<!--<!DOCTYPE html>-->
<!--<html xmlns="http://www.w3.org/1999/xhtml" lang="en">-->
<!--xmlns:math="http://www.w3.org/1999/Math/MathMl">-->
<!--<head>-->
<!--    <meta charset="UTF-8">-->
<!--    <title>Title</title>-->
<!--</head>-->
<!--<body>-->
<!--<p>Normal HTML here.</p>-->
<!--<svg xmlns="https://www.w3.org/2000/svg">-->
<!--    <circle r="50" cx="50" cy="50" fill="red"/>-->
<!--    <rect x="120" y="5" width="90" height="90" stroke="blue" fill="none"/>-->
<!--</svg>-->
<!--</body>-->
<!--<script>-->
<!--    let circle = document.querySelector("circle")-->
<!--    circle.setAttribute("fill", "cyan")-->
<!--</script>-->
<!--</html>-->

<!--<!DOCTYPE html>-->
<!--<html lang="en">-->
<!--<head>-->
<!--    <meta charset="UTF-8">-->
<!--    <title>Title</title>-->
<!--</head>-->
<!--<body>-->
<!--<p>Before canvas.</p>-->
<!--<canvas width="120" height="60"></canvas>-->
<!--<p>After Canvas.</p>-->
<!--<script>-->
<!--    let canvas = document.querySelector("canvas")-->
<!--    let context = canvas.getContext("2d")-->
<!--    context.fillStyle = "red"-->
<!--    context.fillRect(10, 10, 100, 50)-->
<!--</script>-->
<!--</body>-->
<!--</html>-->

<!--<!DOCTYPE html>-->
<!--<html lang="en">-->
<!--<head>-->
<!--    <meta charset="UTF-8">-->
<!--    <title>Title</title>-->
<!--</head>-->
<!--<body>-->
<!--<canvas></canvas>-->
<!--<script>-->
<!--    let cx = document.querySelector("canvas").getContext("2d")-->
<!--    cx.strokeStyle = "blue"-->
<!--    cx.strokeRect(5, 5, 50, 50)-->
<!--    cx.lineWidth = 5-->
<!--    cx.strokeRect(133, 5, 50, 50)-->
<!--</script>-->
<!--</body>-->
<!--</html>-->


<!--<!DOCTYPE html>-->
<!--<html lang="en">-->
<!--<head>-->
<!--    <meta charset="UTF-8">-->
<!--    <title>Title</title>-->
<!--</head>-->
<!--<body>-->
<!--<canvas></canvas>-->
<!--<script>-->
<!--    let cx = document.querySelector("canvas").getContext("2d")-->
<!--    cx.beginPath()-->
<!--    for (let y = 10; y < 100; y +=10){-->
<!--        cx.moveTo(10, y)-->
<!--        cx.lineTo(90, y)-->
<!--    }-->
<!--    cx.stroke()-->
<!--</script>-->
<!--</body>-->
<!--</html>-->


<!--<!DOCTYPE html>-->
<!--<html lang="en">-->
<!--<head>-->
<!--    <meta charset="UTF-8">-->
<!--    <title>Title</title>-->
<!--</head>-->
<!--<body>-->
<!--<canvas></canvas>-->
<!--<script>-->
<!--    let cx = document.querySelector("canvas").getContext("2d");-->
<!--    cx.beginPath();-->
<!--    cx.moveTo(50, 10);-->
<!--    cx.lineTo(10, 70);-->
<!--    cx.lineTo(90, 70);-->
<!--    cx.closePath()-->
<!--    cx.stroke()-->
<!--</script>-->
<!--</body>-->
<!--</html>-->


<!--<!DOCTYPE html>-->
<!--<html lang="en">-->
<!--<head>-->
<!--    <meta charset="UTF-8">-->
<!--    <title>Title</title>-->
<!--</head>-->
<!--<body>-->
<!--<canvas></canvas>-->
<!--<script>-->
<!--    let cx = document.querySelector("canvas").getContext("2d")-->
<!--    cx.beginPath()-->
<!--    cx.moveTo(10, 90)-->
<!--    cx.quadraticCurveTo(60, 10, 90, 90)-->
<!--    cx.lineTo(60, 10)-->
<!--    cx.closePath()-->
<!--    cx.stroke()-->
<!--</script>-->
<!--</body>-->
<!--</html>-->

<!--<!DOCTYPE html>-->
<!--<html lang="en">-->
<!--<head>-->
<!--    <meta charset="UTF-8">-->
<!--    <title>Title</title>-->
<!--</head>-->
<!--<body>-->
<!--<canvas></canvas>-->
<!--<script>-->
<!--    let cx = document.querySelector("canvas").getContext("2d")-->
<!--    cx.beginPath()-->
<!--    cx.moveTo(10, 90)-->
<!--    cx.bezierCurveTo(10, 10, 90, 90, 45, 90)-->
<!--    cx.lineTo(90, 10)-->
<!--    cx.lineTo(10, 10)-->
<!--    cx.closePath()-->
<!--    cx.stroke()-->
<!--</script>-->
<!--</body>-->
<!--</html>-->

<!--<!DOCTYPE html>-->
<!--<html lang="en">-->
<!--<head>-->
<!--    <meta charset="UTF-8">-->
<!--    <title>Title</title>-->
<!--</head>-->
<!--<body>-->
<!--<canvas></canvas>-->
<!--<script>-->
<!--    let cx = document.querySelector("canvas").getContext("2d")-->
<!--    cx.beginPath()-->
<!--    cx.arc(50, 50, 40, 0, 7)-->
<!--    cx.arc(150, 50, 40, 0, 0.5 * Math.PI)-->
<!--    cx.stroke()-->
<!--</script>-->
<!--</body>-->
<!--</html>-->

<!--<!DOCTYPE html>-->
<!--<html lang="en">-->
<!--<head>-->
<!--    <meta charset="UTF-8">-->
<!--    <title>Title</title>-->
<!--</head>-->
<!--<body>-->
<!--<canvas width="500" height="200"></canvas>-->
<!--<script>-->
<!--    const results = [-->
<!--        {name: "Satisfied", count: 1043, color: "lightblue"},-->
<!--        {name: "Neutral", count: 563, color: "lightgreen"},-->
<!--        {name: "Unsatisfied", count: 510, color: "pink"},-->
<!--        {name: "No comment", count: 1175, color: "silver"}-->
<!--    ]-->
<!--    let cx = document.querySelector("canvas").getContext("2d")-->
<!--    let total = results.reduce((sum, {count}) => sum + count, 0)-->
<!--    let currentAngle = -0.5 * Math.PI-->
<!--    for (let result of results) {-->
<!--        let sliceAngle = (result.count / total) * 2 * Math.PI-->
<!--        cx.beginPath()-->
<!--        cx.arc(100, 100, 100, currentAngle, currentAngle + sliceAngle)-->
<!--        currentAngle += sliceAngle-->
<!--        cx.lineTo(100, 100)-->
<!--        cx.fillStyle = result.color;-->
<!--        cx.fill()-->
<!--    }-->
<!--    cx.font = "28px Georgia"-->
<!--    cx.fillStyle = "fuchsia"-->
<!--    cx.fillText("I can draw text, too!", 10, 50)-->
<!--</script>-->
<!--</body>-->
<!--</html>-->

<!--<!DOCTYPE html>-->
<!--<html lang="en">-->
<!--<head>-->
<!--    <meta charset="UTF-8">-->
<!--    <title>Title</title>-->
<!--</head>-->
<!--<body>-->
<!--<canvas width="500" height="200"></canvas>-->
<!--<script>-->
<!--    let cx = document.querySelector("canvas").getContext("2d")-->
<!--    let img = document.createElement("img")-->
<!--    img.src = "https://eloquentjavascript.net/img/hat.png"-->
<!--    img.addEventListener("load", () => {-->
<!--        for (let x = 10; x < 200; x += 30) {-->
<!--            cx.drawImage(img, x, 10)-->
<!--        }-->
<!--    })-->
<!--</script>-->
<!--</body>-->
<!--</html>-->

<!--<!DOCTYPE html>-->
<!--<html lang="en">-->
<!--<head>-->
<!--    <meta charset="UTF-8">-->
<!--    <title>Title</title>-->
<!--</head>-->
<!--<body>-->
<!--<canvas></canvas>-->
<!--<script>-->
<!--    let cx = document.querySelector("canvas").getContext("2d")-->
<!--    let img = document.createElement("img")-->
<!--    img.src = "https://eloquentjavascript.net/img/player_big.png"-->
<!--    let spriteW = 48, spriteH = 60-->
<!--    cx.scale(-1, 1)-->
<!--    img.addEventListener("load", () => {-->
<!--        let cycle = 0-->
<!--        setInterval(() => {-->
<!--            cx.clearRect(-100, 0, spriteW, spriteH)-->
<!--            cx.drawImage(img, cycle * spriteW, 0, spriteW, spriteH, -100, 0, spriteW, spriteH)-->
<!--            cycle = (cycle + 1)% 8-->
<!--        }, 120)-->
<!--    })-->
<!--</script>-->
<!--</body>-->
<!--</html>-->

<!--<!DOCTYPE html>-->
<!--<html lang="en">-->
<!--<head>-->
<!--    <meta charset="UTF-8">-->
<!--    <title>Title</title>-->
<!--</head>-->
<!--<body>-->
<!--<canvas></canvas>-->
<!--<script>-->
<!--    let cx = document.querySelector("canvas").getContext("2d")-->
<!--    cx.scale(3, .5)-->
<!--    cx.beginPath()-->
<!--    cx.arc(50, 50, 40, 0, 7)-->
<!--    cx.lineWidth = 3-->
<!--    cx.stroke()-->
<!--</script>-->
<!--</body>-->
<!--</html>-->

<!--<!DOCTYPE html>-->
<!--<html lang="en">-->
<!--<head>-->
<!--    <meta charset="UTF-8">-->
<!--    <title>Title</title>-->
<!--</head>-->
<!--<body>-->
<!--<canvas></canvas>-->
<!--<script>-->
<!--    let cx = document.querySelector("canvas").getContext("2d")-->
<!--    let img = document.createElement("img")-->
<!--    img.src = "https://eloquentjavascript.net/img/player_big.png"-->
<!--    let spriteW = 48, spriteH = 60-->
<!--    // cx.scale(-1, 1)-->
<!--    img.addEventListener("load", () => {-->
<!--        let cycle = 0-->
<!--        setInterval(() => {-->
<!--            cx.clearRect(0, 0, spriteW, spriteH)-->
<!--            cx.drawImage(img, cycle * spriteW, 0, spriteW, spriteH, 0, 0, spriteW, spriteH)-->
<!--            cycle = (cycle + 1)% 8-->
<!--        }, 120)-->
<!--    })-->
<!--    function flipHorizontally(context, around){-->
<!--        context.translate(around, 0)-->
<!--        context.scale(-1, 1)-->
<!--        context.translate(-around, 0)-->
<!--    }-->
<!--    flipHorizontally(cx, 60)-->
<!--</script>-->
<!--</body>-->
<!--</html>-->


<!--<!DOCTYPE html>-->
<!--<html lang="en">-->
<!--<head>-->
<!--    <meta charset="UTF-8">-->
<!--    <title>Title</title>-->
<!--</head>-->
<!--<body>-->
<!--<canvas></canvas>-->
<!--<script>-->
<!--    function flipHorizontally(context, around){-->
<!--        context.translate(around, 0)-->
<!--        context.scale(-1, 1)-->
<!--        context.translate(-around, 0)-->
<!--    }-->
<!--    let cx = document.querySelector("canvas").getContext("2d")-->
<!--    let img = document.createElement("img")-->
<!--    img.src = "https://eloquentjavascript.net/img/player.png"-->
<!--    let spriteW = 24, spriteH = 30-->
<!--    img.addEventListener("load", ()=>{-->
<!--        flipHorizontally(cx, 100+spriteW /2)-->
<!--        cx.drawImage(img, 0, 0 , spriteW, spriteH, 100, 0, spriteW, spriteH)-->
<!--    })-->
<!--</script>-->
<!--</body>-->
<!--</html>-->

<!--<!DOCTYPE html>-->
<!--<html lang="en">-->
<!--<head>-->
<!--    <meta charset="UTF-8">-->
<!--    <title>Title</title>-->
<!--</head>-->
<!--<body>-->
<!--<canvas height="800" width="800"></canvas>-->
<!--<script>-->
<!--    let cx = document.querySelector("canvas").getContext("2d")-->
<!--    function branch(length, angle, scale) {-->
<!--        cx.fillRect(0, 0, 1, length)-->
<!--        if(length < 17) return-->
<!--        cx.save()-->
<!--        cx.translate(0, length)-->
<!--        cx.rotate(-angle)-->
<!--        branch(length * scale, angle, scale)-->
<!--        cx.rotate( 2 * angle);-->
<!--        branch(length * scale, angle, scale)-->
<!--        cx.restore()-->
<!--        cx.fillStyle = "red"-->
<!--        cx.fillRect(0,0,4,4)-->
<!--        cx.fillStyle = "black"-->
<!--    }-->
<!--    cx.translate(300, 0)-->
<!--    branch(60, 0.5, 0.3)-->
<!--</script>-->
<!--</body>-->
<!--</html>-->


<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Title</title>
    <script type="text/javascript" src="./levels.js"></script>
</head>
<body>
<canvas></canvas>
<script>
    class Level {
        constructor(plan) {
            let rows = plan.trim().split("\n").map(l => [...l]);
            this.height = rows.length
            this.width = rows[0].length;
            this.startActors = []

            this.rows = rows.map((row, y) => {
                return row.map((ch, x) => {
                    let type = levelChars[ch]
                    if (typeof type == "string") return type;  //如果匹配到静态的 墙 岩浆或者空的就返回
                    this.startActors.push( //否则是动态的 有特定的对象和函数
                        type.create(new Vec(x, y), ch)
                    )
                    return "empty"
                })
            })
        }
    }
    class State {
        constructor(level, actors, status) {
            this.level = level
            this.actors = actors
            this.status = status
        }

        static start(level) {
            return new State(level, level.startActors, "playing")
        }

        get player() {
            return this.actors.find(a => a.type == "player")
        }
    }
    class Vec {
        constructor(x, y) {
            this.x = x;
            this.y = y;
        }
        plus(other) {
            return new Vec(this.x + other.x, this.y + other.y)
        }
        times(factor){
            return new Vec(this.x * factor, this.y * factor)
        }
    }
    class Player {
        constructor(pos, speed) {
            this.pos = pos
            this.speed = speed
        }
        get type() { return "player"; }
        static create(pos) {
            return new Player(pos.plus(new Vec(0, -0.5)), new Vec(0, 0))   //这一句 好好理解
        }
    }
    Player.prototype.size = new Vec(0.8, 1.5)

    class Lava {
        constructor(pos, speed, reset) {
            this.pos = pos
            this.speed = speed
            this.reset = reset
        }

        get type() {return "lava"}

        static create(pos, ch) {
            if(ch == "=") {
                return new Lava(pos, new Vec(2, 0))
            } else if (ch == "|") {
                return new Lava(pos, new Vec(0, 2))
            } else if (ch == "v")  {
                return new Lava(pos, new Vec(0, 2), pos)
            }
        }
    }
    Lava.prototype.size = new Vec(1, 1);

    class Coin {
        constructor(pos, basePos, wobble){
            this.pos = pos
            this.basePos = basePos
            this.wobble = wobble
        }

        get type() {return "coin"}

        static create(pos) {
            let basePos = pos.plus(new Vec(0.2, 0.1))
            return new Coin(basePos, basePos, Math.random() * Math.PI * 2);
        }
    }
    Coin.prototype.size = new Vec(0.6, 0.6)

    const levelChars = {
        ".": "empty", "#": "wall", "+": "lava",
        "@": Player, "o": Coin,
        "=": Lava, "|": Lava, "v": Lava
    }

    let simpleLevelPlan = `
......................
..#................#..
..#..............=.#..
..#.........o.o....#..
..#.@......#####...#..
..#####............#..
......#++++++++++++#..
......##############..
......................`;

    const scale = 20


    Level.prototype.touches = function(pos, size, type) {
        var xStart = Math.floor(pos.x)
        var xEnd = Math.ceil(pos.x + size.x)
        var yStart = Math.floor(pos.y)
        var yEnd = Math.ceil(pos.y + size.y)

        for(var y = yStart; y < yEnd ; y++) {
            for(var x = xStart; x < xEnd; x++) {
                let isOutside = x < 0 || x>= this.width || y <0 || y >=this.height;
                let here = isOutside ? "wall" : this.rows[y][x]
                if (here == type) return true;
            }
        }
        return false
    }

    State.prototype.update = function(time, keys) {
        let actors = this.actors.map(actor => actor.update(time, this, keys))
        let newState = new State(this.level, actors, this.status)

        if (newState.status != "playing") return newState

        let player = newState.player;
        if (this.level.touches(player.pos, player.size, "lava")) {
            return new State(this.level , actors, "lost")
        }

        for (let actor of actors) {
            if (actor != player && overlap(actor, player)) {
                newState = actor.collide(newState)
            }
        }
        return newState
    }








    class CanvasDisplay {
        constructor(parent, level) {
            this.canvas = document.createElement("canvas")
            this.canvas.width = Math.min(600, level.width * scale)
            this.canvas.height = Math.min(450, level.height * scale)
            parent.appendChild(this.canvas)
            this.cx = this.canvas.getContext("2d")

            this.flipPlayer = false

            this.viewport = {
                left: 0,
                top: 0,
                width: this.canvas.width / scale,
                height: this.canvas.height / scale
            }
        }
        clear() {
            this.canvas.remove()
        }
    }
    CanvasDisplay.prototype.syncState = function(state) {
        this.updateViewport(state)
        this.clearDisplay(state.status)
        this.drawBackground(state.level)
        this.drawActors(state.actors)
    }

    CanvasDisplay.prototype.updateViewport = function(state) {
        let view = this.viewport, margin = view.width / 3
        let player = state.player
        let center = player.pos.plus(player.size.times(0.5))

        if(center.x < view.left + margin) {
            view.left = Math.max(center.x - margin, 0)
        } else if (center.x > view.left + view.width - margin) {
            view.left = Math.min(center.x + margin - view.width, state.level.width - view.width)
        }
        if(center.y < view.top + margin) {
            view.top = Math.max(center.y - margin, 0)
        } else if (center.y > view.top + view.height - margin) {
            view.top = Math.min(center.y + margin -view.height, state.level.height - view.height)
        }
    }

    CanvasDisplay.prototype.clearDisplay = function(status) {
        if(status == "won"){
            this.cx.fillStyle = "rgb(68, 191, 255)"
        } else if (status == "lost") {
            this.cx.fillStyle = "rgb(44, 136, 214)"
        } else {
            this.cx.fillStyle = "rgb(52, 166, 251)"
        }
        this.cx.fillRect(0, 0, this.canvas.width, this.canvas.height)
    }

    let otherSprites = document.createElement("img")
    otherSprites.src = "./sprites.png"
    CanvasDisplay.prototype.drawBackground = function(level) {
        let {left, top, width, height} = this.viewport;
        let xStart = Math.floor(left);
        let xEnd = Math.ceil(left + width);
        let yStart = Math.floor(top);
        let yEnd = Math.ceil(top + height);

        for (let y = yStart; y < yEnd; y++) {
            for (let x = xStart; x < xEnd; x++) {
                let tile = level.rows[y][x];
                if (tile == "empty") continue;
                let screenX = (x - left) * scale;
                let screenY = (y - top) * scale;
                let tileX = tile == "lava" ? scale : 0;
                this.cx.drawImage(otherSprites,
                    tileX,         0, scale, scale,
                    screenX, screenY, scale, scale);
            }
        }
    };

    let playerSprites = document.createElement("img")
    playerSprites.src = "./player.png"
    const playerXOverlap = 4

    function flipHorizontally(context, around){
        context.translate(around, 0)
        context.scale(-1, 1)
        context.translate(-around, 0)
    }

    CanvasDisplay.prototype.drawPlayer = function(player, x, y,
                                                  width, height){
        width += playerXOverlap * 2;
        x -= playerXOverlap;
        if (player.speed.x != 0) {
            this.flipPlayer = player.speed.x < 0;
        }

        let tile = 8;
        if (player.speed.y != 0) {
            tile = 9;
        } else if (player.speed.x != 0) {
            tile = Math.floor(Date.now() / 60) % 8;
        }

        this.cx.save();
        if (this.flipPlayer) {
            flipHorizontally(this.cx, x + width / 2);
        }
        let tileX = tile * width;
        this.cx.drawImage(playerSprites, tileX, 0, width, height,
            x,     y, width, height);
        this.cx.restore();
    };

    CanvasDisplay.prototype.drawActors = function(actors) {
        for (let actor of actors) {
            let width = actor.size.x * scale;
            let height = actor.size.y * scale;
            let x = (actor.pos.x - this.viewport.left) * scale;
            let y = (actor.pos.y - this.viewport.top) * scale;
            if (actor.type == "player") {
                this.drawPlayer(actor, x, y, width, height);
            } else {
                let tileX = (actor.type == "coin" ? 2 : 1) * scale;
                this.cx.drawImage(otherSprites,
                    tileX, 0, width, height,
                    x,     y, width, height);
            }
        }
    };









    function overlap(actor1, actor2) {
        return actor1.pos.x + actor1.size.x > actor2.pos.x &&
            actor1.pos.x < actor2.pos.x + actor2.size.x &&
            actor1.pos.y + actor1.size.y > actor2.pos.y &&
            actor1.pos.y < actor2.pos.y + actor2.size.y;
    }

    Lava.prototype.collide = function(state) {
        return new State(state.level, state.actors, "lost")
    }
    Coin.prototype.collide = function(state) {
        let filtered = state.actors.filter(a => a!=this)
        let status = state.status
        if(!filtered.some(a => a.type == "coin")) status = "won"
        return new State(state.level, filtered, status)
    }

    Lava.prototype.update = function(time, state) {
        let newPos = this.pos.plus(this.speed.times(time))
        if (!state.level.touches(newPos, this.size, "wall")) {
            return new Lava(newPos, this.speed, this.reset)
        } else if (this.reset) {
            return new Lava(this.reset, this.speed, this.reset);
        } else {
            return new Lava(this.pos, this.speed.times(-1)) //反弹
        }
    }

    const wobbleSpeed = 8, wobbleDist = 0.07
    Coin.prototype.update = function(time) {
        let wobble = this.wobble + time * wobbleSpeed
        let wobblePos = Math.sin(wobble) * wobbleDist
        return new Coin(this.basePos.plus(new Vec(0, wobblePos)), this.basePos, wobble)
    }

    const playerXSpeed = 7
    const gravity = 30
    const jumpSpeed = 17

    Player.prototype.update = function(time, state, keys) {
        let xSpeed = 0;
        if (keys.ArrowLeft) xSpeed -= playerXSpeed
        if (keys.ArrowRight) xSpeed += playerXSpeed
        let pos = this.pos
        let movedX = pos.plus(new Vec(xSpeed * time, 0))
        if (!state.level.touches(movedX, this.size, "wall")) {
            pos = movedX
        }

        let ySpeed = this.speed.y + time * gravity;
        let movedY = pos.plus(new Vec(0, ySpeed * time))
        if (!state.level.touches(movedY, this.size, "wall")) {
            pos = movedY
        } else if (keys.ArrowUp && ySpeed > 0) {
            ySpeed = -jumpSpeed
        } else {
            ySpeed = 0
        }
        return new Player(pos, new Vec(xSpeed, ySpeed))
    }


    function trackKeys(keys) {
        let down = Object.create(null)
        function track(event) {
            if(keys.includes(event.key)) {
                down[event.key] = event.type == "keydown";
                event.preventDefault()
            }
        }
        window.addEventListener("keydown", track)
        window.addEventListener("keyup", track)
        return down
    }

    const arrowKeys = trackKeys(["ArrowLeft", "ArrowRight", "ArrowUp"]);

    function runAnimation(frameFunc) {
        let lastTime = null
        function frame(time) {
            if (lastTime != null) {
                if (lastTime != null) {
                    let timeStep = Math.min(time - lastTime, 100) / 1000
                    // let timeStep = 0.5
                    if (frameFunc(timeStep) == false) return;
                }
            }
            lastTime = time;
            requestAnimationFrame(frame);
        }
        requestAnimationFrame(frame)
    }

    function  runLevel(level, Display) {
        let display = new Display(document.body, level);
        let state = State.start(level)
        let ending = 1
        return new Promise(resolve => {
            runAnimation(time => {
                state = state.update(time, arrowKeys);
                display.syncState(state)
                if(state.status == "playing") {
                    return true;
                } else if (ending > 0) {
                    ending -= time;
                    return true
                } else {}
                display.clear()
                resolve(state.status)
                return false
            })
        })
    }

    async function runGame(plans, Display){
        for (let level=0; level <plans.length;) {
            let status = await runLevel(new Level(plans[level]), Display)
            if ( status == "won") level++
        }
        alert("You've won!")
    }






    runGame(GAME_LEVELS, CanvasDisplay)
</script>

</body>
</html>
