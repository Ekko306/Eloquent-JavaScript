title,url,tags,description,comments,annotations,created_at
"Bugs and Errors :: Eloquent JavaScript","http://eloquentjavascript.net/08_error.html","no_tag","""function canYouSpotTheProblem() {
  for (counter = 0; counter < 10; counter++) {
    console.log(""Happy happy"");
  }
}

canYouSpotTheProblem();
console.log(this.counter)
console.log(window.counter)
console.log(counter)""","","Highlight:Another change in strict mode is that the <code>this</code> binding holds the value
Sticky notes:⬆️  没有写 let，js内部在全局window/this创建变量，用“use strict”阻止
——————————————————————
⬇️  没有写new，对于面向对象用到的this（指向实例，在第六章），js内部会把this错误的作为全局window/this，用“use strict”阻止

看实际都是 全局的 this，上面是隐式的设计到全局this，而下面是在类的构造函数显式的this和全局this冲突

非strict都会出错
Highlight:those caused by the thoughts being confused and those caused by mistakes introduced while converting a thought to code.
Sticky notes:bug分成两种
一种是思想混乱的逻辑上的错误
一种是代码程序里的错误

第二种代码程序的错误更容易解决
Highlight:There are some things that JavaScript does complain about
Sticky notes:这一节名字叫LANGUAGE，就是说明JavaScript这个语言的特性：

1、js的语言的绑定和属性的概念很模糊，所以有些变量拼写错了程序段只有在运行的时候才会报错。然后在执行没意义的操作比如 true * ""monkey""也不会报错
（这里的报错是指运行结果后有“TypeError“等红色返回结果，无意义的计算不会红色出错，对比C语言，只要出一点错误比如分号漏了，这种类型不对的计算或变量未定义都会指出来）

2、但是有些是js会报错的：比如不符合语法的、调用不存在的函数或者 let of一个undefined的值，会报错

3、但是其它很多情况，没有意义的计算只是会成功运行，顶多返回值是NaN或者undefined，然后一步步影响后面大的程序就很难找到。
Highlight:debugging
Sticky notes:减少bug的术语 debugging
Highlight:""use strict""
Sticky notes:可以用简单的在代码最上面加“use strict”
来避免一些基本的问题（有限）
下面是两种情况，其实本质上属于一类，是防止了 全局变量的自动创建和绑定

什么意思呢，就是全局其实是有个this绑定的
console.log(window === this) -> true

1、看下面的counter 没有 let  其实就是js偷偷创建了一个window.counter
2、还有再下下面 console.log(name) 本质上也是偷偷创建了一个window.name（本质上是console.log(window.name)）

use strict 可以防止
有个博客可以学学

https://www.cnblogs.com/itwhite/p/12242109.html
这里先说说window和this的概念，让你更清晰理解
Highlight:forget to put <code>let</code> in front of your binding
Sticky notes:上面是""use strict""会报错counter没有定义

如果是非""use strict""，看我运行下面的代码就懂了
function canYouSpotTheProblem() {
  for (counter = 0; counter < 10; counter++) {
    console.log(""Happy happy"");
  }
}

canYouSpotTheProblem();
console.log(this.counter)
// -> 10
console.log(window.counter)
// -> 10
console.log(counter)
// -> 10

调用了canYouSpotTheProblem()之后就在全局偷偷新建变量

但是如果加了 let 就不是在 window全局加，下面代码报错：
function canYouSpotTheProblem() {
  for (let counter = 0; counter < 10; counter++) {
    console.log(""Happy happy"");
  }
}

canYouSpotTheProblem();
console.log(this.counter)
// -> undefined
console.log(window.counter)
// -> undefined
console.log(counter)
// -> ReferenceError: counter is not defined
Highlight:undefined
Sticky notes:下面是在定义面向对象的类的时候，显式的用到this变量

如果是use strict 构造函数里this 就是 undefined

如果不是use strict 构造函数里this 就是默认全局的window/this
（当没有new 的时候 如果有new 就还是正常绑定到实例）
Highlight:Another change in strict mode is that the <code>this</code> binding holds the value
Highlight:different.
Sticky notes:可以试着改一下他的代码更深入打印一些研究理解，参考我的，
⬆️
function Person(name) { this.name = name; }
let ferdinand = Person(""Ferdinand""); // oops
console.log(name);
console.log(this.name)
console.log(window.name)

⬇️
""use strict"";
function Person(name) { 
  console.log(this)
  this.name = name; 
}
let ferdinand = Person(""Ferdinand""); // forgot new
console.log(name)
Highlight:Fortunately
Sticky notes:好的是 es6新定义的class语法 不允许我们没有new来调用，直接出错

strict还可以做更多的事比如
“它不允许给一个函数使用多个具有相同名称的参数，并且完全删除了某些有问题的语言功能（例如with语句，这是非常错误的，因此本书不做进一步讨论）” 
——谷歌翻译

总之在代码最上面用“use strict”很简单也可以减少一些问题
Highlight:implicitly convert values to the type it expects
Sticky notes:js本来就不是强类型语言，前面第一章就讲过，js里的运算会隐式自动转换类型完成一些操作，但是这样有时候会造成问题
Highlight:You could add a comment like the following before the <code>goalOrientedRobot</code>
Sticky notes:⬆️  介绍js里的类型type容易出错
————————————————
⬇️  介绍防范js出错的一些方法
Highlight:describe
Sticky notes:1、第一种方法，在函数前面写注释
说明参数的类型，防止迷惑出错
(VillageState, Array) → {direction: string, memory: Array}

然后类型的另外一个作用是：
“关于类型的一件事是，它们需要引入自己的复杂性，以便能够描述足够的代码以供使用。”
可以用注释提供更多信息，比如我们randomPick就可以写注释：
([T] -> T)

意思是字符串数组挑出来是字符串，数字数字挑出来是数字 
[""abc"", ""ad""] => ""abc""
[123, 33] => 123
Highlight:pointing out mistakes before the program is run.
Sticky notes:2、第二种方法就是用一些预处理语言来限定，在js程序运行之前，进行类型检测

有很多js的方言（扩展语言的意思），比如typescript，可以在程序运行前规范一些错误，可以尝试学学使用
Highlight:Automated testing
Sticky notes:因为js语言不能很好的帮我们检查错误，我们就需要通过运行程序再来判断错误，

但是手工的一次次运行检查很麻烦，而计算机最擅长的是就是做重复的工作，所以 我们可以写自动检查语法错误的程序，每当文件修改的时候就检查语法

这个工作是一劳永逸
Highlight:toUpperCase
Sticky notes:然后我们看下我们简单的例子，展示test函数的执行逻辑

下面代码好理解，body是一个函数参数
Highlight:<em>test runners</em>.
Sticky notes:写这种test runners检测程序是很麻烦的，但是好在有很多现成的软件根据语法提供合适的检测方法和在出错的时候输出结果

有些代码好检查，但是有些深入一些的object有属性值就更难检查错误，我们前章的机器人程序是用的自定义的常量程序而不是检查对象就方便检查很多
Highlight:triggered the problem is simply the first place
Sticky notes:一旦我们发现的错误，第一个反应是解决这个错误

有时候这个错误很明显，程序会报错在那一段哪一行出错了，大多数情况

但有的情况程序只会在第一次调用的地方报错，但是在其它地方运行的时候才会实际出错，有些之前的练习就能发觉（就是不容易找的错误）

下面给个没有报错的错误例子，该如何解决？
Highlight:The following example program tries to convert a whole number to a string in a
Highlight:<code>console.log</code> call
Sticky notes:当上面程序出现错误，两种解决思路：
1、随机多试一些地方，看改改哪里可能解决问题

2、从头到位分析是阿里可能出现问题，然后在可能觉得有问题的地方增加额外的代码测试（比如增加conso,log）

3、这里立即就觉得n有蹊跷，所以增加
 do {
    result = String(n % base) + result;
    n = n / base
    console.log(n)
  } while (n > 0);

发现n 很难达到0 ，错误是 没有向下取整数，加上Math.floor函数就能解决

这个是思路，用console.log细查[less than a minute ago]
当上面程序出现错误，两种解决思路：
1、随机多试一些地方，看改改哪里可能解决问题

2、从头到位分析是阿里可能出现问题，然后在可能觉得有问题的地方增加额外的代码测试（比如增加conso,log）

3、这里立即就觉得n有蹊跷，所以增加
 do {
    result = String(n % base) + result;
    n = n / base
    console.log(n)
  } while (n > 0);

发现n 很难达到0 ，错误是 没有向下取整数，加上Math.floor函数就能解决

这个是思路，用console.log细查[less than a minute ago]
Highlight:An alternative to using <code>console.log<span class=""diigoHighlightCommentLocator""></span></code> to peek into the program’s behavior is to
Sticky notes:⬆️   分析我们的例子和思路 —————————————————— 
⬇️  说一下浏览器的调试工具
Highlight:breakpoint
Sticky notes:其实还有更科学的方法，跟C语言在codeblocks里进行调试的方法一样

JavaScript也可以在浏览器环境进行调试，也是打断电，根据不同的浏览器调试的方法也大同小异，可以网上找一些，也可以开组会分享浏览器调试的方法

另外另一个设置断点的方法是加一个debugger关键字，浏览器运行时会自动停下
Highlight:debugger
Highlight:by anybody else
Sticky notes:如果程序上线 面临的错误情况可能很复杂
比如得到畸形的输入，让程序过载或网络崩溃

到实际环境中给用户肯定不是简单的崩溃，我们应该结束错误的输入然后继续运行我们的程序，或者另一种能发生崩溃报告然后放弃本次运行，每种方法都需要积极的响应错误，下面是个例子
Highlight:Say you have a function <code>promptNumber</code> that asks the user for a number and
Sticky notes:⬆️  介绍ERROR PROPAGATION的意思，就是说当实际环境中有错误需要积极的处理错误（错误传播）
——————————————————
⬇️  一个小例子说明解决错误的方式之一
Highlight:check whether an actual number was read and
Sticky notes:这里我们的立即，积极响应非数字类型的输入，是return null，这样也能继续运行下去


再积极的解决方法是，要么重复再问一次，要么告诉用户他怎么错的原因
Highlight:In many situations, mostly when errors are common and the caller should be
Sticky notes:⬆️  例子 解决错误 返回特殊值 null / undefined/ -1
——————————————————
⬇️  但是简单的返回特殊值 null/ undefined / -1 也有问题
Highlight:downsides
Sticky notes:返回 错误的特定值 null/undefined/-1是一个好方法，但是也有他的坏处：

1、第一个坏处，就是我们正确的值也可能是null/undefined/-1的一种，我们这时候不是简单的返回混淆的null/undefined/-1，而是可以是更清晰的对象比如{failed: true}

2、第二个坏处，直接返回null/undefined会让代码很丑很奇怪，如果一个代码调用10次paromptNUmber，就需要检查10次有没有出现null，然后如果这个“检查”的操作又出错了也是返回null就不太好
Highlight:exception handling
Sticky notes:当一个函数出错了，接下来应该做的是停下现在做的然后立即跳到另外一个可以处理问题的地方去。这个叫做exception handling 意外处理
Highlight:super-charged return from a function
Sticky notes:意外处理的机制 有点像第三章的函数调用栈的原理：
它跳出当前的函数，和调用当前的函数的函数，一直到到最开始调用这个函数的函数（也就是一直在调用栈里追根溯源找有哪些函数一路用到了 unwinding 你看见react报错也是这个原理 有一大串设计的函数）

会throw away 出所有遭遇到的内容
Highlight:right down to the bottom of the stack
Sticky notes:exceptions 意外的作用不仅仅是 一直向前查找栈找出相关的函数，

还有更有用的作用是会沿着栈设置“obstacles”障碍来抓住移动时候的exception， 一旦抓到了障碍的的根源 可以 定位问题 然后 继续运行（这个应该是底层报错的原理，它几句也说不清楚，感兴趣可深入研究）
Highlight:Here’s an example:
Sticky notes:⬆️  理论
————————————————
⬇️  例子
Highlight:try/catch
Sticky notes:这个Java里也有 类似概念就是在try/catch块里执行代码，这样如果出了错 也可以正确的执行这个try/catch逻辑 继续运行下面的代码 而不至于这个歌程序崩溃掉

要理解一点的就是
1、try里面的 throw error：
throw new Error(""Invalid direction: "" + result);

2、这个传入到Error的参数（""Invalid direction: "" + result）
可以用到 catch关键字的error离去
catch (error) 

这里error = ""Invalid direction: "" + result

这样进行一些自定义的操作
Highlight:stack
Sticky notes:Error是一个类，传入报错信息做构造函数，会存放到Error.message属性里

也会保存一些调用栈的信息，存储在Error.stack里
可以用来告诉哪里出错了
Highlight:the big advantage of exception
Sticky notes:这里有个个exception的好处就是，只需要在可能出现问题的地方定义throw error
其它地方完全可以不考虑会出错

比如这里promptDirection函数定义了出错的情况

而look函数包含了 promptDirect 就不需要加上一个判断if(promptDirect 发生错误)这种情形 可以忘记

简洁的交给look处理
Highlight:control flow
Sticky notes:这个控制流我也不太懂啥东西，感兴趣可以网上搜一下，例如https://blog.csdn.net/cengjingcanghai123/article/details/34222813

这里简单看懂书的意思（控制流简单理解为程序本应该从上到下执行的顺序）：
就是说任何可能产生exception的操作会导致失去控制流，而失去控制流会导致有些代码不会正常执行
Highlight:Here is some really bad banking code.
Sticky notes:⬆️  模糊的概念讲解
————————————————
⬇️  例子
Highlight:transfer
Sticky notes:首先 transfer函数的作用是 将A的钱转移到B的账户去

from是A的钱
执行transfer只会 会有一个 prompt 弹出一个框 让你输入B的名字 

如果B的名字有问题 则 throw exception 

导致了问题下面的问题
Highlight:<code>transfer</code> <em>first</em> removes
Sticky notes:问题就是首先执行了减少钱的工作
accounts[from] -= amount;

增加钱的工作accounts[getAccount()] += amount;

这里getAccount() 出现了报错，那么控制流就不会继续执行了 就会有钱不翼而飞 有问题

一种解决思路是先调用getAccount() 确认没错了再执行增减钱的操作

但是还是有问题 有些看上去不会初肤哦的函数可能在例外的环境或者包含编程问题的时候出错（最科学还要看下面的方法）
Highlight:One way to address this is to use fewer side effects. Again, a programming style
Sticky notes:⬆️  分析问题
——————————————
⬇️  解决问题
Highlight:finally
Sticky notes:更好的方法是减少副作用，放弃增减已经存在的钱，而是进行计算新的值的操作，这样就算计算新的值出问题也不会直接破坏增减了已经存在的钱

所以有个 finally关键字 就是 无论是否报错 都会执行finally的操作
Highlight:repairs
Sticky notes:解释上面的代码：
1、有一个finally操作，当throw error 的时候把已经减掉的钱加回去

2、可以发现finally 不像 catch(error) 一样，finally完全没有error参数，也就是说不关系是否发生了error 总会在try执行完毕后执行一些操作。（然后finally只会前面说的error回退找错误栈还是继续）

3、写一个可靠的能正确处理exceptions的程序是很困难的，有些人根本不在乎，因为他们觉得发生的情况少，直到错误导致软件出了很大问题才知道 处理exception的严重性
Highlight:careful about data corruption
Sticky notes:当一个exception一直出错没有被我们catch捕捉的时候，我们JavaScript运行的环境最后会帮我们捕捉。js运行的环境有 浏览器 和 node.js(第20章详细讲)两种

node.js 对崩溃的错误捕捉更小心，

浏览器的错误捕捉通常在console打印台里爆红看出来，还有一些调用站的信息
Highlight:Invalid uses of the language,
Sticky notes:但是错误分两种：

1、一种是我们直到可能会出现的错误，比如之前的银行例子，我们直到B的账户名字可能会输错，这时候我们可以把A的钱加进去或者运行其它的操作

2、但是另一种就是我们不知道的错误（实际运行中保留这种未知的错误是很坏的策略）
比如取一个不存在的绑定，找一个null的属性、或者调用不存在的函数。
这种错误也会被捕捉

当catch被执行了，我们直到try里面出错了，但是并不知道是1类型还是2类型出错
Highlight:doesn’t provide direct support for selectively catching exceptions: either you catch them all or you don’t catch any.
Sticky notes:但JavaScript不支持我们选择性的处理错误

要么你全部接收错误，要么不处理错误，这个就要求你必须预知你要处理的错误是什么类型

但是要求太高有可能不知道，比如一些其它的情况设计或者有bug造成了错误

看底下代码就是 catch(e) 里的错误不是我们预想的到的，完全没有正确响应到
Highlight:misspelled <code>promptDirection</code>
Sticky notes:上面例子本意是：
用无限循环for(;;) 不断的询问我们要选left还是right，如果非left/right，就告知Not a valid direction. Try again.

但是实际问题是我们拼写错了promptDiection，正确的错误是“undefined variable”，但是出乎意料，不是我们料想的错误（和上面的分析一致是第2类错误）

导致浏览器报错 程序崩溃
Highlight:As a general rule, don’t blanket-catch exceptions unless it is for the purpose of
Sticky notes:⬆️  展示我们理论出现的错误情况
-————-————————————
⬇️  修正解决问题
Highlight:And even
Sticky notes:一般来说，除非是为了在某处“路由”异常，例如，通过网络告诉另一个系统我们的程序崩溃了，否则不要笼统地捕捉异常。即便如此，也要仔细考虑你可能是如何隐藏信息的。
Highlight:catch a <em>specific</em> kind of exception
Sticky notes:下面是我们的解决方法，我们想定义一种专门我们前面的“left/right 选择错误”类型的错误，用来和别的类似变量拼写错误的错误区分开来 好在catch里正确的处理

方法是class InputError extends Error
Highlight:ompare its <code>message</code>
Sticky notes:一种解决方法是可以比较 Error.message属性来判断是什么错误，但是作者觉得很不靠谱，

这样是对比
""Invalid direction: abc""
和
ReferenceError: prompdtDirection is not defined (line 3 in function eval)

这两种信息 一种机器报错一种人类语言，一旦 人类语言更改了就不能用了 所以用下面更科学的方法
Highlight:inherits the <code>Error</code> constructor
Sticky notes:InputError 继承了 Error方法 也继承了Error的构造函数 只是再封装了一层 然后 e instanceof InputError 能正确判断对象的类型 可以正确判断

底下代码看懂了可以好理解

这样catch(e) 里就可以正确判断是什么类型的错误了，然后分类正确处理
（单词打错可以正确报错出来）
Highlight:Assertions
Sticky notes:这个assertions 是断言的意思
就是更明白通知你错误的意思，并不用来处理正常操作可能出现的情况，而是告知程序

看下面代码就懂了

平常我们array.length == 0 得到的是undefined
但是如果我们加了 assertions断言 就会变成
throw new Error(""firstElement called with []"");
大声的红色报错告诉你 你错误使用了这个函数 可以更方便的告诉你问题

但是不建议所有的地方都写上这种断言，不然会很吵很麻烦，很多地方随便就出现红色报错，可以在容易出错的地方加上断言
Highlight:Summary
Sticky notes:潦草总结：
1、错误和坏的输入可能会出现，变成更需要修bug，如果有好的开发者工具我们可以自动test减少程序错误（webstorm或者vscode）

2、某段代码应该本地就能解决问题（及其不准不知道作者意思），在函数里return特殊的值或者用throw error很好用

3、注意try/catch 和 finally逻辑（我也不懂 可以看别的书深入学习）
","2020-11-07 08:48:19"
"Handling Events :: Eloquent JavaScript","https://eloquentjavascript.net/15_event.html","no_tag","","","Highlight:respond to it as it happens
Sticky notes:本章的“事件”与众不同的是，它是面对用户的输入，鼠标或者键盘，这些操作是间断实时的，你不能预测用户什么时候执行了这些操作

所以要绑定一些“事件”，监听这些事件发生的时候来进行一些操作
Highlight:whether a key on the keyboard is being pressed
Sticky notes:以前的方法：
比如为了检查一个按键是否被按下，需要持续周期的家呢keyboard的状态，万一有别的任务占用资源没检测到就错过了。

有些原始的机器就是用这种“polling轮询”的方式，按键了之后会将信息添加到一个队列里去，然后要去周期的查看这个队列有没有按键，这样检测和按下之间的间隔是空白不响应的不好
Highlight:Most programmers prefer to avoid it.
Sticky notes:⬆️  通过周期检测key的状态判断时候有按键事件（老过时）
————————————————————
⬇️  通过注册handlers事件 当事件发生的时候让操作系统积极响应
Highlight:window
Sticky notes:一个更好的解决方法是当事件发生的时候积的响应，浏览器允许我们用“handlers”来绑定事件。

window是浏览器内置绑定，代表浏览器的包含document的窗口，调用addEventListener来绑定事件，第一个参数是事件名称，第二个参数是事件触发的调用函数
Highlight:context
Sticky notes:看了半天这个context，是上下文的中文意思（就是可以具体绑定，而不是只绑定到window大的上）

意思好理解就是event handler 可以绑定到window也可以绑定到DOM节点，

看下面就是绑定到button节点上，点击button就会触发事件，而如果是window.addEventListener就会绑定到整个渲染页面，随便点都会触发
Highlight:<code>onclick</code> attribute
Sticky notes:可以直接加一个onclick 的 attribute到节点上，如：

<button onclick=""click()"">Click me!</button>

其它的也类似，可以在事件前面加“on”来构成属性attribute，比如onkeydown，ontouch

这样方便，但是局限是只能绑定一个事件触发函数，
addEventListener可以绑定多个
Highlight:removeEventListener
Sticky notes:removeEventListener 看名字都懂

注意是传入第二个参数要和addEventListener的事件处理函数一致
Highlight:This object holds additional information
Sticky notes:好理解，就是有些事件（这里“mousedown”，后面还有很多其它的）

的触发函数可以是带一个参数的函数参数

例子是：
event => {...} ，这个event参数包含这个事件的一些额外的信息（比如这里mousedown，event是个objcet包含点击的按键，坐标等信息）

通用：
任何event.type 指明事件的名字(""click'或""mousedown"")
Highlight:But
Sticky notes:传播的两条规则：
1、如果父节点绑定了“click”之类事件，当点击子节点的时候也会触发父节点的事件

2、如果父节点和子节点都定义了相同类型事件（比如“click”），这时候就要判断优先级，原则是：子节点的事件优先级高于父节点（重载），这样顺序是
a、子节点“click”
b、父节点“click”
c、window的“click”
Highlight:Propagation
Sticky notes:这个单词中文：传播

主要讨论：如果有父子关系的节点，父/子节点绑定了事件该如何触发？
Highlight:stopPropagation
Sticky notes:注意这个event.stopPropagation()方法

是为了打破上面说的继承“传播”规则，
子节点调用event.stopPropagation()会阻止父节点的同类事件（比如下面同“click”事件）触发，看下面例子很好理解。

用stopPropagation来完成更复杂灵活操作
Highlight:target
Sticky notes:父子传播关系触发事件，父节点还提供很方便的event.target来指明那个子元素被点击

这样可以灵活处理被点击的元素触发的事件，并且方便不需要每个子节点都麻烦绑定一个个
Highlight:Key events
Sticky notes:下面一大堆讲事件，不要害怕每个都很短，目录：

- Key events
- Pointer events 
    - Mouse clicks
    - Mouse motion
- Touch events
- Scroll events
- Focus events
- Load event
Highlight:preventDefault
Sticky notes:就是有些event是浏览器默认的事件（比如点击链接跳转，按键盘的⬇️ 页面下移），可以调用e.preventDefault()来阻止默认的事件，而自定义自己的事件

啰嗦两点：
1、最好不要阻止默认行为，除非自己定义特别好，不然用户得不到预期很气愤
Highlight:keydown
Sticky notes:说明按键事件的基本：
1、如名字有两种按键事件""keyup""和""keydown""

2、keydown按键要注意的是，它不仅仅在按下去一瞬间会触发，而一直按着一个键会不断的触发keydown事件
Highlight:<code>key</code> property
Sticky notes:因为键盘有很多组合（用户有普通按键还有组合键），下面讲下“按键的key属性”要注意的：

1、普通的按键，event.key显示""v"" / ""B""这种，经过测试只能有一个字母，同时按下多个字母无效。

2、特殊的键比如""ENTER""，event.key显示内容是""Enter""
按住SHIFT按键，得到的event.key的内容是大写“B”或者""@""这种（就跟打在记事本一致）

3、组合的按键，如果想判断是否按下了特殊修饰键，可以配合event.shiftKey/ctrlKey/altKey/metaKey使用就像下面例子：
event.key == "" "" && event.ctrlKey

注意有没有和笔记本的热键冲突（mac的切换中英文是ctrl+space，按了半天没用，改了代码ctrl+t才有用）
（这里还注意有些ctrl+v可能会触发多次打印，而ctrl+t只会触发一次，还是可能和default事件影响有关，但原理上是只会触发一次的，先学基本）
Highlight:focus
Sticky notes:1、注意这里有个“focus”的问题，就是说你的“keydown”等事件，只有点击一个页面或输入框（网站生成的代码交互栏，要点一下生成页面的再按键才会检测，如果点到外面的书内容网站按键没有用）

2、大多节点不能focus，除非给一个tabindex的属性，但是有些默认是可以的比如links，button，form field
可以到18章具体学习

3、如果页面都没有focus元素，默认用document.body
Highlight:key events
Sticky notes:这个地方作者没有说清楚，我不跟你说也很容易迷糊过去吧
就是不要用“key”事件来获取用户的输入

就是这里说key事件的历史，用key检测键盘输入有问题：
1、某些平台（尤其是Android手机上的虚拟键盘）不会触发按键事件。
2、即使您使用的是老式键盘，某些类型的文本输入也无法直接匹配按键，例如脚本不适合键盘的人所使用的输入法编辑器（IME）软件， 多个按键组合在一起以创建字符。

所以输入比如在一个<input>标签里输入内容，就不要用“key”事件检测输入，要用“input”事件来检测用户的输入，在18章可以学习更多
Highlight:two
Sticky notes:两种广泛使用的指针事件：
1、鼠标事件
Mouse CLICK + MOTION
2、触摸事件
Touch Events
Highlight:he pr
Sticky notes:一个鼠标点击下各事件触发情况
1、点击一个DOM节点，立即触发mousedown和mouseup

2、上面1结束只会，看click事件根据鼠标开始位置和结束位置的节点触发（可能鼠标点击拖拽，事件能检测出那两个始末节点涉及并完成一些操作）

3、如果点击两次，触发“dblclick”事件
Highlight:To get precise information about the place where a mouse event happened, you
Sticky notes:⬆️  将鼠标点击一下背后的多个事件及条件
——————————————————
⬇️  获取鼠标点击触发事件的event+小例子
Highlight:to the t
Sticky notes:event参数可以包含鼠标点击点的参数：

1、clientX和clientY属性表示相对于window窗口的坐标

2、pageX和pageY属性表示相对于文档流的坐标（包含scroll下来的）

下面小例子根据click事件加点（你可以试下点击拖拽验证一下上面学的（结果是最后的位置显示点））
Highlight:mousemove
Sticky notes:这一小节就是 “mousemove”事件，只要鼠标移动就会触发（不需要点击然后移动，下面的例子是需要点击然后拖拽）

看懂下面例子很好理解

注意先看懂下面蓝色注释
Highlight:<code>buttons</code> property (note the plural)
Sticky notes:首先注意上面代码的event.button和event.buttons的区别（上面event.button==0和event.buttons==0不是同一含义）

https://wangdoc.com/javascript/events/mouse.html#mouseeventbutton%EF%BC%8Cmouseeventbuttons

button==0表示左键
buttons==0表示没有按键
buttons可以检测多个鼠标按键按下（用得少吧）先看懂这个不然上面代码难理解
Highlight:isn’t very robust
Sticky notes:1、早期触摸屏少，浏览器用“mousedown”、“mouseup”和“click”的鼠标mouse事件来代替

2、但是鼠标和触摸屏的机制不一样，有问题比如：
a、触摸没有多个buttons
b、当没有触摸的时候不能跟踪手指（mousemove不管有没有点击都会触发检测移动）
c、触摸屏可以同时按多个点（mouse事件不能满足）

3、mouse事件只能包括一些简单的touch交互，复杂的比如缩放就不能用mouse替代
Highlight:touchscreen.
Sticky notes:⬆️  以前触摸屏用的少，古老的web开发者用mouse事件来代替touch事件但是有很多问题（两者原理不同而且特性不一样）
————————————————————
⬇️  简单讲一下新touch事件以及应用
Highlight:touchscreens
Sticky notes:“touch”事件新特性：

1、
“touchstart”事件当手指触摸开始触发
“touchmove”事件当触摸的时候移动触发
""touchend""事件当停止触摸屏幕的时候触发

2、因为触摸屏可以按很多点，所以没有单个点的属性，只有 touches属性，像一个数组包含按的所有点的
clientX/clientY和pageX和pageY

下面例子很神奇，可以用触摸的时候手指画一个圈，注意它的update函数，是先删除所有的点，然后画出所有的点

这样配合 start =》 move =》 end事件可以很好实现逻辑（有手指触摸就显示）
Highlight:scroll
Sticky notes:当滚动元素的时候触发""scroll""事件（前提是这个元素足够高，能有滚动条让你滚动）

这非常有用：
1、觉察用户正在看什么元素
2、禁止出屏动画
3、发送邪恶的报告（根据浏览的位置）
4、显示下面例子的进度条

看下面代码好理解
Highlight:fixed
Sticky notes:1、这里用position: fixed
让上面的进度条固定在最上面
Highlight:innerHeight
Sticky notes:2、用%来更科学的显示百分比，下面来讲怎么计算和小细节：

let max = document.body.scrollHeight - innerHeight;
bar.style.width = `${(pageYOffset / max) * 100}%`;

a、-innerHeight是因为滑动到最底部不能滑动了，上面百分比要减去最底下的（页面高度），才能到最底下就显示100% 自己实验一下
b、pageYOffset表示当前滚动的位置
结合当前位置计算百分比

3、”scroll“事件的preventDefault不能阻止滚动发生（实际上是滚动只会才调用scroll事件所以不能阻止）
Highlight:do not propagate.
Sticky notes:聚焦和失焦事件好理解

主要是注意focus和blur不同于前面讲的事件，这个不会传播propagate就是说子节点的聚焦不会触发父节点的聚焦事件

然后看下面的例子懂了就很简单

window也可以加聚焦和失焦
Highlight:display them.
Sticky notes:一大堆事件终于讲完了
Highlight:""load""
Sticky notes:""load""事件相关的，正好三小点
1、window/ document.body 的“load”事件会在整个页面加载完成之后触发，值得注意的是<script>标签包含的代码会在页面加载后立即调用，这比页面完全加载出来要快，所以要有一个“load”事件来实现页面完成之后的操作

2、一些大一点的 img/script 也有“load”事件，他们加载完的时候进行特定操作，并且这种也不会传播propagate

3、当一个页面被关闭或a链接等导航不见了，会触发一个“beforeunload”事件，这个事件是用来确认询问是否保存，可以设置returnValue来自定义对话框。
但是有点网站可能会用这个属性来放广告，有点浏览器不支持了
Highlight:behave like other asynchronous notifications
Sticky notes:event handlers和其它的异步操作一样，也是必须等其它程序完成之后才能有效执行。

这样只有没有后台程序运行的时候才能检测事件event的结果就是，可能任务多了会阻止运行，会很卡很慢
Highlight:For cases where you <em>really</em> do want to do some time-consuming thing in the
Sticky notes:⬆️  11章里面说的事件循环，会对本章学习的event handler也会阻塞（情况遇得少，这里先说明可以了解学一下以后有具体应用抓紧学）
————————————————
⬇️  解决方法和小例子
Highlight:<em>web workers</em>.
Sticky notes:一种解决方法是使用 web workers （一个worker是一个js进程，在主进程之外运行，（多线程运行））

假设将一个数平方是一个繁重的、长时间运行的计算，我们希望在一个单独的线程中执行。我们可以写一个叫做代码的文件/squareworker.js它通过计算一个正方形并返回一条消息来响应消息。
Highlight:avoid the problem
Sticky notes:具体代码实现上下两段代码例子说明的，注意小点：

1、防止作用域重叠互相影响，这里新建一个code/squareworker.js的文件 并通过 发送”message“的方式通信

2、调用postMessage会发送一个信息，导致“message”事件触发，这时候分两部分
a、主脚本里的
主进程里创建额外的线程通过Work对象发送和接收信息

b、code/squareworker.js 里面的：
然后这个额外的线程就直接和主脚本a里通信，通过直接在全局作用域里发送和监听

3、只有JSON格式的值可以被当作message发送，而其它格式的值只会返送传递copy
Highlight:<code>setTimeout</code> and calling <code>clearTimeout</code>
Sticky notes:定时器很容易理解

就像下面用：
setTimeout来设置定时器，然后setTimeout的返回值handler用来传递到 clearTimeout里 来取消定时器
Highlight:cancelAnimationFrame
Sticky notes:然后这种绑定然后清除的方法一脉相承，底下两种都这个样子用

1、requestAnimationFrame和cancelAnimationFrame

2、setInterval和clearInterval
Highlight:<code>setInterval</code> and <code>clearInterval</code>
Highlight:potential to fire rapidly, many t
Sticky notes:（debouncing直接翻译这样，跟电路里的防抖动一样，就是你的按下一个键或者浏览器操作动一下点一下实际上出发了好几十次相同的事件）

有些类型的事件比如“mousemove”和“scroll”事件可能在很短事件触发很多次，这时候事件函数里就不能写太耗费事件的操作，不然会显得特别卡顿

如果非要执行这种好事操作，可以用setTimeout来保证不会太频繁调用
Highlight:<em>debouncing</em> the event. There are several slightly different approaches to this.
Sticky notes:⬆️  讲弹跳的概念，有几种解决方法
————————————————————
⬇️  解决方法之一
Highlight:first example
Sticky notes:下面的例子，我们不像太快速的响应用户输入

于是定义setTimeout(() => console.log(""Typed!""), 500);

比较特别的是我们子啊每个setTimeout之前定义
clearTimeout来把之前的计时器消除

这样是如果我们很快连续的点击一个键，这样会重复触发""input""事件（小于0.5s），为了不出错要把前一次的timeout的handler清除掉

然后clearTimeout对undefined的值或一个已经实现的setTimeout不会有影响，可以放心调用，只会在满足条件清除成功，不会报错
Highlight:We can use a slightly different pattern if we want to space responses so that
Sticky notes:⬆️  第一种防止弹跳的方法
————————————————
⬇️  第二种防止弹跳的方法
Highlight:separated by at least a certain length of time
Sticky notes:如果想不同于上面的，上面是每次输入完的最后过0.5s触发事件（新的事件会覆盖前面的，阻塞前面的）

如果像下面这样，像每次间隔0.25s触发事件，就可以像下面这样写，是有不同的，下面这个更适用于mosemove事件（不像上面input，如果用上面的防止弹跳方法可能只有每次停下来才会打印出来坐标，这里只要只要一直移动就会间隔0.25周期打印）
Highlight:Summary
Sticky notes:潦草的总结：
1、用addEventListner可以让用户和浏览器有很多监听和交互操作

2、事件函数的参数 event.type 可以指明当前触发的是啊斤
大多数事件可以在某个DOM元素触发，也可以像父节点propagate传播到祖先节点，让相关的节点也可以处理类似的事件

3、可以用stopPropagation和preventDefault来阻止传播和触发浏览器默认方法

4、按下一个键盘上的键触发“keydown”和""keyup""事件
鼠标点击触发""mousedown""和""mouseup""和""click""
触摸屏幕触发""touchstart"" 和 “touchmove"" 和 ""touchend""

5、滚动可以用 “scroll”
聚焦和失焦有 ‘“focus”和""blur""
加载有""load""
","2020-11-03 08:40:44"
"The Document Object Model :: Eloquent JavaScript","https://eloquentjavascript.net/14_dom.html","no_tag","","","Highlight:Document Object
Sticky notes:这一章是讲js和html的搭配关联了，（比如js获取html的DOM节点）

所以会带上很多html的相关知识
Highlight:model of the document’s structure
Sticky notes:浏览器会解析一个page的HTML解析转换成一个“The Document Object Model”，原理类似我们第12章搞的蛋语言解释器。

这是一个可以修改的数据结构，并且是实时的，一旦更改页面就会刷新。
Highlight:Document Object Model
Sticky notes:我们 html 封装的代码 会像盒子一样构成上面直观的格式，这种格式叫做Document Object Model，简称DOM

全局绑定document 让我们能够获取上面的的DOM对象获取文档树

document.documentElement属性获取到<html>标签，还有head和body属性指向对应标签。
Highlight:tree
Sticky notes:这主要将tree（又和第十二章的Egg language混在一起比来比去说不明白看半天，这里分段翻译理解）
1、第1章的结构体和浏览器文档的机构提特别类似。具体是每个节点可以参考到其它子节点，然后子节点还可以有子节点。这是一种典型嵌套结构可以反复包含子节点。

2、（上面说的这种嵌套结构就是树结构）当一个数据结构有分支结构，没有循环联系节点的时候我们叫做一个tree。树结构肯定有一个根节点，对于DOM可以用document.doumentElement来获取。

3、这个和计算机科学很有联系，这种方式（树结构）可以很好代表这种HTML或项目的递归结构，他们可以用来存储数据集因为元素可以很方便的存储或插在在一个树结构比一个平的数组。

4、一个典型的树结构有不同的节点，比如Egg language 语言有id、value和application节点，application节点可能也有子节点，而identifiers和值是树叶没有子节点。（看第十二章，具体意思就是树形结构，有的有子节点，有的没有子节点）
Highlight:The same goes for the DOM. Nodes for <em>elements</em>, which represent HTML tags,
Sticky notes:⬆️   上面是说计算机科学的tree概念（和Egg language一起比较学习）

——————————————————

⬇️   再回过头来具体讲DOM
Highlight:a node is <code>document.body</code>
Sticky notes:这对DOM的节点来表示HTML标签也是类似的，DOM就决定了整个文档的结构，这些DOM即可以有子节点。

一个例子是document.body，body可以有叶子节点，叶子节点可以包含文字或者注释节点。
（人要崩溃 完全没有逻辑这些介绍写的）
Highlight:nodeType
Sticky notes:每个DOM节点对象还包含nodeType属性，来指明这个节点的类型（就是有的节点是<h1>这种标签，有的节点是纯文字比如 My home page 这里有特定数字表示出来）
看下面总结：
1、code 1 代表元素(h1这些) Node.ELEMENT_NODE.Text
2、code 3 代表文字 Node.TEXT_NODE
3、code 8 代表注释 Node.COMMENT_NODE

下面还有一个图很清晰
Highlight:The standard
Sticky notes:下面这个是关于DOM的历史影响的，作为背景只是了解就行，不需要太较真。

1、问题是，前面的code 3 (Node.TEXT_NODE)这种东西看起来很奇怪，而且后面会看到很多DOM奇怪的东西，原因是，这种DOM文档结构最初不是专门为JavaScript设计的，而是设计者想最初作为一种通用的结构（XML这种通用数据结构也能使用）

2、统一的标准很好，但是在这里DOM的标准（通用的标准）反而让JavaScript里面使用DOM很冗余很不好用。（学一门专门给Javascript设计的DOM远比通用的DOm更容易）

3、举例来说哪里不方便：
比如DOM节点拥有childNodes属性，这个属性“像是一种数组样子的对象”，但实际上是DOM里面定义的NodeList类型，所以它没有js里数组通用的slice和map方法。

4、然后还有例子这种标准造成的问题：
例如没有方法创建一个新的节点然后立即加子节点或者attributes上去，反而只能用副作用，先创建，然后加子节点和属性一步步来，要经常操作DOM就很长重复和丑。

5、但是这个问题不是致命性的，
js可以自己封装抽象，搞一些很方便的库来操作DOM
Highlight:nearby nodes
Sticky notes:这里看下面的图很清晰，就是说一下DOM里面如何互相获取节点。下面有很多方法。
Highlight:childNodes
Sticky notes:最直观的方法parentNode和childNodes

这两个方法每个节点都有，就是指向父节点和子节点数组
Highlight:additional convenience links
Sticky notes:理论上用上面两个方法就可以获取到所有相关的节点，但是有一些复杂应用还是比较麻烦，提供一些额外方便的链接方法：
1、firstChild和lastChild属性指向子元素组里的第一个和最后一个（没有子元素会返回null）

2、previousSibling和nextSibling指向同父节点相邻的兄弟节点（如果没有前向或后向兄弟节点就返回null）
Highlight:children
Sticky notes:还有一个children属性，类似childNodes，但是children属性不会有嵌套的子元素属性
只会有单一直接相关的子元素

这对获取text节点很有用。
Highlight:recursive functions
Sticky notes:处理这种DOM的嵌套的数据结构，用递归的函数非常方便。

看下面的例子代码（前提只是nodeValue来获取text节点的值）

还有底下的例子代码我试了三种，各种都有区别：
1、我的这个浏览器环境安装了diigo插件，把整个页面封装了一层，会有问题，最后停止到
''‘This page has the following structure:""

2、新开一个浏览器环境，取消giigo插件，运行代码，最后停止到：
“I also wrote a book! Read it”
这个结果是正确的，检测到“book”这一行就停下来了

3、还有用本章最上面的例子：
<!doctype html>
<html>
  <head>
    <title>My home page</title>
  </head>
  <body>
    <h1>My home page</h1>
    <p>Hello, I am Marijn and this is my home page.</p>
    <p>I also wrote a book! Read it
      <a href=""http://eloquentjavascript.net"">here</a>.</p>
  </body>
</html>
控制台停下来是最后的.
（还有一个区别是，第3个不会检查到</html>这样认为是Node.TEXT_NODE这种打印出来，12会打印出来）

三种运行代码一摸一样是：
function talksAbout(node, string) {
  if (node.nodeType == Node.ELEMENT_NODE) {
    for (let child of node.childNodes) {
      if (talksAbout(child, string)) {
        return true;
      }
    }
    return false;
  } else if (node.nodeType == Node.TEXT_NODE) {
    console.log(node.nodeValue)
    return node.nodeValue.indexOf(string) > -1;
  }
}

console.log(talksAbout(document.body, ""following""));

可能是浏览器环境有问题（diigo插件影响和打开的方式，http协议和file协议打开有区别，之后再去看，然后说一句这里它代码块运行环境是My home page这个页面的，并不是这个14_dom.html整个页面可以运行上面的代码看看）
Highlight:found
Sticky notes:代码结果有出入跟运行环境有关不用太纠结，主要理解它的思想意思
Highlight:parents, children, and siblings
Sticky notes:上面一小节说的可以获取父母节点，兄弟节点特别好用但是有时候比较麻烦，原因是html文档是动态改变的，可能点击一个按钮增加了几个元素，整个html文档的父子兄弟关系就变了，他给的例子是下面的，空格也算做子元素，所以需要一种更方便不是基于固定关系的定位节点的方法。

<body>
    
    <h1>My home page</h1>
    
    <p>Hello, I am Marijn and this is my home page.</p>
    
    <p>I also wrote a book! Read it</p>

  </body>
Highlight:Get the first link in the document”
Sticky notes:这里就很清楚，就是说“获取文档里的第一个链接a标签”总会比“获取文档的第二个子元素的第六个子元素”更好。下面有具体三种方法这样根据标志获取html元素：

1、getElementsByTagName()
注意这里是Elements，根据tag名字（a，div，p这种tag名来获取），获取的是一个数组，可以根据索引获取。

2、getElementById()
这个根据id来获取唯一的元素（id=“gertrude”这种因为htmlid是唯一的这里也能唯一定位一个元素）。

3、getElementsByClassName()
注意这里是Elements，根据class来获取所有有相同class属性的元素（class=""blue""这种获取所有蓝色字体的元素集）
Highlight:shape of the document<span class=""diigoHighlightCommentLocator""></span> tree
Sticky notes:可以通过改变父子关系的结构来改变“document tree”文档书的结构（也就是说就算顺序变了也是完全不一样的结构树了，会重新渲染出新页面）

下面又说一些方法操作获取的节点
1、remove()
child.remove()
一个子节点调用，然后从父节点删除这个子节点

2、appendChild()
parent.appendChild(newChild)
一个父元素调用，讲一个新子元素放到父元素的子元素集的最后一个。

3、insertBefore()
parent.insertBefore(nodeA .nodeB)
一个父元素调用，子元素里把nodeA放到nodeB元素的后面

4、replaceChild()
parent.replaceBefore(nodeC, nodeD)
一个父元素调用，子元素里用nodeC取代nodeD元素
Highlight:only one place
Sticky notes:因为一个文档里一个节点存在

所以调用insertBefore() 方法来移动一个元素会将旧的元素先删除，然后移动到新的位置（这个是副作用）

（但是如果insertBefore(A，B)传入参数A是你新定义的一个参数就不存在这个问题，你就是新加一个节点 ）
Highlight:document.<wbr>createTextNode
Sticky notes:1、document.createTextNode() 方法创建一个文字节点

2、应用是下面的小例子，删除img节点然后用text节点替换，看懂代码好理解。
Highlight:live
Sticky notes:上面代码有奇怪的 i--
主要因为getElementsByTagName是实时的，如果是array=[image1, image2]
delete array[0]
array = [image2]
这样索引 i 不好确定

所以是
array=[image1, image2]
delete array[1]
array=[image1]
delete array[0]      （i--）
Highlight:elt
Sticky notes:1、这个函数全书见到很多应该熟悉，是将子节点加到父节点方法

2、下面好理解，看懂代码就是应用createElement

Highlight:If you want a <em>solid</em> collection of nodes, as opposed to a live one, you can convert
Sticky notes:⬆️  document.createTextNode() 方法和小例子
——————————————————
⬇️  Array.from()这个方法，用来将一个动态对象变成静态不变的数组，上面的小例子就展现了动态对象的不便性，需要用i--
Highlight:Array.from
Sticky notes:这个Array.from方法可以把一个动态getElementsByTagName类似这种方法获取到的对象转换成一个真正的 静态数组
（可能应用是把这个之前获取到的保存起来吧，比如insertBefore方法会修改之前的DOM结构，

因为getElementsByTagName获取到的对象是类似
{0: ""one"", 1: ""two"", length: 2}这种的0和1作为对象的key，很容易转换成数组，如果对象是{""name"": ""syp"", ""age"": 20}这种还很难转成数组）

反正是一种静态保存的方法
Highlight:To create element nodes, you can use the <code>document.<wbr>createElement</code> method.
Sticky notes:⬆️  Array.from 方法
——————————————
⬇️  document.createElement() 方法
Highlight:set any attribute you want
Sticky notes:1、标签元素element有很多内置的attributes属性比如href

除了内置的也可以自己设置/获取自定义attribute（但自己定义的attribute必须用getAttribute获取，内置的getElementBy等方法获取的节点检测不到自定义attribute）

2、getAttribute获取属性
setAttribute设置属性
Highlight:class
Sticky notes:上面代码和设置/获取属性好理解，主要是下面两个小注意点：
1、新attribute命名最好要这种“data-xxx”，防止与内置属性冲突。

2、第二点无关紧要：就是class是css的样式属性，但是对某些低端浏览器有问题（那些低端浏览器的class命名是className，但可以在低端浏览器上用set/getAttribute自定义来解决这种问题）
一般低端的浏览器都不用了。
Highlight:For any given document, browsers are able to compute a layout
Sticky notes:“layout”是布局的意思，
html里面不同种类的元素有不同的布局

1、块级元素
<p> <h1>这些，占用一整行宽度。并且渲染在分隔的行里
2、内联元素
<a> <strong>这些，占用宽度只是内容撑起来的宽度。并且和其它周围元素渲染在一行。

然后浏览器渲染出页面的的机制是：
对于任何一个html文档，基于元素类型和内容计算每个元素大小和位置（确定布局layout），然后渲染出最终结果。
Highlight:The size and position of an element can be accessed from JavaScript. The
Sticky notes:⬆️  介绍 “layout” 的概念
————————————————
⬇️  介绍js里获取元素的“大小size” 和 “位置position” 的方法
Highlight:pixels
Sticky notes:获取元素size大小的方法：
1、offsetWidth和offsetHeight
给出实际占有的大小（包含border）
（再科普像素pixel的概念，像素最初定义是计算机屏幕上一个最小的发光点，但对现代的高像素显示器不再适用，一个像素可能是多个点了）

2、clientWidth和clientHight
给出净占有的大小（不包含border）
Highlight:position
Sticky notes:获取位置position的方法：

1、getBoundingClientRect()函数
返回一个对象 {top, bottom, left, right}
相对于屏幕窗口打开的防伪

2、pageXOffset和pageYOffset
返回基于文档流的x和y坐标（从上到下的位置坐标，包含scroll）
Highlight:Laying out a document can be quite a lot of work. In the interest of speed,
Sticky notes:⬆️  元素的size和position 
——————————————
⬇️  布局的效率问题
Highlight:wait as long as they can
Sticky notes:1、浏览器渲染一个布局需要很多工作，为了包含保证速度，浏览器的解决方案是“尽可能推迟更新”，当可能有多个更新准备好的时候一起更新

2、浏览器更新document的两种条件：
a、js程序完成对document的更改
b、读取布局位置属性offSetHight/调用getBoundingCLientReact

3、重复修改DOM布局会要大量时间，重复导致效率很低

4、下面是一个小例子，
第一种while循环重复调用appendChild反复操作DOM

第二种定义target.firstChild.nodeValue = ""X"".repeat(total);这种方法一次赋予text只进行一次DOM操作

第二种效率很高
Highlight:style
Sticky notes:1、 HTML 里不同的 元素渲染出来不同，有的块级有的内联，有的加醋<strong> ， 有的蓝色有下划线<a>

2、这些渲染出来的样子不同很大部分是因为元素的类型不同(<img> <a>)，我们那可以改变style的attribute来改变样式
下面的小例子

3、想要style的attribute里写多种样式用 分号分隔好就行
""color: red; border: none""
Highlight:display
Sticky notes:很多style都可以改（废话，不是css里所有的都是可以放到style里吧）

这里具体说下 display样式：
1、display: block 可以把一个内联元素变成块级
2、display: none 防止展现在屏幕上
（这是会隐藏元素，但是不推荐，还是最好删除掉一个元素然后之后再放回去便于再次显示）
Highlight:JavaScript code can directly manipulate the style of an element through the
Sticky notes:⬆️  style 的 display
——————————————
⬇️  js操作 改变style
Highlight:style
Sticky notes:1、元素节点有一个style指向这个attribute
可以用js操作改变（属性值是字符串）
小例子好理解

2、还有因为是属性名，不方便修改一些css里的“font-family”这样的分隔符属性，改成小驼峰命名法，例如

para.style.fontFamily = ""songti""
Highlight:A lot of aspects of the document can be influenced by styling. For example, the
Sticky notes:⬆️  html的 style 属性简单使用
————————————
⬇️  html的 style 属性的“display” （其实还是在讲css）
Highlight:CSS
Sticky notes:这JS书还讲起了CSS，就是最简单的css语法（然而必须要有前期学习css的知识，第一次看肯定有点懵，比如下面specificity这个是读了深入理解css才明白的，大一大二的我来读完全不懂），下面东一句西一句，我来简单调理总结。
Highlight:final style
Sticky notes:下面一堆特别混乱瞎说主要三点：

1、锁定元素的方法有三种
a、class        .subtle
b、id              #header
c、tag name       strong
也可以这三种混合更精确定义 比如p#main.a.b这种注意不能有空格之间（有点小区别，看这个很清楚：https://www.cnblogs.com/liuting1314521/p/6185020.html）

2、在<style>标签里对同一样式可能有重复定义，这时候要考虑优先级和级联规则，判断冲突的时候到底选哪一个style propety属性，规则如下（这本书简化版，其实一大堆）：
a、写在后面的覆盖前面的规则
b、越精细的（上面说的多定位组合），定位优先级更高 比如 p .a 高于 p
（其实很不严谨）

3、
p > a {....} 子元素选择器，选择直接关系的元素
p a{....}  后代选择器， 不一定是直接关系子元素，可以有嵌套爷父子关系都选中

（这讲的很散 不系统，要认真学去看看 CSS In Depth）
Highlight:this same mini-language
Sticky notes:哦哦 为啥要潦草的讲一下css呢，因为css的嵌套锁定语法（子元素选择器，p .animal这种css专有的语法）可以用到query selectors 里去用js获取DOM元素

querySelectorAll接收一个query 字符串，然后返回NodeList数组
Highlight:<em>not</em> live
Sticky notes:1、querySelectorAll不是实时的，不会像getElementxxx一样会改变，但是返回的也不是数组，需要变为数组要用Array.from

2、querySelector类似，只不过不是返回所有结果的组合，而是返回第一个匹配到的或null
Highlight:position
Sticky notes:css的position属性，好好总结一下：

1、默认不设置是static，就在原始元素该在的位置，不能设置top/right，只能写margin-left/margin-top，加一段距离，一直存在本分的文档流里面

2、设置relative，相对于本身位置改变，如果不加top/right就和static完全一样，也是在本分的文档流里面，可以先写margin-left/margin-top定位好原来的，然后如果想要这个元素相对于“原来”位置偏移就加上top,left，这个时候可能会和其它元素重叠

3、而absolute重要是“脱离文档流”，就是整个元素从本来应该在的位置删掉了（relative是原来的位置还在，只是加了top/left偏移了不本分），删掉了原来文档流的位置，然后根据最近的非static或如果没有相对文档流的位置，独立出来定位

不知道把你绕晕没有，强烈建议去在线网站试一试：
https://www.w3school.com.cn/tiy/t.asp?f=csse_position_absolute

把前半段我的抄进去：
<html>
<head>
<style type=""text/css"">
body {
background-color: lightblue;
}
h2.pos_abs
{
position:relative;
margin-top: 400px;
top: 30px;
background-color: pink;
}
p{
background-color: lightgreen;
}
</style>
</head>

然后把relative改成absolute，或者改下top/margin-top体会一下
Highlight:animation
Sticky notes:然后下面是应用学的postion小例子说一大堆解释代码，别害怕看我分析

还有下面程序运行了 浏览器会占比较多cpu和内存不停的绘制，注意消耗
Highlight:requestAnimationFrame
Sticky notes:1、肯定你对这个函数理解有问题。
这个requestAnimationFrame的参数是一个函数参数A

这个函数参数A的第一个参数是默认传入当前的时间，比如下面
requestAnimationFrame(newTime => {console.log(""当前时间是："", newTIme)});

然后这个函数是每次浏览器允许repaint整个页面的的时候调用，大概的频率是60FPS，比较流畅

2、为什么我们不采用for + 频繁改动DOM的原因是这样会东接住页面，因为浏览器不会在js程序运行的时候刷新页面，也不允许进行交互。所以我们要用麻烦的requestAnimationFrame，来告诉浏览器我们要更新了并且做一些操作。

3、还有我们的angle也有讲究，是根据newTime和上一次的time计算出来的，这样就很丝滑流畅还有加速度的感觉，底下一段英文塑料英语六级阅读一样搞得看半天
If it just moved the angle by a fixed amount per step, the motion would stutter if, for example, another heavy task running on the same computer were to prevent the function from running for a fraction of a second.

就是说如果是固定角度页面就很不流畅一卡一卡的刷新，就仿佛是电脑运行了其他占cpu程序导致你的浏览器很卡的渲染一样（分几步显示几分之秒的画面），这个英语搞得烦人
Highlight:Moving in circles is done using the trigonometry functions <code>Math.cos</code> and
Sticky notes:⬆️  实现的方法技巧，难点理解requestAnimationFrame啥的
——————————————————
⬇️  说明球面坐标来绘制曲线运动
Highlight:multiplied
Sticky notes:上面的根据角度计算坐标，圆周啥的小学生都会，过一遍就行，再就是底下两点注意：
1、angle是一个全局变量，不断的更新，然后高的基准是20，宽的基准是200，所以看起来扁一点

2、再就是要带上单位 绝对单位px或相对单位em啥的，忘了单位就不会正常渲染，除非0可以没单位（还是去学css in depth这里讲得很业余，其实没单位也有好处应用）
Highlight:Summary
Sticky notes:1、js可以操作html生成的DOM结构，DOM展现浏览器的文档模型，可以用ks更改DOM完成操作

2、DOM是一种树形结构，每个节点可以相互寻找，有子节点父节点，兄弟节点等

3、DOM还可以很方便更改style改变一些样式。
","2020-10-27 08:42:51"
"前端路由两钟实理方法_百度搜索","https://www.baidu.com/s?ie=UTF-8&wd=%E5%89%8D%E7%AB%AF%E8%B7%AF%E7%94%B1%E4%B8%A4%E9%92%9F%E5%AE%9E%E7%90%86%E6%96%B9%E6%B3%95","no_tag","","","","2020-10-27 05:52:03"
"https://eloquentjavascript.net/18_http.html","https://eloquentjavascript.net/18_http.html","no_tag","","","Highlight:Communication must be stateless in nature [...] such that each request from client to server must contain all of the information necessary to understand the request, and cannot take advantage of any stored context on the server.
Sticky notes:通讯本质上必须是无状态的，以便从客户端到服务器的每个请求都必须包含理解该请求所必需的所有信息，并且不能利用服务器上任何已存储的上下文。
Highlight:detail
Sticky notes:这一节详细讲更多http的细节，前面13章只是和浏览器提起提到过
Highlight:body
Sticky notes:当浏览器输入一个网址，浏览器会向服务器端建立TCP协议，并在80端口（默认）进行连接，如果存在有效，则浏览器和服务器会分别发出request和response


还有这个body提一下，在response里
一些信息发送完成后，会空一行，显示完整的html信息
这个html信息称为response的body（不要和html的<body>标签混淆）
Highlight:The information sent by the client is called the <em>request</em>. It starts with this line:
Sticky notes:上面展示具体request和response的格式，然后之后解读
—————————————————————
下面讲request的具体结构
Highlight:GET
Sticky notes:首先讲request请求的具体细节：（只讲第一行）
1，第一个关键字是请求方法，有GET获取资源，DELETE删除资源，PUT创建或者修改资源，POST给服务器发送信息，不是所有请求server都会响应，比如可能不会响应你的DELETE操作
2、第二个数请求的请求的资源这里是一个html文件，有很多网站不需要后面固定写html文件，请求一个路径就会在服务器查找正确的话服务器会生成一个页面然后在body里返回，比如https://github.com/marijnh
3、再后面一个数是 HTTP/1.1 是说明HTTP请求的版本
现在有版本2 效果更好，增加了更多的功能，但是常用的还是1.1更加直观容易学习，浏览器给服务器端发送请求的时候会自动判断自己用1.1版本还是2版本。
Highlight:The server’s response will start with a version as well, followed by the status of
Sticky notes:上面是request的具体细节
———————————————————
下面是response的具体细节
Highlight:response
Sticky notes:response 响应结构比较清晰：
1、第一行 HTTP/1.1 200 说明版本号和状态码status code
不同的status code有特定含义
2xx 表示成功
4xx 表示请求方有问题
5xx 表示服务器方有问题

2、后面是headers 一些头部信息，是name：value的形式展示更多信息：
Content-Length: 65585
Content-Type: text/html
Last-Modified: Thu, 04 Jan 2018 14:05:30 GMT
说明返回文档大小 65586 bytes
类型 html
上次修改时间
Highlight:For most headers, the client and server are free to decide whether to include
Sticky notes:之后是request和response归纳一起总结
Highlight:won’t
Sticky notes:然后两个细节：
1、request和response可以自由的添加头部信息，但是request的头部信息有两个是必须的，一个是Host另一个是User-Agent，host好理解是请求的服务器ip地质，而User-Agent有点难理解因为有的电脑可能是多用户运行的（比如linux操作系统，可能多个用户用同一台电脑，不同用户有不同的用户名），加上User-Agent指明用户名就可以在多个用户计算机上正确通信了。

2、定义完headers信息之后，request或response会空一行然后包含一些body内容，有特殊情况：
1、request的GET和DELETE不会包含body，但是PUT和POST会包含
2、response大多包含body，除了一些少数的例如error responses
Highlight:Browsers and HTTP
Sticky notes:下面就展示了浏览器发送http请求的例子
Highlight:A moderately complicated website
Sticky notes:浏览器如何发送请求呢？

就是在地址栏输入一个ip地址回车，就会请求一个网页，如果这样网页也包含了其他的文件例如图片和js文件，他们也会被一起请求。

一个现代的网站可以轻松的包括10～200个资源，为了快速获取那些资源，浏览器会同步发送多个GET请求，而不是一个个请求浪费时间。

然后看下面的<form>标签的例子，允许用户写一个发送GET请求的例子
Highlight:This code describes a form with two fields: a small one asking for a name and a
Sticky notes:上面是说明浏览器与请求的关系
————————————————————
下面解释<form>标签发送GET请求的例子
Highlight:query
Sticky notes:上面的html代码，写着<form>标签用来通过http发送一个表单 写了 method = “GET” ，当填写完信息之后，点击button，就是发送GET请求，而GET请求通过 query 的形式发送，例如

GET /example/message.html?name=Jean&message=Yes%3F HTTP/1.1

然后讲一下因为要在网路上传输，不能包含“？”这样的特殊符号（因为和区分字段的？冲突了呀就不知道到底是字符的？还是区分字段的？），就用encodeURIComponent来进行编码，以 %3F的形式传输。

编码规则是以16进制来进行编码。

用decodeURIComponent来解码
Highlight:If we change the <code>method</code> attribute of the HTML form in the example we saw
Sticky notes:⬇️ 下面说明改成POST方法会怎么样，并一起讲POST方法和GET方法的区别
Highlight:POST
Sticky notes:GET请求用来获取数据，而POST请求一般是用来在服务器端更改一些东西的，例如创建账户或发送信息，这时候用POST请求就会有一个 response 的 body，而不是在URL里直接写query string。

有些浏览器也不会盲目的发送POST请求，只是会而通常会隐式地发出GET请求，例如预取它认为用户不久将需要的资源。来保证安全合理。

后面一点再仔细讲<form>表单
Highlight:fetch
Sticky notes:浏览器做http请求的方法是 fetch方法（之前是xmlhttprequest是旧的过时的方法了），fetch方法为什么新呢就是：
1、fetch支持了promise
2、调用fetch方法返回一个promise，这个promise包含了浏览器返回值的信息，例如status code、headers，headers是用Map似的对象包含关键词的，所以要用get来获取，因为header不区分大小写，所以Map类的的键也是不区分大小写的。

这样headers.get(""Content-Type"")  
等同于 headers.get(""content-TYPE"")
Highlight:rejected
Sticky notes:fetch返回的是一个promise，就算服务器端返回错误的status code，他也是会resolve

如果因为网络错误或者地址找不到 会 reject
Highlight:<code>fetch</code> is the URL
Sticky notes:然后再就是fetch方法里传入的URL参数
1、当没有以“http:” 开头，地址就默认为相对的比如example/data.txt 这里example就是相对与当前获取的的文档的目录（这里是搞个特殊一点自己定义例子https://eloquentjavascript.net/syp/18_http.html
相对于18_http.html这个文件的路径 syp
）
2、但是如果地址开头有""/""，就是绝对路径，就是直接跟在ip地址后面。比如写“/example/data.txt”
实际路径就是
https://eloquentjavascript.net/example/data.txt

3、如果地址开头没有""/""，则是夹在相对URL后面，比如写“example/data.txt”，实际路径是：
https://eloquentjavascript.net/syp/example/data.txt

他道理说的很模糊，例子也很模糊，就是基础的linux知识
Highlight:text
Sticky notes:可以用 text() 或 json()方法 获取 response的body实际内容
这里要注意的是，response最后获取到了，但是要读取出内容还需要一个异步操作（可能返回的文本内容比较大还需要几秒读取），所以有两个then

json方法不同于text方法是获取response的json格式，但是要有严格的json文本格式，然后转为JSON格式的对象
Highlight:fetch
Sticky notes:然后底下是更多的fetch可以添加的方法：
1、换方法，传入{method: ""DELETE""}
2、增加 headers信息，传入{headers: {Range: ""bytes=8-19""}}
3、浏览器会自动添加一些headers，比如Host和body的大小

但是自己添加自定义headers很有用，可以在request告诉服务器端返回特定大小文件或者特定文件形式
Highlight:Access-Control-Allow-Origin: *
Sticky notes:这个跨域问题 这里简单说是几句，但是实际应用的时候够你折腾的（开发匣子的h5编辑器就有跨域问题）

就是说一个域名有一个服务器，一般网络请求只能是在本域名下的网站请求本服务器底下的资源（图片，js资源等）

因为跨域请求资源会有安全性问题，比如一个银行的脚本被跨域抢走了 把你的存款都搞没了。

解决方法是在server的headers里面加一个新设置项：Access-Control-Allow-Origin: *
这样就可以解决跨域请求问题

（这里提一下，其实跨域阻拦是浏览器的行为，因为服务器端发出的response本来已经包含敏感内容了，只是没有Access-Control-Allow-Origin: *这个字段又发现域名不一样，浏览器就会自己阻拦你不让你用跨域资源）
Highlight:communication between a JavaScript program running in the browser (client-side) and a program on a server (server-side)
Sticky notes:就是本地的浏览器（客户端）如何和远程服务器（服务器端）通信，这里介绍了两种通信模型。

第一种最常用的叫做remote procedure call（远程过程调用）
这种模型是通过本地调用普通的函数，但是背后实际上函数在服务器端执行本地调用函数的名字和参数，然后再response返回值。

这种模型HTTP只是传输的工具，背后有一层抽象掉了
Highlight:<em>remote procedure calls</em>.
Sticky notes:可以看看这里说明RPC：https://juejin.im/entry/6844903619968368653
Highlight:Another approach is to build your communication around the concept of
Sticky notes:上面是remote procedure calls通信模型
——————————————————
下面是另一种围绕资源和HTTP方法的通信模型
Highlight:Instead of a remote procedure called <code>addUser</code>
Sticky notes:下面这种模型更加贴合HTTP设计初衷

1、就是不是调用一个远程在服务器的addUser函数，而是利用PUT方法 对 /users/larry的服务器数据进行请求
这样子的话，就不是像模型一，将用户信息编码成一长串字符串，而是将要发送去改变的用户信息定义成JSON文档，然后把这个JSON文档放在PUT的body里面去请求。

2、这样用GET 方法请求一个 URL
也是会返回一个代表资源的文档

第二种方法充分利用了HTTP提供的特性，可以很方便完成一些功能，例如对缓存资源的支持（在客户端上保留副本以进行快速访问），特别有用也方便服务器端定义接口
Highlight:secure HTTP
Sticky notes:就是普通的http在像目的地传输数据的时候 很容易被拦截或者修改（因为计算机网络需要通过大量的路由器等设备传输），如果是银行账户密码什么的就会很不安全。就推出https这个协议将HTTP包裹的更安全：

下面两段生词比较多，直接谷歌翻译：

用于以https：//开头的URL的安全HTTP协议以一种难以阅读和篡改的方式包装HTTP通信。 在交换数据之前，客户端通过要求服务器证明其具有浏览器可以识别的证书颁发机构颁发的加密证书，从而验证服务器是否是其声称的身份。 接下来，对连接上所有经过的数据进行加密，以防止窃听和篡改。

因此，当HTTPS正常运行时，它可以防止其他人冒充您尝试与之交谈的网站以及监听您的通信。 它不是完美的，并且由于伪造或被盗的证书以及软件损坏而导致HTTPS失败的事件屡屡发生，但比纯HTTP安全得多。
Highlight:Forms were originally designed for the pre-JavaScript Web to allow web sites to send user-submitted information in an HTTP request.
Sticky notes:/*为啥把form标签讲的与众不同（不和div p a table标签一样），因为<form>标签是在JavaScript发明之前用于浏览器来发送HTTP请求的，有一句不懂*/

不好意思上面是我理解错了，又不想删除错误思想，一开始我把“Form”这个单词理解成了<form>这个标签，其实非也，Form的意思是单纯的js里的一个概念“表单”，表单是最开始设计来进行http交互的（这样下面才理解的通，不然想半天）

就是这个设计假设和服务器的交互始终通过导向新的页面来实现。
啥意思？新界面？

可能是表单每次提交后当前页面的所有内容都会消失，（就像有的网站 有时候刷新的时候，提示：“是否提交当前表单？”）
Highlight:elements
Sticky notes:这个their 就是 “表单的”，就是表单的标签元素也是DOM标签大家族的一部分，但是这些表单元素标签会有一系列特殊的属性properties和事件events，而其他的DOM标签没有

这就可以结合js程序来做一些检测或者控制复杂的表单操作，比如给form增加一个新的函数或者用表单和在JavaScript应用程序中使用表单和字段作为构建块。
Highlight:A web form consists of any number of input fields grouped in a <code>&lt;form&gt;</code> tag.
Sticky notes:上面简单讲了“表单”和“表单元素”的概念
——————————————————
下面具体来说一些代码里面的表单元素：
1、<input/>
2、<textarea/>
3、<select/>
这本书毕竟是JavaScript的书，也不会详细将HTML的表单，只是简单做一个大总结
Highlight:&lt;input&gt;
Sticky notes:<input/>很清楚下面的总结，有很多种
Highlight:&lt;form&gt;
Sticky notes:这是Form fields（表单元素的总称input，select，textarea），也可以不在<form/>标签里面使用，不构成一个表单（这样就不能作为一个总的表单发送http请求到服务器）

但是这样单独拿出来用的表单元素也是会定义一些特殊的函数完成特殊的用途，并不像原本设计的放在一个<form>里然后submit提交
Highlight:&lt;textarea&gt;
Sticky notes:<textarea/> 通常用来输入多行文本

值得注意的是初始值不是 value=“A”像上面input而是直接在<textarea></textarea>里面写初始值（因为多行文本挤在一个value属性太奇怪了还有换行）
Highlight:<code>&lt;select&gt;</code>
Sticky notes:<select/> 用来提供多个选择

所有的表单元素改变的时候，都会触发“change”事件
Highlight:<code>focus</code> and <code>blur</code> methods.
Sticky notes:首先讲下focus是啥概念，就是表单的元素是需要和键盘输入交互的，一个元素只有先“focus”聚焦了之后才能接受键盘输入。（就是习惯上的点击一个输入框肯定向这个输入框输入数据不然输入东西输到哪里去了？）

可以用blur方法“失焦”

不同元素对聚焦后的键盘相应不同：
1、input就是可以打字进入这个输入框
2、select是你输入一个选项的内容就会跳转到相应选项，可以玩一下上面的例子：
<select>
  <option>Pancakes</option>
  <option>Puddi ng</option>
  <option>Ice cream</option>
</select>

点开之后打字看看
Highlight:autofocus
Sticky notes:看懂这段话：
就是说有的时候需要一个页面加载完的时候自动聚焦到一个表单元素上，有两种方法：

1、JavaScript方法，在页面完成的时候调用<script>的代码聚焦
2、用HTML的autofocus方法，这个方更好，因为这让浏览器知道你想要干什么（就是与初心语义相符），并且也可以让浏览器来关闭这个自动聚焦的行为当用户不需要这种自动聚焦的时候，关注别的内容的时候
Highlight:tabindex
Sticky notes:还有对表单还可以使用tab键来切换表单上聚焦的元素，

有一个tabindex属性，来控制你按tab的时候切换的元素，下面的例子写的很不好，没有换行

<input type=""text"" tabindex=1>
<a href=""."">(help)</a>
<button onclick=""console.log('ok')"" tabindex=2>OK</button>

这样就清晰很多，有三行，然后你按tab键会跳过(help)这个链接元素，然后最后才是这个元素

两点注意：
1、有些元素不能被聚焦你也可以添加tabindex来增加聚焦选项
2、tabindex=-1，可以跳过这个tab聚焦
Highlight:disabled
Sticky notes:可以增加一个不带属性值的属性disabled

增加这个之后就是不可选中，不能被聚焦focus或者change，浏览器也会让他们很难看。

disabled的用途就是，当你需要和服务器通信通过网络有一定事件延时的时候来禁止这个按钮，直到这个网络操作完成，防止重复操作。
（很明显例子就是工作台每次写进度的时候，提交的按钮，点击之后就禁止了用disabled，因为有网络延迟，如果你点击多次就是重复提交，直到服务器返回一个200的code就跳转到进度表页面（我改的这个bug哟哟！））
Highlight:elements
Sticky notes:当<form>标签里包含了很多表单子元素，父元素可以获取到子元素，子元素也可以获取到父元素。

let form = document.querySelector(""form"")
1、父元素获取子元素：
a、form.elements[1] （获取form标签的第一个子表单元素）
b、form.elements.password （这个是在子表单元素添加name = ""password"" 这样用名字password也可以获取对应子表单元素）
上面是两种方法，一种是用index锁定，另一个是用name锁定

2、子元素获取父元素：
let child = form.elements[1] 这个是子元素
然后子元素获取父元素就是 child.form
Highlight:A button with a <code>type</code> attribute of <code>submit</code> will, when pressed, cause the form to
Sticky notes:上面讲所有元素包含在form表单的<form>标签和子元素如何互相获取

————————————————————
下面是说点击“submit”的时候发生的http请求，可以是默认的也可以是自定义的。
Highlight:submit
Sticky notes:点击submit之后就会产生http请求，可以用默认也可以用自定义：

1、默认：
就像上个例子，在<form>表单里有多钟attributes来指定http请求：
action：url 地址，服务器接收表单数据的地址

method：提交服务器的http方法，一般为post和get

name：最好好吃name属性的唯一性

enctype: 表单数据提交时使用的编码类型，默认使用""pplication/x-www-form-urlencoded""，如果是使用POST请求，则请求头中的content-type指定值就是该值。如果表单中有上传文件，编码类型需要使用""multipart/form-data""，类型，才能完成传递文件数据。

然后点击""submit""的 input就可以提交默认的http请求

2、自定义的：
想这里例子这样，定义
form.addEventListener(""submit"", event => {...})
箭头函数里定义自己的操作，可以是fetch方法更灵活的，注意用event.preventDefault()来禁止1方法的默认http方法
Highlight:Fields
Sticky notes:“fields”输入区域可以用<textarea>（实现多行）或<input>（功能更多text/password）来实现，他们有类似的接口

都将值保存在 value 的属性里面
Highlight:properties of text fields give us
Sticky notes:上面引语：引出textarea
————————————————
下面讲一下selectionStart和selectionEnd两个属性，然后用来实现一个换词的小例子
Highlight:<code>selectionStart</code> and <code>selectionEnd</code>
Sticky notes:下面主要是讲selectionStart和selectionEnd的应用，其实特别好理解

他们两个就是鼠标左键点击的时候向右选中，保存记录开始和结束的位置，然后结合""keydown""事件就可以实现用f2来实现选中换词的功能

看懂下面代码
Highlight:Text fields
Sticky notes:上面宏观讲了form里面包含表单元素如何父子元素交互以及在最后“submit”的http请求
————————————————————
下面连讲几节说明具体多种表单元素用法（就是多，单个不难别怕）
1、textarea
2、input的checkbox
3、input的radio
4、select
5、input的file
Highlight:The <code>""change""</code> event for a text
field does not fire every time something is typed.
Sticky notes:上面讲完“keydown”事件结合selectionstart的小例子
——————————————————————
下面讲下""change""和“input”事件的区别，并又实现一个“input”事件的小例子
Highlight:""input""
Sticky notes:text field文字输入区域的触发事件区别：

1、“change”有点不太适用，它的触发情况是，当field失去焦点了并且内容相比上次改变了触发
2、“input”比较好，每当fields内容改变的时候都触发（不管是输入，删除还是用别的函数改变文字）

再看懂下面例子用“input“实时显示字数
Highlight:Checkboxes and radio buttons
Sticky notes:从上到下三个小点，看完后看理不理解：
1、<label> 就是包裹一个 checkbox或者radio，这样点击label的主体就可以触发 点击事件（就是如果没有label，你只能点击那个小圆点或小方框，加了你点击文字也可以触发）

2、checkbox和radio的区别，可以这样想：checkbox就是唯一一个单独选项，比如“你是女生吧？”的checkbox点击之后说明是女生，不点击就是男生，

而radio是提供多个选项只能选择一个，比如“你最喜欢的水果？”可以苹果李子西瓜橙子很多种选一

还有对于js代码，多个radio可以共享一个name的attribute属性

3、let buttons = document.querySelectorAll(""[name=color]"");
选取拥有name=color的属性的所有标签
Highlight:radio
Sticky notes:区别1：select概念上有点类似radio，他们都提供选择，但radio 的样式唯一确定，select的样式却跟浏览器有关系（qq小程序的select上线的时候和开发的时候本地浏览器渲染出来就不一样）

区别2：<select>标签支持多选（千万注意windows按住ctrl，mac按住command），并且样式的单选的select不一样
Highlight:when you open it.
Sticky notes:上面是<select>和<input type=""radio"">的区别
——————————————————————
下面是<select>的具体使用
Highlight:For a <code>multiple</code> field, though, this property doesn’t mean much since it will give the value of only <em>one</em> of the currently selected options.
Sticky notes:首先，select和option是搭配使用的：
<select><option value=""1"">1<option></select>

1、select.value
a、对于单选框，select.value 就是选择的option的value属性值
b、对于多选框，select.value没有意义了，因为选中了多个value值你需要自定义计算（下面的例子是加起来，可能还有别的更复杂运算）
（还有如果 value=“1”没有指定， <option>标签包裹的就是value值）

2、select.options[0].selected
这个更适合多选框，根据options数组selected的属性判断那些被多选，自定义自己复杂的操作，看下面的例子一目了然。
Highlight:File fields
Sticky notes:注意这里理解意思：

就是说<input type=""file""> 最初发明是 为了配合 <form>上传文件使用的，但是现代浏览器也可不用必须用来上传文件，而是读取用户硬盘的文件

还有JavaScript运行在浏览器上并没有权利读取你所有的硬盘文件，但是你用type=""file""选取之后，浏览器就有权利读取你的选中的文件了 保证了安全性

还有<input type=""file"">的样式想下面像一个按钮，写着“选择文件”
Highlight:or “browse”, with information about the chosen file next to it.
Sticky notes:上面是 “File Field”文件栏简介
————————————————
下面是<input type=""file""> 在JavaScript程序中的具体应用
Highlight:files
Sticky notes:input.files属性

这个属性像一个数组对象，包含了选择了文件的纤细（没有file单个文件属性是因为这个标签也支持选择多个文件，保证统一性）

files拥有 name size 和 type属性 好理解结合英文解释
Highlight:What it does not have is a property that contains the content of the file. Getting
Sticky notes:上面是 JavaScript的 input.files 具体代码使用
————————————————
下面是从硬盘读取文件需要一定事件 需要绑定事件 检测异步操作
Highlight:FileReader
Sticky notes:因为读取文件内容（前面”change“事件只是文件基本信息的加载比如name、type，但这里是文件内容可能200Mb）需要花费时间，要绑定“load”事件给异步操作reader对象

这里用的是 
let reader = new FileReader()
然后reader.addEventListener(""load"", ()=>{...})
读取文件

同时reader读取文件也会出错，也可以监听“error”事件，下面的readFileText是一个完整的封装逻辑
Highlight:localStorage
Sticky notes:1、单纯在本地，用html+js就可以写出一些基本的小应用，但是因为背后是JavaScript程序，每次刷新这个页面之后，程序里的let绑定就会全部消失了，为了保存不同会话（session）之间的值，就需要用localStorage存储共同的值。

2、用法就像下面一样，存储，获取，删除

3、localStorage会一直保存除非被重写或removeItem或被用户删除（不动它它一直都在）

4、原则是不同域名间的localStorage不能共享

5、localStorage有大小限制（防止无限制扩大太大）
Highlight:Storing data client-side
Sticky notes:累的要死，把好几种特殊的表单元素讲完了
————————————————————
讲localStorage
Highlight:The following code implements a crude note-taking application. It keeps a set
Sticky notes:上面介绍localStorage的理论
——————————————————
下面搞一个稍微有点复杂的，结合整章的select和option的学的东西搞个小例子，要看懂代码
Highlight:the
Sticky notes:解读下面的代码（还是有点点复杂）
1、从上到下函数主题：
function setState(){}            ———定义setState函数
setState(....)                       ———初始化最开始的列表

然后下面的绑定写的很乱，这里来理清 document.querySelector(“select”).addEventListener(""change""...       ————监听最上面的select ，变的时候同步到state（主要是option.selected改变）

document.querySelect(“textarea”).addEventListener(""change""...)      ————监听下面的多行文本，每当失去焦点（活学活用看上面学的，不同于input事件），将内容保存到state

document.querySelector(""button"").addEventListener(""click""...)         ————监听“Add”按钮，点击之后弹出一个prompt，输入后新增一个note，内容为“”空
Highlight:edit
Sticky notes:后面三个监听好理解，难得是前面定义setState函数和调用setState函数有点奇葩难理解。

首先看看state的结构：
{""notes"":{
        ""123"":"""",
        ""shopping list"":""Carrots\nRaisins\n大蒜大蒜\n666"",
        ""几年"":"" 就基本就会被环保部\n环境比较好""},
""selected"":""shopping list""
}
就是有个""notes"" 属性值是一个大对象，对应：
note名字+note内容，然后有个selected指明选中的note

1、function setState(newState) {}
定义的时候干了啥呢：看起来很烦，本质三部曲：
a、将state数组里的selected的选中值放到<select>
b、并且将<textarea>的内容也正确放过去
c、然后存储到localState里

2、初始化调用：
setState(JSON.parse(localStorage.getItem(""Notes"")) || {
    notes: {""shopping list"": ""Carrots\nRaisins""},
    selected: ""shopping list""
  });
第一次没有就给个默认的shoppinglist，
然后这里为非要搞个localStorage，就是让你下次开这网页的时候保存上次的内容防丢失
Highlight:Object.assign
Sticky notes:4个小点：
1、|| 操作符用在setState初次调用，用来给默认note

2、setState作用一句话就是将state对象改变到dom里去并存储到localStorage

3、Object.assign 创建一个空对象，然后将旧的state和这次操作的内容共同合并到一个对象里去（某个改变了的部分，增加了新内容都会合并）

4、还有一个有点相似的sessionStorage，差不多，只不过每次关闭浏览器之后就消失了（localStorage会一直在除非人文删除）
Highlight:forms
Sticky notes:粗略的总结，简单看自己还会不会：
1、明白client 和 server 发送request和 返回 response，明白headers信息作用
2、发送http请求的js内置方法fetch方法
3、可以用表单“Form”来发送http请求
4、有多种表单栏输入，text，checkboxes, textarea, file类型
5、“change” 和 “input”时间区别， value和checked的attributes
6、“submit”事件，可以触发默认的http事件，要想自己定义可以结合preventDefault来定义自己的http请求（js的fetch方法）
7、读取文件使用FileReader接口
8、localStorage和sessionStorage的区别
","2020-10-22 23:10:17"
"Eloquent JavaScript","https://eloquentjavascript.net","no_tag","","","","2020-10-21 11:09:36"
"JavaScript and the Browser :: Eloquent JavaScript","http://eloquentjavascript.net/13_browser.html","no_tag","","","Highlight:Web technology
Sticky notes:这个引子说的浏览器和JavaScript的关系。JavaScript只有用在浏览器上面发挥最大的作用被人们广泛学习，或者说JavaScript只有因为被用在浏览器上词汇被重视。

这个意思就是说，JavacScript和浏览器是分开发展的，浏览器是很多个厂商推出的，有IE，火狐，谷歌，网景各种浏览器。

浏览器的功能就是解析html+js+css，浏览器需要支持多种新的特性，或者在自己的广告上增加自己新的特性。这样翻译最后一段：

「这既是福也是祸。 一方面，它授权没有中央控制系统，但是可以通过松散协作（或偶尔公开敌视）的各方面对其进行改进。 另一方面，开发Web的随意方式意味着所得到的系统并不是内部一致性的光辉典范。 其中的某些部分令人困惑，构思不佳。」

意思就是说虽然可以百花齐放，但是有时候也有兼容问题，所以就说有很多浏览器的兼容问题
Highlight:Networks and the Internet
Sticky notes:新人一开始读这个可能感触不深，其实这是计算机网络的知识，你们可以在大二大三学习完计算机网络后再回来理解会很好，现在不太清晰以后就清晰了
Highlight:shoot bits at another computer.
Sticky notes:计算机网络最早1950s左右，当两台电脑连接在一起可以完成很多事情，那么当世界上所有电脑连接在一起更可以完成更好的事情，这就是互联网Internet

一台电脑可以另一台电脑发送比特很方便，但问题是另一台电脑需要你发送的比特是什么意思，一定序列的bit代表什么含义表达和使用的编码方式，这就需要互联网协议protocol

——————
因为有句话叫做“网络协议是网上通信的基本语言”
Highlight:A <em>network protocol</em> describes a style of communication over a network. There
Sticky notes:计算机通信的历史（互联网）
————————————————————
在互联网上通信，需要特定互通的语言——协议protocol
Highlight:HTTP
Sticky notes:有很多种协议（其实都是计算机网络应用层的协议）
1、发送邮件的协议：SMFP
2、传输文件的协议：FTP
3、控制电脑的协议：SSH
4、还有跟web相关很大的HTTP协议

HTTP协议用来在网络上传输资源（网页html或者图片），指明request和response的双方，下面的例子说明获取的资源和协议版本：
GET /index.html HTTP/1.1

更详细的许多http规则在18章学习

还有http协议不是单独用就可以了还需要很多底层的可靠协议来保证数据在计算机网络上传输，第11张搞的复杂要死让人崩溃就是用乌鸦通信的原理模拟了最简单的计算机网络异步传输，详细可再到第11张体会。
（最好学习计算机网络后再学习）
Highlight:The <em>Transmission Control Protocol</em> (TCP) is a protocol that addresses this
Sticky notes:Http协议
————————————————
TCP协议
Highlight:TCP
Sticky notes:（上面有物理层，链路层）
这里说运输层的协议TCP
其实还有网络层Ip协议
最后才是应用层HTTP/SMTP协议。

TCP连接的基本原理如下：
就是网卡是电脑最忙的硬件，他需要每时每刻监听网络上的请求，看有没有是和自己通信的请求，就需要一直listing监听，然后一台电脑可能有多个程序qq、微信、迅雷，为了不同程序都连接一台电脑通信，就出来特定的端口号，一般每种程序有固定的端口（邮件25，ssh22），这样TCP/IP就提供了一种互联网的抽象层，而屏蔽了底层硬件咋实现的 屏蔽了你的电脑如何通过路由器/网线连接到好基友电脑了。

发送方叫做server，接收方叫做client。可以两台电脑建立联系，哎这里讲的很浅显抽象只是基本点了个意思具体可以去好好学计网
Highlight:World Wide Web
Sticky notes:可能大家对Internet，WWW，http有点不清楚相互关联，看维基百科上说明：
互联网和万维网这两个名词经常被混用。然而，这两个名词的意思并不相同。互联网是一个全球互相连接的电脑网络系统。相较之下，万维网是由超链接和统一资源标志符连接的文件和其他资源的全球集合。万维网资源通常使用HTTP或HTTPS访问，是互联网通信协议的其中之一[20]

就是WWW最先倡导在物联网上用http协议来整合全球资源相互通信，然后互联网借此高速发展（不官方，可以网上再学习历史）
Highlight:<em>Uniform Resource Locator</em> (URL)
Sticky notes:要在Web上提供服务，你需要一个机器（服务器）连接到互联网，然后这台机器检测自己的80端口并定义别人能获取到的http协议。

一个互联网文档（资源）如何从网上获取（借助URL）

URL = protocol + server + path

前后好理解：
1、http就是协议，这里是超文本传输协议（还有安全一些的https）
2、13_browser.html就是你想获取的资源，就是服务器上你感兴趣的文件（这里是获取第13章的html渲染在浏览器学习，你还可以写成图片音频都行）
Highlight:<em>IP address</em>,
Sticky notes:然后在稍微复杂一点就是中间服务器server的IP地址，同样系统学习计网后好理解。

就是每台连接到互联网的计算机必须要有一个唯一的ip地址别人才能区分你是那台电脑，但是这些地址都是难记的数字比如149.210.142.219 or 2001:4860:4860::8888，很难在人类习惯里记住，就出现了域名的概念，可以专门搞一个域名服务器DNS，每当你在浏览器输入https://eloquentjavascript.net 的时候，你的电脑就自动去域名服务器问一下这个含义的字符串地址代表的真实ip地址是什么，然后完成通信

最后接收到server服务器传回的document文档
Highlight:HTML
Sticky notes:因为这本书主要是将JavaScript的，所以也提一些html

html 超文本传输语言，用作网页的文档格式，一个html文档包含文字和tag标签，标签用来描述链接，段落，和标题等不同形式
Highlight:The document 
Sticky notes:这一堆开始碎碎念讲上面html内容了，其实很好理解：
1、小于大于符号包裹的是标签，包含了文档结构的信息，其他的是普通文字
2、文档用<!doctype html>高速浏览器讲这个文档解释称现代html的页面，而不是以前的旧语法内容
3、<head>标签包含文档信息
<body>指示文档的具体内容
有<h1> <p> <a> 好理解吧
4、name=“value”是标签特有的attribute属性可以指示更多信息
5、<meta charset=“utf-8”>是指明编码格式，并不需要闭合标签
Highlight:To be able to include angle brackets in the text of a document, even though
Sticky notes:上面简单介绍普通html文档的各个小标签含义
————————————————————————
下面是谈到类似js里面反斜杠/的转义字符
Highlight:an ampersand (<code>&amp;</code>) character followed by a name or character code and a semicolon (<code>;</code>) is called an <em>entity</em>
Sticky notes:html里面的转移符号用 & ; 开头结尾包裹起来，类似js里面反斜杠转义字符，因此有些html里特殊含义的符号有特定转义形式：
1、<     =      &lt;
2、>     =       &gt; 
3、&    =     &amp;

这几种表示特殊的含义实现字符串含义的符号内容<>&
Highlight:HTML is parsed in a remarkably error-tolerant way. When tags that should be
Sticky notes:⬇️ html不规范写法，不推荐这样瞎写虽然浏览器兼容很强很智能
Highlight:charset
Sticky notes:1、上面瞎写的省略百度翻译：

<html>、<head>和<body>标记已完全消失。浏览器知道<meta>和<title>属于头部，<h1>表示身体已经启动。此外，我不再明确地结束段落，因为打开一个新段落或结束文档将隐含地结束它们。属性值周围的引号也不见了。

2、这本书里为了简洁省略 <html> <head> <body>

3、作者有时候为了方便忽略 doctype 和 charset 但是最好带着因为这些东西不给浏览器可能走出很蠢的事情，虽然它们没有具体显示出来（规范得好）
Highlight:HTML and JavaScript
Sticky notes:html里面嵌入js的三种方法：
1、直接写<script></script>标签，里面包含js程序，记得写</script>不然浏览器会将之后所有内容判定为js代码
2、<script src=“./hello.js”></script>引入外部标签，
值得一提的是 如果 js里用到了 第10章说的ES module，用了import语法，可以加一个 type=“module”，这样就可以支持多个js模组封装互相加载
3、标签直接加 onclick=“alert(“123”)”属性来调用js代码

这样双引号文本内容可以用转义&quot;表示
Highlight:Isolating a programming environment in this way is called <em>sandboxing</em>
Sticky notes:这一小节算是 理论上科普告诉你吧

就是运行网上的程序是看有风险的，可能某个网站有有危害的代码攻击你的电脑，所以浏览器有内部沙盒机制防止JavaScript代码进行名感的操作比如读取本电脑的文件或者修改文件，整个js程序像在一个“铁笼子”限制里运行，这就需要浏览器开发者进行可靠的安全性工作

每当一个新漏洞被发现，开发者就去及时修补，是一场博弈
Highlight:browser wars
Sticky notes:哎就是杂谈 说一下浏览器的发展吧

就是最开始有很多家浏览器公司竞争，每个浏览器公司都想给自己浏览器加入新的特性，然后就不管别的浏览器了，导致有很多bug和不同浏览器适配的困扰（因为html是文档可以随意写传播，但是实际渲染还是在不同的浏览器厂商那里）

知道现代主流浏览器是Chrome，firefox，safaris，就比较幸运不用太纠结许多浏览器不兼容的问题，现在的主流浏览器兼容性比较好
","2020-10-21 10:14:17"
"前端实现在线预览pdf、word、xls、ppt等文件","https://juejin.im/post/6844903561017425927","no_tag","","","Highlight:'
","2020-10-21 01:51:43"
"Functions :: Eloquent JavaScript","https://eloquentjavascript.net/03_functions.html","no_tag","""Recursion""","","Highlight:Functions
Sticky notes:Functions 作用：
1、让大程序用很多小片段来组成，减少重复
2、将名称与子程序相关联，并将这些子程序彼此隔离。

函数会创建很多新的词汇变量，因为js内置不可能有所有语言变量（英语20000个词）很多都需要自己来构建新概念避免重复
Highlight:function
Sticky notes:用function关键字定义函数
包含括号里的参数(x) 可以一个参数或者没有参数
和花括号的函数体 {return x * x} 即使只有一个语句
Highlight:return
Sticky notes:有些函数只值产生副作用 （console.log(""Pling"")）

有些函数会返回一个值（return result）
没有写 return 会默认返回 undefined
Highlight:regular bindings
Sticky notes:函数值也类似常规绑定

但是函数值要传入一些参数，而不是像像常规绑定 const x =1 这样直接用
Highlight:binding
Sticky notes:每个绑定有作用域，函数或者作用块之外的命名是全局变量(global bindings)。

但是函数或者作用块里面的变量叫做 局部变量(local bindings)


函数体里的变量只和本地有关，就不用
Highlight:var
Sticky notes:如果用 let 和 const就可以在单独的作用域里产生

但是2015年前的的关键字var有问题，var定义的变量在整个函数内外都可见，不要用var，造成错误
（因为当年只有函数会创建新的作用域，var没有权利创建独立的作用域）
Highlight:Nested scope
Sticky notes:嵌套作用域 没啥废话，就是js区分全局变量和局部变量，还有作用块和函数的作用域，直接看底下例子

humus函数里 factor是全局的可以用的 
单独调用ingredient 对单个ingredient里 unit是局部变量 相互调用不会冲突。
Highlight:lexical scoping
Sticky notes:在一个块里能否获取某个绑定是由块在项目重的位置决定，每个局部作用域可以看见包含在内部的全部局部作用域，并且全部作用域可以看见全局作用域
能否获取绑定的能力叫做词法作用域
Highlight:function and its name
Sticky notes:一个函数绑定有可能于普通的变量名弄混。

但是函数绑定还是和普通变量名不同
1、函数绑定可以完成普通变量名的所有事情
2、可以用函数的内容值而不是调用（就像有的参数是函数参数，这里并没有调用而是用的变量名的意义）
3、函数绑定还可以被绑定到其他函数（非const）
Highlight:function <em>declaration</em>
Sticky notes:注意这节为啥莫名奇妙

前面是让一个变量等于函数绑定，这里是直接用function关键字定义函数
let launchMissiles = function() {
  missileSystem.launch(""now"");
};
变成⬇️
function square(x) {
  return x * x;
}

下面的function定义简单清楚一点。
Highlight:Function declarations are not part of the regular top-to-bottom
Sticky notes:还有function定义的函数有个特点
就是不需要从上到下定义，function绑定会自动搬到最上面作用域上面去。不用担心获取不到
Highlight:third notation for functions,
Sticky notes:函数第三种定义方法，箭头函数，
下面很啰嗦：
1、形式 (参数) => {函数体}
2、当只有一个变量参数可以去掉变量的括号
并且主题是一个表达式而不是{}定义的，默认会return这个表达式
const square1 = (x) => { return x * x; };
const square2 = x => x * x;
3、没有参数直接写一个括号
const horn = () => console.log(""nihao"")
Highlight:less verbose way
Sticky notes:同时存在 function 方式 和  箭头函数的方式 并不矛盾

箭头函数是 2015年出的，而且能用更简单的形式写函数表达式（后面还会提到作用域的好处，自动bind的好处，毕竟后设计的箭头函数会更先进一些）
Highlight:The way control flows<span class=""diigoHighlightCommentLocator""></span> through functions is somewhat involved.
Sticky notes:函数调用里 用到了控制流 这里简单说一下

首先看一下下面代码简单说明了函数控制流，在程序段里跳来跳去，看他的解释反而绕进去绕半天
Highlight:call
stack
Sticky notes:函数执行跳来跳去就不是这么简单完了

更重要是涉及一个概念 调用栈 call back
因为函数要跳来跳去，程序需要记住每个上次调用的绘制一个地方执行完了之后要返回回去。

每次调用函数之后，会把当前位置存储到一个栈的顶端，当函数返回的时候 顶端栈的刚才存入的就拿出来找到位置继续向下执行。

但是 栈的大小也有限 当下面的程序运行记住会有死循环 栈爆掉，然后 环境报错
Highlight:broad-minded
Sticky notes:js对传递给函数的参数很开明
1、参数传递多了忽略
2、参数传递少了 当作undefined
并不会报错

但是这样的缺点是 当你传递参数个数不对的时候不会报错

优点是允许随意传递多少参数（传少了同样可以工作）
Highlight:<code>=</code> operator
Sticky notes:1、用=来制定默认参数，当没有指定这个参数的时候可以表示默认值

2、下一章可以学用剩余参数(Rest parameters)来获取多余的参数，进行更复杂处理
例如 console.log 就用到了剩余参数 可以传递多个参数然后打印出来 没毛病

console.log(""C"", ""O"", 2);
Highlight:Closure
Sticky notes:可能是 闭包的概念吧

就是可以有函数变量 
在函数里有封闭的作用域，里面定义了局部的变量

当这个函数不用了 这个局部的变量也会保存在这个函数里面
Highlight:situation
Sticky notes:上面例子很好说明了闭包的概念
看起来可能比较复杂，也迷迷糊糊的，但总结的就下面几点：

1、函数变量里面的变量在定义之后依然可以获取到（闭包在这个函数里）
2、本地变量会在每次函数声明的时候创建
3、相同名字的函数不会冲突
（
上面调用了
let wrap1 = wrapValue(1);
let wrap2 = wrapValue(2);
同样的函数名 wrapValue，但是不会相互影响 并且 wrap1和wrap2会保存闭包的内部变量
）
Highlight:creative
Sticky notes:这样有好处 可以创造性的使用
看下面的例子，只要稍微改变一点就可以实现不同功能的函数

let twice = multiplier(2);
console.log(twice(5));
Highlight:local
Sticky notes:就是说上上面例子不需要let local = n，因为n本来就是内部绑定。
function wrapValue(n) {
  return () => n;
}
这样等同
Highlight:A good mental model is to think of function values as containing both the code in their body and the environment in which they are created.
Sticky notes:这里虽然简单几句，但是实际上很值得深入研究：

就是由于js的闭包的概念

js定义的函数不仅仅有函数体，可以接受参数执行一定操作，同时还包含这个函数的内部环境environment
看待函数要把函数体和环境结合起来对待
Highlight:Recursion
Sticky notes:另外一个函数的重要概念递归，但是底下讲解啰里八嗦讲了一大堆，一段来一句，本来不熟悉英语看的头更疼，简单分段总结翻译直到绿色分割线

首段：
一个函数体里可以调用自己只要不超过前面说的函数栈个数，允许用一种更利于人类思考的方式来写函数，比如看下面的power函数的递归思想
Highlight:In
Sticky notes:然后一堆堆一小段一小段折磨（从上至下的小段）：
1、上面power的函数体更接近数学家的思考方式，用越来越小的幂相乘来达到求几次方的目的。
2、但是这样思考的递归写法效率比简单的loop循环慢三倍
3、这样1和2的困境比较有意思，一方面要人的优雅的算法，另一方面要机器的执行效率，需要达到巧妙平衡
4、虽然power例子里很简单，用for循环也很好理解，用递归的版本替换没多大意义，但是一个程序为了处理这种复杂概念放弃一些效率来让程序更直观更有用。
5、担心效率会让你分心，本来设计程序已经比较复杂，担心更多会让程序瘫痪。
6、因此每次实际程序的时候尽量追求正确和简单来利于理解，如果担心程序太慢（通常不会现在硬件发展太快了效率很高），再回来优化
7、递归也不总是比loop效果差，有些情况用递归更好，大多数情况下，这些都是需要探索或处理多个“分支”的问题，每个分支可能会再次分支为更多分支。
Highlight:puzzle
Sticky notes:上面啰哩啰嗦讲完了递归，下面来个稍微复杂例子说明递归的好处：
从数字1开始，重复进行要么+5或者*3的操作，可以找到所有数字，如何写一个函数来找到这样运算式？
Highlight:by starting from the number 1 and repeatedly either
Highlight:shortest
Sticky notes:上面算法没有找最好最短的方法，只是现搜寻 * 3的递归 再搜寻 + 5的递归，可能对某些数另外递归路径更短更好，这里简化来学习递归思想
Highlight:find
Sticky notes:find函数完成一系列递归操作

find函数接受两个参数，当前数字和一个字符串路径寻找history。

find函数会判断：
1、要么找到目标返回目标
2、要么超过目标值没有找到 return null
3、要么没有超过目标值，继续尝试 * 3 或者 + 5

这里return null会由于
return find(current * 3, `(${history} * 3)`) ||
             find(current + 5, `(${history} + 5)`);
这里 或|| 的原因 *3失败后 尝试 +5 
（相当于退回上次进入的 *3 递归 开始尝试 + 5的递归）

哎这些一大堆英语不用太较真的读 更好的是理解代码，要是搞不清楚代码就读它的英文介绍还被绕进去，可以debug试一试

还有看下面的 用缩进表示的 递归结构栈大大帮助你理解他递归的路径
Highlight: functions to be introduced into programs.
Sticky notes:两种可能在程序中引入函数的情况。
1. 一种情况是，写程序的时候有大量要重复的代码片段，防止隐藏错误和更利于别人理解程序。抽象出个函数。
2. 另一种情况，写代码突然要写个伪代码，然后这之后去定义下函数体，就是突发需要函数抽象。
Highlight:clear a concept it is that you’re trying to wrap. Let’s go through an example.
Sticky notes:上面讲了废话 的写函数概念，

如何给函数命名决定了你想如何抽象出一个数。

下面说一个例子帮助理解，自己读从上到下好理解作者如何清晰巧妙抽象构建函数的
Highlight:A useful principle is to not add cleverness unless you are absolutely sure you’re going to need it. It can be tempting to write general “frameworks” for every bit of functionality you come across. Resist that urge. You won’t get any real work done—you’ll just be writing code that you never use.
Sticky notes:上面的代码流程主要教我们如何编函数的思路，最好找到抽象度最高最实用功能涉及更广泛的函数，而不是为每个简单的部分都编写函数。写函数的技巧可以在实战中逐渐修炼。
Highlight:<em>pure</em> function
Sticky notes:哦哦，新手肯定比较难理解第一次读到这里，这里可以去学习“纯函数”的js博客，就是纯函数没有副作用，对每次输入都有确定输入，不改变和使用全局变量，这个纯函数的概念更好用于“函数式编程”的理念，可以有空学习，这个思想在React中应用广泛。
Highlight:side effects
Sticky notes:函数基本分为两种，返回值的和利用副作用的。
返回值的函数与其他函数搭配的能力更强更好，比副作用函数。
虽然有副作用不是纯函数，但是利用副作用有时候很方便，比如用console.log可以很好编程
这一节只是简单的说明高级函数的思想，寥寥几句没有深入可以之后学习js函数编程思想。
Highlight:Summary
Sticky notes:这个概括很简单不全
1，定义函数的三种形式，下面代码很清晰
2，注意函数里scope的概念
3，在程序里抽象函数很有用
","2020-10-16 04:31:27"
"The Secret Life of Objects :: Eloquent JavaScript","https://eloquentjavascript.net/06_object.html","no_tag","","","Highlight:object-oriented programming
Sticky notes:第四章已经把object和array一起讲过 提到过object

object更多应用在“面向对象编程”

很多语言的设计风格都被面向对象思想影响（C++、Java），这节详细讲一下js里面向对象的发展

对新生可能很不友好，完全可以学校学完面向对象编程的课在返回来研究，也可以有个浅层的理解跟着我的注释
Highlight:Encapsulation
Sticky notes:这个单词是 “封装” 的意思，下面几段讲了js中使用对象封装的思想，简单中文总结一段段：
1、面向对象编程思想的核心是将程序分成一段段独立的片段，这些片段独立管理自己的state状态。

2、这样关于某个片段的只是可以封装到那个片段的内部，其他片段用这个片段并不需要知道内部细节，当内部更新的时候只有跟这个相关的部分代码需要更新。

3、不同片段交互通过“interface”接口来实现，用一个更抽象的层次隐藏精确的实现而只是提供接口给别人用实现功能。

4、这样的程序片段用objects对象来实现，他们之间的接口用method和property实现（第四章讲过）。接口暴露出来的属性property是公共的public，不能获取的是私有的private。

5、很多语言有public和private关键字，在语言方面就避免了私有和共有混淆，但是js还是不负众望没有实现。

6、但是js的程序员又想利用买你想对象的思想。就自己封装了实现js里面向对象的方法，
a、将可用接口在文档或者树枝里说明
b、用_开头定义变量表明是私有变量
Highlight:Usually a method needs to do something with the object it was called on. When
Sticky notes:上面是普通对象 加一个object.method的普通运行方法，好理解
——————————————————————
1、下面是对象里面的 object.method方法 调用时候 用上object里面的数据（用this指向）

2、同时另一种显式使用this的函数执行方法 function.call(...)
Highlight:this
Sticky notes:this 可以看作 指向具体的实例
Highlight:this
Sticky notes:有时候调用函数想用到 object里面的 数据，可以在函数体里写this 指代对象的数据

1、像上面这种
whiteRabbit.speak(""Oh my ears and whiskers, "" +
                  ""how late it's getting!"");
只要speak里说明了 this 就能指向 whiteRabbit里的数据

2、另一种更显式的调用方法
speak.call(hungryRabbit, ""Burp"")
hungryRabbit是 this指向的对象， 用于调用完整的speak函数
Highlight:Since each function has its own
Sticky notes:下面讲解this的小问题
Highlight:binding, whose value depends on
Highlight:Arrow functions are different
Sticky notes:上面一段可能看不懂，啥意思呢？：

就是this不是可以指代某个object吗，但是这个this不能在函数体里再向下传递，只能传递一次，哎说不清你看下面例子：
1、function add(n) {
  return n / this.length
}

2、function normalize() {
  console.log(this.coords.map(add));    
}

3、normalize.call({coords: [0, 2, 3], length: 5});

上面的函数normalize函数体里有this指向 {coords:[0, 2,3], length: 5}

但是函数normalize里又调用了函数add，add函数体里又有this，这个时候normalize里面的this不能传递到add函数里面，add函数里this是undefined，就会出错，懂了意思吧，this只能传入一级

但是箭头函数是es6新出的语法，先进一些，可以传递绑定，可以再次传递this，所以例子
console.log(this.coords.map(n => n / this.length));
这样没问题

但是不跟你说明白可能 比较难搞懂他跳跃思想
Highlight:Prototypes
Sticky notes:看清楚下面三节的结构不至于太迷糊：
这一节是PROTOTYPE
下一节是CLASSES
下下节是CLASS NOTATION

1、prototype是js里独特的，先讲一些js里原生的一种“类似”类的思想的原型概念和js里代码怎么用prototype

2、然后classes 再来讲通用的 其它面向对象编程是怎么利用class和object的，然后讲讲用js的 prototype 如何在2015年前 没有class的时候 前端工程师利用prototype 实现 class的需求的代码方法

3、最后class notation里面，更新了es6的语法，js现在终于有class了 ，新时代如何和其它语言统一用class定义使用js 的类
Highlight:prototype
Sticky notes:这里故弄玄虚，第一次也是看不懂他在搞什么鬼东西，意思就是{}空的 一个对象，其实是有prototype原型的一些方法的，继承了祖先的内置的方法，比如这个{}.toString()就是

当调用一个方法本元素没有这个方法的时候，就会去祖先原型找有没有这个方法。

用Object.getPrototypeOf可以 查找一个东西的原型
Highlight:don’t directly
Sticky notes:可以用Object.getPrototypeof来获取一个东西的原型组件

1、普通的对象Object{}的原型是Object.prototype，是原始祖先，他没有原型了（最高级）
2、函数function的原型是Function.prototype，他还继承于Object.prototype
3、数组Array[]的原型是Array.prototype，他还继承于Object.prototype

这样的好处就是可以重用一些类似toString()的方法很方便
Highlight:You can use <code>Object.create</code> to create an object with a specific prototype.
Sticky notes:⬆️  上面是Object.getPrototyepOf属性讲原型链
————————————————————
⬇️  下面是Object.create方法根据一个原型创建一个对象
Highlight:shorthand
Sticky notes:这里自己尝试写一个原型，然后用Object.create来继承一个原型创建一个实例来体验一下原型的思想。

上面好理解，就是原型定义的speak方法有点简写，这个定义的函数也没有 function关键字
let protoRabbit = {
  speak(line) {
    console.log(`The ${this.type} rabbit says '${line}'`);
  }
};

上面这个就等于
let portoRabbit;
protoRabbit.speak = function (line) {
    console.log(`The ${this.type} rabbit says '${line}'`);
}
Highlight:A class defines the shape of a type of object—what methods and properties it has. Such an object is called an <em>instance</em> of the class.
Sticky notes:底下这句绕口令（两个角度说明类和对象）：
1、*类*定义了一个有具体方法和属性的对象
2、“对象”叫做一种类的实例
Highlight:JavaScript’s prototype system can be interpreted as a somewhat informal take on an object-oriented concept called <em>classes</em>.
Sticky notes:（哦哦，其实本质上Javascript是一种“基于原型编程”，可能没说太清除（没仔细研究），后面又引入class变成“基于类编程”（es6））

所以说JavaScript的原型就类似于一种 非正式的 “类”

class类可以用来指明一个对象object——说明属性properties和方法methods，这样一个对象就叫做一个类的实例

下面也只是讲es6以前的 人们用原型来做类的使用和构建 主要理解class和object的关系就成，新的用法看下一小结（也就是说下面讲的js的方法是新语法之前的用法）
Highlight:constructor
Sticky notes:下面这个makeRabbit不是构造函数！！！！
不要被下面这个例子迷惑了，下面只是展示了“利用类的思想（这里js里类的形式是原型链，非正式）”构造一个实例的浅显步骤（先继承，在再增加实例特有的）

1、let rabbit = Object.create(protoRabbit)
这个是继承prototype 父级的通用属性

2、rabbit.type = type
这个是除了继承prototype，具体实例instance也可以存储独特的实例属性

这里只是说概念

下面才是js里的代码实现，有constructor函数
Highlight:JavaScript provides a way to make defining this type of function easier. If you
Sticky notes:⬆️ 介绍通用的类的概念和实例的概念
——————————————————————
⬇️ 说明JavaScript里的类和实例的用法，并给出小例子
Highlight:Constructors (all functions
Sticky notes:他的介绍反过来没逻辑，这里我整理下：
1、构造函数的定义：
第一步：
js里的所有函数都可以作为constructor构造函数
（例子里function Rabbit(type)，在Rabbit函数体{}里是一些自定义实例特殊的属性或者方法）

第二步：
第一步完成后，然后函数里有一个prototype属性，可以随便覆盖/修改prototype属性，prototype就是父类的原型的一些方法通用的。
（例子里的Rabbit.prototype，是通用的一些方法）

注意上面两步骤定义函数里都有this，这个this是指向具体的构造之后的实例（我们例子是this =》 weirdRabbit）

2、构造函数上面两步骤定义完成之后，就可以用用new关键字从构造函数构建一个实例，会自动绑定this => weirdRabbit
（例子里：let weirdRabbit = new Rabbit(“weird”)）

3、一般我们定义构造函数的名字开头为大写，告诉别人这是一个抽象的类
（例子里名字是：Rabbit）
Highlight:It is important to understand the distinction between the way a prototype is
Sticky notes:⬆️ js里实例和类的代码实现
————————————————————
⬇️ 探讨一下构造函数(constructor)和实例(instance object)的原型
Highlight:prototype
Sticky notes:Function   =>   Rabbit   =>   weirdRabbit
函数              构造函数         实例

别被它绕进去了就是上面简单的原型关系，两层prototype

也就是说weirdRabbit 实际上还是有 Function原型的一些方法的

他的一句塑料英语：

It is important to understand the distinction between the way a prototype is associated with a constructor (through its prototype property) and the way objects have a prototype (which can be found with Object.getPrototypeOf)。
上面这句话意思就是让你认清Rabbit.prototype和weirdRattbit.prototype的区别，清晰图就行
Highlight:It just looks nicer.
Sticky notes:上面是新用class构建的Rabbit类，和上上节没有class关键字构建的rabbit一摸一样，只是更好看了，这里全局看：

class Rabbit {
}
这个Rabbit类{}里面可以写很多种方法：
methods和一个constructor

a、constructor是特殊的一个方法，是构造函数，他是实例化instance里不同生成对象里特殊的属性（比如这里killer和black杀手兔和黑兔子）

b、其它的methods想定义多少就定义多少，是一些通用的方法，任何实例化后的对象都可以调用（任何new Raabit 都可以调用killerRabbit.speak(""123"")）
Highlight:only <em>methods</em>
Sticky notes:这一小段的意思是啥呢，就是，现在我们“通用”只能是method函数，也就是说下面这样不行：

class Rabbit {
  constructor(type) {
    this.type = type;
  }
  speak(line) {
    console.log(`The ${this.type} rabbit says '${line}'`);
  }
  abc=""123""
}

可能下个版本可以改进，方便的定义一些通用变量
可以在定义class自己加，像这样：
Rabbit.prototype,abc = ""123""
Highlight:Like <code>function</code>, <code>class</code> can be used both in statements and in expressions.
Sticky notes:⬆️  介绍新出的class语法的特点和不足
——————————————————
⬇️  介绍一种奇葩的用法 说明有这种用法
Highlight:omit the class name
Sticky notes:就是和funciton类似，class也可以有两种形式
statements 和 expression ，先看函数的：
1、
function abc() {...}
2、
let abc = function() {....}

class 也类似，有两种，他给的例子跳跃了（实际上像是Java的匿名类，看下面不需要指明类的名字就创建了一个对象实例）：
1、
class Rabbit {...}   （声明statement定义方法）
2、
他的例子拆解：
let niming = class { getWord() { return ""hello""}} （另一种expression定义方法）

然后：
let object = new niming
console.log(object.getWord())

懂了吧，书还是有跳跃的
Highlight:Overriding
Sticky notes:overriding是覆盖/重写的意思，其实面向对象编程还有重写和重载的区别，之后可以在你们学完面向对象编程之后了解

新手的就理解浅层一点，就是在具体的实例里不要以前的属性，重新自己写了一个覆盖之前的属性
Highlight:express exceptional
Sticky notes:1、给已经实例生成的object加一个property，会加到本object上，如果原型有相同名字的property，新加的会覆盖（子代定义的覆盖父代的，优先级更高）

2、上面的图很清楚，killerRabbit背后有两个继承的Rabbit和Object，有些本身killerRabbit没有的属性可以在父类找到

3、overriding已经存在的属性，作用可以给自己实例添加额外的属性，而其它的保持标准的属性有统一性（比如这里Rabbit正常的teeth是“small”统一的，而killerRabbit需要凶狠一点，teeth是“long，sharp”只是个例外）
Highlight:Overriding is also used to give the standard function and array prototypes a
Sticky notes:⬆️  是重写我们例子的小应用
——————————————————
⬇️  是讲原生js语言里已经有的覆盖重写
Highlight:toString
Sticky notes:js内置的一些标准函数就有重写overridde了

比如array继承与Object，但array覆盖了object的toString方法，两者不同

console.log(Object.prototype.toString.call([1, 2]));
// → [object Array] （只是简单打印出类别Array）

console.log(Array.prototype.toString.call([1, 2]));
// → 1,2
Highlight:<em>map</em>
Sticky notes:前面高阶函数一章 提到了 “map” 这个单词，这里也要将“Map”， 虽然相似 但是两个含义完全不相关

1、前面的map是一个高阶函数方法，是来给数组的每个元素进行操作：
console.log([1,2,3].map(a => a+1))
// → [2, 3, 4]

2、这里Map 是“图”的意思，是一种数据结构，来关联一些数据
Highlight:toString
Sticky notes:但是我们之前已经有Object，已经有方法可以存储有关联的数据了，为啥还要用“Map”图呢？

上面例子很清晰说明问题：
我们用属性名来作为keys获取年龄，但是由于原型链的影响，“toString”也可能被当作键值keys影响到，有两种方法解决，看下面

1、Objcet.create(null) 构建一个不会继承原型的对象
2、使用Map
Highlight:<code>null</code> to <code>Object.create</code>
Sticky notes:用普通的（plain）的对象作为图map是很危险的，一种解决方法用Objcet.create(null)构建不会继承原型的对象

缺点，用object作为map的键值keys只能是字符串，如果有的键值不能方便的转换成字符串就不太好用
Highlight:Fortunately, JavaScript comes with a class called <code>Map</code>
Sticky notes:Map可以克服用object作为图map的各种缺点，并且有优势啦，好处：

1、Map专门用来作为图map的目的而设计
2、Map的keys键值允许任何类型的数据
3、Map拥有set，get和has方法用来作为现成的接口使用
4、从效率来看在一个大的map里存储检索数据是很耗费时间的，开发者已经设计好了很好的检索算法，用Map效率会更高，并且直接使用
Highlight:If you do have a plain object that you need to treat as a map for some reason, it
Sticky notes:⬆️  一点点解决图Map的使用问题
————————————————
⬇️  如果非要用object代替Map也有一些方法
Highlight:Object.keys
Sticky notes:非要用objcet作为图maps，解决方法大全：

1、Object.create(null) 创建没有任何原型的对象

2、用Object.keys 检索所有非原型属性的属性property

3、Map的has方法 可以用 object.hasOwnProperty方法代替，会忽略原型属性
（
这里说的As an alternative to the in operator，意思是这种操作和in很像，像是检查图里有没有这键值
if(""toString"" in {x:1}){
  console.log(1234)
} 
=》 打印1234
， 所以用hasOwnProperty方法更好，也等同于Map的has方法
）
Highlight:String
Sticky notes:String方法 本质上是 调用一个特定类型的toString方法

我们可以定义自己的“特定类型”，然后用String这个统一的接口来调用，像下面的例子，我也新加了几个对比：

Rabbit.prototype.toString = function() {
  return `a ${this.type} rabbit`;
};

console.log(String(blackRabbit));
// → a black rabbit
console.log(String({x:1}))
// → [object Object]
console.log(String([1,2]))
// → 1,2

都是用String函数方法
Highlight:This is a simple instance of a powerful idea. When a piece of code is written to work with objects that have a certain interface—in this case, a <code>toString</code> method—any kind of object that happens to support this interface can be plugged into the code, and it will just work.
Sticky notes:polymorphism 这个单词是多态的意思， 在面向对象编程里面绝对会碰到，基本含义是这一段：

可以将支持该接口的任何类型的对象插入代码中，这样就可以正常工作。（上面我们的例子就是String对待不同的toString接口都能正常使用）

就是同样一段代码，当传入的类型不同时也可以都可以正常工作，这个就是多态，多态可以实现很强大的功能
Highlight:we can also add this interface to your own objects!
Sticky notes:还有之前的 for/of 也是类似的方法 可以支持多种不同的数据结构（数组/对象）

let / of 的背后本质是调用了 不同的数据类型（array/string）的响应这个 let of语法的函数

我们也可以在自己定义的class 定义 响应let of语法的类，我们要先学习symbols

（其实最终学习响应let of 是在下下小节The iterator interface，然后下下小结The iterator interface需要先学Symbol的用法，看了半天才明白）
Highlight:It is possible for multiple interfaces to use the same property name for different things.
Sticky notes:下面四段，调理清晰的总结：
1、symbol引入的初衷：就是我们想要给同一个属性名 property name 背后有不同的函数
（比如toString()函数 我们还想用toString名字 定义另外一个 不是转换成字符串的功能 （这里不用管他奇葩函数意义，理解成另外一个功能，转换成“yarn”，在下下代码块里））
仅仅凭原来的普通方法是不能实现“想要相同名字实现不同函数功能”的功能的，所以引入symbol

2、这样用的少，但是js的最初设计者帮我们考虑好了

3、用Symbol关键字 定义的symbol是唯一的，就算初始化传入字符串参数“name”是相同的名字，背后内存存储是不同的，所以不是同一个东西

4、接着3，实际上初始传入字符串“name”没有实际的意义，只是方便编程者去区分不同类的symbol或者在console里打印出来。
（
比如 你可以创建多个 “toString”的要实现不同的toString方法：
let toString1 = Symbol(""toString"")
let toString2 = Symbol(""toString"")
let toString3 = Symbol(""toString"")
这三个 大体是方便记忆要实现“toString”类型的方法，其实是不同Symbol
）
Highlight:Being both unique and usable as property names makes symbols suitable for
Sticky notes:⬆️  介绍Symbol加入这个语法的用途 和 定义
——————————————————————
⬇️  Symbol的具体代码使用
Highlight:by using square brackets around the property name.
Sticky notes:1、有了具有唯一性和可用性的 symbol，我们就可以 跟着初始toString()方法 再实现一些具有相同名字 但是背后实现函数不同的 方法了(下面toStringSymbol)方法。上面代码完全可以写成:

const toString = Symbol(""toString"");
Array.prototype[toString] = function() {
  return `${this.length} cm of blue yarn`;
};

console.log([1, 2].toString());
// → 1,2
console.log([1, 2][""toString""]());
// → 1,2
console.log([1, 2][toString]());
// → 2 cm of blue yarn
这样也运行，symbol名字完全一样了
（[toString]背后是指向的绑定的Symbol(""toString"")，而[""toString""]是纯字符串背后不是symbol还是原型的toString()方法）


2、使用symbol 我们用方括号 [toStringSymbol]这样使用，可以用在对象表达式和类里面，这样[toStringSymbol]和我们的【】最初的含义相同，可以解析toStringSymbol背后绑定的 Symbol(""toString"")
Highlight:The object given to a <code>for</code>/<code>of</code> loop is expected to be <em>iterable</em>.
Sticky notes:上上节 我们不是讲过 let of：

“let / of 的背后本质是调用了 不同的数据类型（array/string）的响应这个 let of语法的函数”

实际上这个“响应这个let of语法的函数” 更确切来说就是Symbol.iterator（他是array/string自带的，类似toString()的property，但是是以Symbol的形式存储）

for(a of ""OK"") {
console.log(a)
}
背后的本质⬇️  ：

let okIterator = ""OK""[Symbol.iterator]();
for(a of okIterator) {
console.log(a)
}
Highlight:<em>iterator</em>
Sticky notes:这里简单：
就说[Symbol.iterator]的返回值是一个迭代器iterator

每次调用okIterator.next() 返回一次迭代的结果
返回
// → {value: ""O"", done: false}
最后一位就done: true 好理解
Highlight:Let’s implement an iterable data structure.
Sticky notes:下面我们就来动手实现一个 可以迭代 （满足上上节let of语法能用的）数据结构，其实看懂了代码很容易

就是自定义覆盖 [Symbol.iterator]  然后自定义 next()
前提是理解了 JavaScript 自带let of背后的原理（所以前面讲了一堆 很绕）

但是下面代码理解了他想干什么很容易
Highlight:next
Sticky notes:上面应该好理解 看懂英文就会，就是介绍Matrix 和 MartixIterator具体的代码，你可以帮忙总结写出来
Highlight:individual pieces of code
Sticky notes:这里意思是 其实我们要定义 可迭代的 Matrix完全可以在一个class{} 定义里写完，但是为了更清楚分成好理解的片段 这里定义了 Matrix 和 MatrixIterator，这本书有很多这样操作，其实可以一步到位定义Matrix：

class Matrix {
  constructor(width, height, element = (x, y) => undefined) {
    this.width = width;
    this.height = height;
    this.x = 0;
    this.y = 0;
    this.content = [];

    for (let y = 0; y < height; y++) {
      for (let x = 0; x < width; x++) {
        this.content[y * width + x] = element(x, y);
      }
    }
  }

  get(x, y) {
    return this.content[y * this.width + x];
  }
  set(x, y, value) {
    this.content[y * this.width + x] = value;
  }
  next() {
    if (this.y == this.height) return {done: true};

    let value = {x: this.x,
                 y: this.y,
                 value: this.get(this.x, this.y)};
    this.x++;
    if (this.x == this.width) {
      this.x = 0;
      this.y++;
    }
    return {value, done: false};
  }
}

Matrix.prototype[Symbol.iterator] = function() {
  return this;
};

像上面这样，最后调用的时候一摸一样
let matrix = new Matrix(2, 2, (x, y) => `value ${x},${y}`);
for (let {x, y, value} of matrix) {
  console.log(x, y, value);
}
完全没问题
Highlight:It is not even necessary for such an object to compute and store such a property directly in the instance.
Sticky notes:这里啥意思呢就是除了method还可以有一些存储值的一些属性，但是有些值 直接在constructor里写不就完了吗？

这里看看下下个代码块class Temperature，其实内部只需要存储this.celsius 存储摄氏度就可以了 而获取华氏度就定义 get fahrenheit() 方法

这样就是getter， 加一个get参数
还有setter，加一个set参数 

都好理解，只是这样使用了之后
temp.fahrenheit 这样具体化的对象 对 setter和getter就像使用 property一样使用 使用者完全觉察不出来 背后是有运算的“函数”
Highlight:<p>Sometimes you want to attach some properties directly to your constructor function, rather than to the prototype. Such methods won’t have access to a class instance but can, for example, be used to provide additional ways to create instances.</p>

<p><a class=""p_ident"" id=""p_zLJ2u9mlXs"" href=""#p_zLJ2u9mlXs"" tabindex=""-1"" role=""presentation""></a>Inside a class declaration, methods that have <code>static</code> written before their name are stored on the constructor. So the <code>Temperature</code> class allows you to write <code>Temperature.<wbr>fromFahrenheit(100)</code> to create a temperature using degrees Fahrenheit.</p>
Sticky notes:下面这两段讲static 只是有点难理解，分段理解：

1、第一段
这里“attach some properties directly to your constructor” 就是说想要用Temperature.fromFahrenheit(100)这种形式

Such methods won’t have access to a class instance but can, for example, be used to provide additional ways to create instances.
这个换种说法就懂了，就是static方法是类共有的，并不属于某个实际实例object，学了面向对象课才理解更清

2、第二段
用static定义的方法就是静态方法可以直接用类+方法名调用，而不用实例化，所以可以用Temperature.fromFahrenheit(100)
Highlight:We could write it from scratch
Sticky notes:1、我们想实现对称矩阵，关于对称轴对称

2、我们可以在原来的Matrix基础上再加一个对称实现SymmetricMatric，也可以从头开始写（write it from scratch），但是会有很多已经重复的代码

3、js的原型系统可以继承一个旧的类，新定义原有的一些属性、方法和构造函数
Highlight:In object-oriented programming terms, this is called <em>inheritance</em>. The new
Sticky notes:⬆️  介绍我们的新需求 SymmetricMatrix 一个对称的举矩阵 需要那些功能
————————————————————
⬇️  介绍js里代码 里用 继承 来方便的基于Matrix 实现 SymmetricMatrix
Highlight:extends
Sticky notes:下面三段解释上面代码块，具体继承用到的代码：
1、extends 指明继承于 Matrix，这样SymmetricMatrix就不再继承于默认的Object原型了

2、继承的子类的constructor里可以使用super调用父类的构造函数，因为继承与Matrix，如果要用一些Matrix原有的方法，还是需要按照Matrix的构造函数定义一些参数。然后我们对称矩阵做了一些限制，定义了element函数的逻辑，保证关于对称轴对称

3、set方法里用到了super.set，也是获取父类的set方法，然后重新定义子类的set方法逻辑，
（不能用this.set因为还是会指向子类的set方法，要用super.set获取父类的set方法）
Highlight:Inheritance allows us to build slightly different data types from existing data
Sticky notes:⬆️  一行行介绍 继承Matrix用到的代码步骤
————————————————————
⬇️  面向对象编程的三大特性总结
Highlight:inheritance is more controversial.
Sticky notes:至此我们就讲完了 面向对象编程的三大特性
encapsulation 封装
polymorphisim 多态
inheritance 继承

前两个比较好，后面继承比较有争议，是因为封装和多态可以减少代码的耦合性，而继承是反过来增加了代码的耦合性，但是有时候继承可以作为很好的工具，是可以使用的工具，但不应该是首选选择

具体封装继承多态可以多学更多资料了解，如：
https://blog.csdn.net/jianyuerensheng/article/details/51602015
Highlight:<code>instanceof</code>.
Sticky notes:可以用 instanceof查找 实例的继承关系

SymetricMatrrix(2) => SymmetricMatrix => Matrix => Object

只要是有父类有祖先关系 instanceof 都会返回 true
Highlight:Summary
Sticky notes:潦草总结：
1、对象除了自己定义的properties，他们还有prototypes原型，会有一些原型的属性和方法

2、构造函数一般用大写开头 定义一种类名 可以用new关键字创造新对象（定义实例特有属性），然后再在写prototype定义实例共有属性，这是es6之前的用法，之后新增class关键字 可以更清晰定义类

3、可以定义getters和setters来像属性property来操作（看不到背后的函数操作），static静态方法是类共有的方法

4、instanceof操作符 查找是否是某个构造函数的实例

5、封装是隐藏内部细节，只让外部通过你定义的一些属性和方法访问

6、多态是给相同的类函数传入不同类型的参数，自动知道如何去处理不同的参数，都能一致性处理

7、继承是 从已经存在的类 继承出新的子类
","2020-10-15 10:32:29"
"Program Structure :: Eloquent JavaScript","https://eloquentjavascript.net/02_program_structure.html","no_tag","","","Highlight:Ruby
Sticky notes:Ruby也是一种 可以应用与web的语言 有兴趣可以之后研究
上面胡言乱语翻译：
我的心在我的薄膜状透明皮肤下发出鲜红色的光，他们必须管理10cc的JavaScript才能让我回来。 （我对血液中的毒素反应良好。）男人，这些东西会把桃子踢出你的腮！
Highlight:nouns and sentence fragments
Sticky notes:这节真正将如何编程 而不是写一些JS的片段或名次
Highlight:expression
Sticky notes:任何代码片段（敲出来的代码值）都是表达式 expression：
1、括号()里的是表达式
2、二元运算符对两个表达式的操作是一个表达式
3、一元操作符的运算对应一个表达式

任何表达式可以相互嵌套类似人类语法，让我们更容易构建复杂的计算。

然后许许多多表达式exprenssion就构成一个语句sentence。一个js声明statement就是一个完整的sentence。
一个程序就是许多js声明statements
Highlight:side effects
Sticky notes:就是写的程序应该产生一些影响：
1、在屏幕上显示东西
2、改变机器的全局状态（增加全局变量）
3、影响这个语句之后的之后的声明statements
上面这些叫做side effect副作用 这样的程序才有有用的程序
（单独产生1和!false无用无副作用）
Highlight:omit the semicolon at the end of a statement
Sticky notes:js可以保留分号也可以省略分号，这本书全部都带上分号，因为不写分号可能会出错，保险不想找麻烦还是都写上。

翻译原句：
The rules for when it can be safely omitted are somewhat complex and error-prone.
何时可以安全地省略它的规则有些复杂且容易出错

I recommend you do the same, at least until you’ve learned more about the subtleties of missing semicolons.
我建议您进行同样的操作，至少直到您进一步了解分号缺失的精妙之处为止。
Highlight:binding
Sticky notes:就是说 要是值不给一个绑定到变量
很快就会在内存里消失
Highlight:=
Sticky notes:可以只声明一个绑定
let caught;
这是正确的 申请了一个内存空间

如果要立马赋值就加上=
let caught = 5 * 5
Highlight:tentacles
Sticky notes:把绑定看作触须，而不是盒子。

绑定不包含值 而是抓住值

1、一个binding可以 变换抓住的值（=赋值改变）
2、多个binding也可以抓住同一个值

程序运行 需要操作有名字的变量啥的，要记住变量，就要定义binding抓住值来操作
Highlight:var
Sticky notes:var是2015年之前js的用的绑定方法
大部分和let一样，但是有很多bug和不好，在下一章来说明
Highlight:const
Sticky notes:定义一个持久的绑定，只要存在就永远指向同一个值（但是对象是例外，对象里面的property还是可以改变的），字符串，数字肯定不变
Highlight:Binding names
Sticky notes:绑定命名规则：
1、可以有数字 catch22 ✅  但是名字不能以数字开头
2、可以有符号，但是只能是$ 和 _两种
3、不能与JavaScript内置关键字重复，还有一些未来预定的关键字，有很多 用熟了就明白有哪些了 不用记，并且会报错提示
Highlight:language standard
Sticky notes:保存存在的值和绑定的空间叫做环境 environment

环境里还会存在一些额外的绑定：
1、始终包含作为语言标准的一些绑定
2、与周围系统进行交互的方式的绑定（例如获取鼠标与键盘输入）
Highlight:type <em>function</em>
Sticky notes:现学现用

比如function 就是 environment里会自带的绑定

函数是包裹在一个值中的一段程序。 可以应用这些值以运行包装的程序。
Highlight:parentheses
Sticky notes:函数名后用一对括号 () 来调用函数，也可在括号传入参数（这也太基础了教小白一样 自己看）
Highlight:console.log
Sticky notes:1、console.log 不是指这个变量名里有非法的 . 而是 console是一个 第4章学的对象

2、console.log可以在node.js和浏览器环境运行在terminal或浏览器控制台打印出来结果
（用f12或command-option-I打开控制台调试模式）

3、
Highlight:side
effect
Sticky notes:副作用（显示一个对话框或在屏幕上显示）：只有产生副作用的函数才是有用的。

函数也可以retrun一个值 这样不具体产生副作用也可以使用。
（其他的操作 再利用这个计算return的值产生作用来使用）

console.log(Math.min(2, 4) + 100)
Highlight:more than one statement
Sticky notes:1、当有多于一条的声明 就会顺序向下执行，最简单的结构

2、用了个转换函数 Number 类似好友String 和 Boolean
Highlight:<p><em>conditional
execution</em>.</p><figure></figure>
Sticky notes:1、条件执行，就是不是从头到尾的执行,
底下例子就是，判断输入是不是合法的数字，如果不是合法数字就不打印

2、简单的要死，非要说明白一点看下面的代码
Highlight:if
Sticky notes:1、Number.isNaN 判断啊是否为合法数字

2、if语句 多余一条语句要用花括号括起来 {}

3、其他情况用else，真的简单不多注释了这节
Highlight:<p>This form of control flow is called a <em>loop</em>.</p><figure></figure>
Sticky notes:1、循环语句，就是利用while或for来执行循环
Highlight:counting from 0
Sticky notes:从0开始计数有好处
Highlight:<code>do</code> loop
Sticky notes:do循环 至少会执行一次循环 然后循环判断是否满足条件
Highlight:stand out
Sticky notes:就是程序完全可以写在一行里，
但是为了突出代码结偶 我们可以定义一些代码块

也可以用代码编辑器帮你自动缩进

块内缩进的作用是使代码的结构突出。 在其他块内打开新块的代码中，很难看到一个块在哪里结束而另一个在哪里开始。 通过适当的缩进，程序的视觉形状与程序内部块的形状相对应。 我喜欢为每个打开的块使用两个空格，但是口味有所不同-有些人使用四个空格，有些人使用制表符。 重要的是每个新块都增加了相同的空间。
Highlight:<code>for</code>
Sticky notes:没啥 就是另一种 for循环

前面是while循环
let number = 0;
while (number <= 12) {
  console.log(number);
  number = number + 2;
}
Highlight:parentheses after a <code>for</code>
Sticky notes:for关键字后面跟着的三个东西
let number = 0 初始定义
number <=12  检查条件
number = number +2  每次迭代更新
Highlight:break
Sticky notes:用break关键字跳出循环

下面的循环 没有 break是无限死循环 需要关掉浏览器重启
Highlight:continue
Sticky notes:continue关键字类似break

但是会跳过当前循环执行下一个迭代
Highlight:switch
Sticky notes:用switch 分开很多分支选项，根据不同的值选择不同的路径执行

但是javascript内置switch很丑，用起来还没有if else美观，记得用break跳出来，不然一直向下执行出错。最后一大堆翻译：

您可以在通过开关打开的模块中放置任意数量的案例标签。 程序将在与给定开关值对应的标签处开始执行，如果没有找到匹配的值，则在默认情况下开始执行。 即使到达其他标签，它也会继续执行，直到到达break语句。 在某些情况下，例如示例中的“晴天”案例，可以在案例之间共享一些代码（建议在晴天和阴天时都出门）。 但是要小心-容易忘记这种中断，这将导致程序执行您不想执行的代码。
Highlight:bottom style
Sticky notes:用多个单词表示语义，最好用小驼峰法命名


Number这种是构造函数的表示，所以开头就大写

不要被这种不一致性困扰
Highlight:A <code>//</code> comment goes only to the end of the line. A section of text between <code>/*</code> and <code>*/</code>
Sticky notes:// 单行注释

/**/ 多行注释
Highlight:Summary
Sticky notes:这节简单的很

主要是说明编程里面的基本内容，第一节里只说明了数据类型 简单的操作符等等

这一节则是更具体说明如何写程序，写程序就需要多种语句多种语句就有 顺序/条件/循环   变量的绑定  函数的声明等等 easy 都不知道咋注释
","2020-09-16 08:38:40"
"Project: A Programming Language :: Eloquent JavaScript","https://eloquentjavascript.net/12_language.html","no_tag","","","Highlight:immensely
Sticky notes:就是本章来构建一个自己的编程语言Egg

别把构建语言看成很难的一个任务，
“我经常觉得有些人类发明非常聪明和复杂，以至于我永远无法理解它们。 但是，只要稍加阅读和试验，它们就会变得相当平凡。”

这里我们构建一个很小简单的语言 足够完成一些计算
Highlight:Parsing
Sticky notes:这里我的方式不是看下面说的一大堆解释它的代码怎么运行的，看他说的可能越看越晕或者理解不透就跳过了

而是直接 debug它的代码，一步步看它的代码是怎么运行的，并自己结结巴巴总结出来视频，跳过它的一大堆解释，你可以参考下我的解释视频： 有5段视频，可能被我绕来绕去，一口气看完5段效果更佳

https://user.qzone.qq.com/1186179435/mood/6ba9b346da5a355f2d700200
Highlight:<em>syntax</em>, or notation
Sticky notes:一个编程语言最重要的是语法。（比如python用缩进代表代码块，c变量前要加类型 int a=1）

所以我们需要一个解释器parser 来将我们语法的代码转换成一个对象然后根据这个对象反应程序逻辑

如果解释失败 就会报错
Highlight:application
Sticky notes:我们Egg里的每个东西可以当作表达式，一个表达式可以是任何东西：绑定变量/数字/字符串/或者应用表达式

这四个在下面四段解释
Highlight:parser simple
Sticky notes:我们解释器程序也不能解析瞎写的egg代码

1、不能有反斜杠转义 比如 \n这种

2、egg的字符串不能含有双引号

3、egg的数字是一系列数字

4、egg的绑定名（变量名）不能有空格并且在语法中没有别的含义
Highlight:Applications
Sticky notes:Application（这个鬼东西，叫他应用表达式，就是define(x,10)这种，叫做应用表达式，有点像调用函数）

应用表达式用js的形式来写，用一个（）括号把一个表达式括起来，并且用，逗号带上许多参数
Highlight:uniformity
Sticky notes:1、这里有个奇怪的：
>(x, 5)

然后这个叫做Egg语言的一致性，我们把>z合格也当作一种普通的绑定 和 define(x, 10) 这种差不多

2、并且由于我们语言没有块的概念，我们用一个do方法来执行连续许多操作
Highlight:The data structure that the parser will use to describe a program consists of
Sticky notes:上面介绍Egg语言的语法
————————————————
下面介绍解释器parser的原理 和 使用的技巧
Highlight:properties
Sticky notes:这里来总结解释器解释出来所有的类型

1、“value”类型单纯值 ，另有value代表具体值
{type: ""value"", value: 5}

2、“word”类型 代表标识符 （识别绑定x或者>这种比较符），另有name代表标识符名称
{type: ""word"", name: ""x""}
{type: ""word"", name: "">""}
他们是不同的“word”，有另外操作

3、“apply”类型 代表应用表达式，就是具体执行一个表达式，另有opeartor属性代表操作，和args属性代表操作的参数
> 是 operator
x 和  5 是参数
Highlight:syntax tree
Sticky notes:谷歌翻译：
这样的数据结构称为语法树。 如果将对象想象为点，并将它们之间的链接想象为这些点之间的线，则它具有树状的形状。 表达式包含其他表达式，而该表达式又可能包含更多表达式，这一事实类似于树枝拆分再拆分的方式。

看图好理解
Highlight:recursive structure
Sticky notes:1、于是我们的解释程序 不同于 第九章的正则解析程序
第九章是将程序拆分成一行一行的，然后每一行判断是不是简单的我们知道的形式

2、
这一章解析程序需要解析递归结构，因为一个表达式底下可能包含更多表达式
Highlight:Fortunately, this problem can be solved very well by writing a parser function
Sticky notes:我们解释器parser的思路
——————————————
我们解释器的具体代码实现，虽然一大堆不要怕，跟着我的思路一点点解决
Highlight:parseExpression
Sticky notes:这个parseExpression函数是解析一个字符串的第一个
比如
+(a, 10) 就解析出 +   为 ""apply""
(a, 10) 就解析出 a    为 “word”

但这个函数的返回值比较奇怪，是
return parseApply(expr, program)

这个parseApply函数只是再看program(程序字符串)后面的内容，然后不断调用parseExpression，让program字符换的内容 不断转换到 expr参数里 变成代表程序的对象

这里有一个递归的思想
Highlight:The evaluator
Sticky notes:这个执行器还是讲太早了结构有问题，强烈建议先到下面学，因为调用evaluator需要最终完成语言的执行步骤是：

evaluate = parse + specialForms + topScope

这个topScope和specialForms还没有讲 这里讲了evaluate函数也没有用

1、topScope的作用一是单纯的作为“environment” 存储一些自定义的变量 全局变量等等
二是有些基本的操作 比如 + - * /这些语句 需要先定义，

2、specialForms就是一些逻辑操作 if while do 等等 内置的关键字

现在的evaluate完全没有意义，先学习下面再上来
Highlight:syntax tree
Sticky notes:当我们有了语法树（就是上节累死获取的对象），然后加上一个scope作用域（包含每个变量的绑定比如a=123）就可以评估我们Egg语言的语法并且执行返回出正确的值
Highlight:scope object
Highlight:each of the expression types
Sticky notes:我们的evaluate分三类处理解析：
1、“value” 普通的字符串或数字
直接return
2、“word” 是一些绑定
去topScope里查找，找到则return绑定的值
没找到则throw ReferenceError

3、“apply” 复杂一点，是“应用表达式”
这时候就具体看 operator 和 args，
let {operator, args} = expr
再分两种情况
a、如果operator.type是""word"" 并且是 specialForms的if/do/while这些 就直接在specialForms对象里找对应执行代码
传入调用参数 是 args（上面代码小问题麻烦：expr.args == args，可以改简化一点）

n、如果operator.type不是“word”
那就不是简单的if/while这些操作了，是再新增的“Function”类型，再到下面去学，也好理解
就是 let op = evaluate(operator, scope);

然后 op操作 调用一下， 传入每个 args作为参数
Highlight:cture of <code>eva</code>
Sticky notes:evaluate和parse类型有点递归的结构，就是evaluate函数里也可能调用evaluate

The recursive structure of evaluate resembles the similar structure of the parser, and both mirror the structure of the language itself. 
谷歌：评估的递归结构类似于解析器的类似结构，并且都反映了语言本身的结构。

也可以写代码把parse和evaluate混在一起 分开就绕死了，还混着更麻烦

解析执行很简单，但是还需要后面两小节 加一些环境变量
Highlight:<code>specialForms</code> o
Sticky notes:specialForms对象里 用来定义一些Egg的特殊的语法 special syntax， 是一个全局变量 不同于下一节的 topScope 定义一些Egg的逻辑操作一点点向下看
Highlight:if
Sticky notes:sepcialForms.if：
1、这个还有点奇葩，因为蛋语言有点怪，是用“应用表达式”的形式，并没有js语言的这种：

if(a>b){
  A
} else {
  B
}

蛋语言就是 if(a>b, A, B)，有点像三目表达式 ? :的语法，一开始还有点懵

2、还有蛋语言不会把0或“”字符串看作false，只有真正的false才是false
3、还有要把if封装成一个specialForm的原因是，第二个和第三个参数只有一个会执行运算，取决于第一个参数返回true/false，（也就是说没有运行的参数函数不会运行造成影响全局变量的值啥的）
Highlight:while
Sticky notes:specialForms,while：
讲的很简单就下面给出例子，应该还有要注意的

1、while应该要传入两个两个参数while(A, B)
A是函数参数，应该返回false/true，是判断是否一直进行虚幻
B也是函数参数，就是每次循环要执行的参数（可能会更给与A一起操作的全局变量，不然死循环出不来）

2、蛋语言没有undefined，也是要用严格的false
Highlight:do
Sticky notes:specialForms.do：

看我们前面写的蛋语言程序段：
do(define(x, 10),
   if(>(x, 5),
      print(""large""),
      print(""small"")))
这个do有点像 “main”函数主体，就是在我们所有操作外面套一层，然后let arg of args，一条条的执行（比如上面段是define然后if）
Highlight:<code>define</code>.
Sticky notes:specialForms.define：

1、需要新创建绑定变量
2、参数要求第一个参数是“word”类型，第二个参数是""value""类型
就像define(x, 10)
这个样子 参数不对就报错
Highlight:Let’s define an object to represent the global scope.
Sticky notes:function evaluate(expr, scope) {

evaluate函数的的 “scope” 参数是一个存储全局变量的一个对象，用来查找绑定和对应的值
Highlight:To be able to use the <code>if</code>
Sticky notes:为了支持if ，我们蛋语言 还不知道 false/true这两个“绑定”/或者叫字符串的含义是 true和false，下面定义了就好用specialForms.if了
Highlight:To supply basic arithmetic and comparison operators
Sticky notes:为了支持数学运算和比较，我们要定义一些下面简单的基本操作符

注意下面的Function是modules一章讲过https://eloquentjavascript.net/10_modules.html#eval

可以用字符串形式定义函数
Highlight:A way to output values
Sticky notes:然后打印也很有用 再定一个print
Highlight:That gives us enough elementary tools to write simple programs. The following
Sticky notes:parse
sepcialForms
topScope
evaluate

四个准备工作终于弄完了，parse最最复杂需要看视频理解，攻克只要头脑清晰到这里还是好理解的，下面run函数将上面四个综合到一起，可以方便的运行我们的蛋语言

run(`
do(define(total, 0),
   define(count, 1),
   while(<(count, 11),
         do(define(total, +(total, count)),
            define(count, +(count, 1)))),
   print(total))
`);
// → 55
Highlight:We’ll use object prototype chains to represent nested scopes so that the program can add bindings to its local scope without changing the top-level scope.
Sticky notes:这一句啥意思？
就是我们用了Object.create(topScope)

因为topScope（类似specialForms这个对象）是我们需要在JavaScript程序外面定义的变量

我们又用Object.create(topScope) 又创建一个副本，然后传入到我们的“Egg语言”，里去，因为是Object.create利用了对象原型链来代表叠层作用域，这样运行的时候也不会更改我们外面的topScope顶层作用域，封起来的意思

然后下面就实验了一下我们的Egg语言，很好用！！
Highlight:lines of code.
Sticky notes:现在看完啦specialsForm和topScope，再回到上面我们的evalutae 看一下很好理解！！
Highlight:fun
Sticky notes:一个定义的语言如果不能自定义函数就很菜

定义自己的函数也很简单

specialForms.fun：
注意定义的形式，比如下面fun(a, +(a, 1))
通用结构fun(a, b, c, ..., BODY)
形式是，前面几个a/b/c是函数的参数，BODY是定义的函数体

明白结构了看他们下面代码很好理解

但是还需要注意下个注释arguments
Highlight:arguments
Sticky notes:return function() {
    if (arguments.length != params.length) {
      throw new TypeError(""Wrong number of arguments"");
    }

上面代码里arguments是啥？ 找了半天发现不是自己定义的，其实本质上是 JavaScript内置的一个对象，可以学学：https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Functions/arguments

上面这个if (arguments.length != params.length) {
是判断 egg蛋语言里调用自己定义的函数的时候保证参数个数匹配

然后函数也会自己创建局部作用域let localScope = Object.create(scope);保证不和外界作用域干扰


好理解
Highlight:Compilation
Sticky notes:哦哦 我们自定义的egg语言讲完了

下面是来说一下“解释型语言”和“编译型语言”的区别

解释型语言有 python JavaScript
编译型语言有 C C++
Highlight:interpreter
Sticky notes:我们前面费劲定义的Egg蛋语言实际上是重要构建了一个解释器“interpreter”


evaluate就执行了parser得到的对象题
Highlight:Compilation
Sticky notes:另外一种是编译，在parse和evalute中间还有一个额外的步骤，就是将代码编译成更有效率的东西（二进制代码）

所以：
compliation: parser + compliation + evaluate
interpreter: parser + evaluate

设计良好的语言应该对每个绑定直接综合到代码里，这样就不需要在运行程序的时候在内存空间存放一个binding 空间 然后每次用变量去查询（编译型语言效率更高的原因）
Highlight:compilation.
Sticky notes:传统意义上的编译是将我们系的代码转换成二进制的及其代码，最原始的计算机进程执行的，但是现代意义上只要将一个程序转换成另外形式都可以叫做编译。

然后我们也可以尝试将Egg语言也写成编译型语言，思路是用Function来调用JavaScript的编译器，当编译好了就可以执行很快

如果感兴趣可以试试
Highlight:built on top of JavaScript
Sticky notes:其实可以发现我们的specialForms.if/while 背后本质上还是调用JavaScript的 if 和while
egg语言是基于JavaScript的，这样有好处可以很方便

如果从头到尾新写一门变成语言太复杂了，但是也可以真正学会一门语言的原理

Similarly, the values in Egg are just regular old JavaScript values.
谷歌翻译：
同样，Egg中的值只是常规的旧JavaScript值。
Highlight:And when it comes to getting something done, cheating is more effective than
Sticky notes:⬆️  说明我们的Egg语言是基于JavaScript的 是cheating笑哭
————————————————————
⬇️  我们的蛋Egg语言也可以完成一些方便的任务
Highlight:<em>are</em> situations where writing small languages helps get real work done.
Sticky notes:虽然Egg语言可能不能比JavaScript做的更好，但是有些情况写这种小型语言可以完成一些真实的工作：

1、这种小语言不用和典型的变成语言一样，包含很大很全的各种语法，比如如果js没有内置正则表达式，我们完全可以写一个自己的小的正则表达式的解释器和执行器

2、或者想象您正在构建一个巨型机器人恐龙，并且需要对其行为进行编程。 JavaScript可能不是最有效的方法。 您可能改为选择如下所示的语言：

这就是通常所说的领域特定语言，一种专门用于表达狭窄知识领域的语言。 这种语言比通用语言更具表现力，因为它旨在准确描述需要在其领域中描述的事物，而没有别的。
————下面两段是谷歌翻译

啊啊 我终于干不动过了了，这一段是苏亚鹏在2020/11/11 完成全书中文注释的位置，我好感动！！！
","2020-08-09 08:17:07"
"Asynchronous Programming :: Eloquent JavaScript","https://eloquentjavascript.net/11_async.html","no_tag","""Summary""","","Highlight:so far
Sticky notes:之前见到的程序都是 让 进程一直忙碌直到完成工作的 （同步程序）

同步程序的速度 很大程度决定于进程速度
Highlight:But
Sticky notes:但是有的程序可能不只是与本机的进程交互，例如与网络通信，就不能用同步程序一直等待这个任务完成（可能网络特别卡但是电脑cpu很快，同步进程不行），解决方法：

1、操作系统的多进程
2、异步编程
Highlight:asynchronous
Sticky notes:1、同步编程模型，所有函数actions动作同一时间进行，当调用一个函数，他只有在函数动作完成的时候return，这让程序program要等待函数行为执行的时间

2、异步编程模型，允许多个程序actions同一时间运行，当你开一个函数行为，程序继续执行，当函数行为完成的时候它通知程序，并让程序program有接口获取结果
Highlight:We can compare synchronous and asynchronous programming using a small
Sticky notes:同步异步对比
————————————
用一个获取网络、合并资源的例子说明两种编程模型解决方案

同步解决方案
Highlight:solution to this problem, in a synchronous system
Sticky notes:同步编程，每个任务接着一个个进行，解决方法之一是开启多线程，同时运行多个线程执行任务，最后将结果合并
Highlight:In the following diagram
Sticky notes:下面图展示两者区别
1、粗线代表程序正常运行需要时间，细线代表等待网络的时间

2、在同步模型中，对于给定的控制线程，网络花费的时间是时间线的一部分。 在异步模型中，从概念上启动网络操作会导致时间轴分裂。 发起该动作的程序将继续运行，并且该动作将在该动作旁边发生，并在完成时通知程序。
Highlight:Another way to describe the difference is that waiting for actions to finish is
Sticky notes:异步解决方案
Highlight:synchronous
Sticky notes:这章真有点难，多谷歌翻译：
描述差异的另一种方法是，等待动作完成在同步模型中是隐式的，而在我们的控制下，在异步模型中则是显式的。
Highlight:Asynchronicity cuts both ways.
Sticky notes:1、异步性是双向的（有好有坏）。 它使表达不适合直线控制模型的程序变得更加容易，但也使遵循直线的表达程序更加笨拙。 在本章的后面，我们将介绍一些解决这种尴尬的方法。

2、多数的浏览器或node程序多用异步方法，而不是多线程（多线程难理解）
Highlight:crows
Sticky notes:本节就是用一个 乌鸦通信的例子 将我们的异步编程，下面一大堆 是作我们要实现的模型的介绍，简介：

1、乌鸦很聪明，能用工具，计划，记忆和交流
2、专家说乌鸦有能力做很多东西，但我们不知道，可能赶上人类科技
3、例如，乌鸦有能力构建计算的东西，他们用与昆虫的共生关系，乌鸦给虫子食物，虫子构建巢穴，然后乌鸦利用活物来计算（这比拟看的人发火，非但没帮助你理解还让你更抓狂）
4、这样的殖民地通常位于长寿的大巢中。鸟类和昆虫共同工作，以建立一个球形的粘土结构网络，该结构隐藏在巢的树枝之间，昆虫在其中生活和工作。
5、为了与其他设备通信，这些机器使用光信号。乌鸦在特殊的通讯杆中嵌入了反射材料，而昆虫则将这些反射的材料反射到另一个巢穴上，将数据编码为一系列快速闪烁。这意味着只有视觉连接完整的嵌套才能进行通信。
6、我们的弯腰专家是我们的朋友，他们绘制了罗纳河两岸希耶尔河畔安比村的乌鸦巢网络。该地图显示了嵌套及其连接：
7、在融合进化的一个惊人例子中，乌鸦计算机运行JavaScript。 在本章中，我们将为他们编写一些基本的联网功能。
Highlight:callback
function
Sticky notes:1、异步编程的一个方法是 在一个动作完成之后结合动作完成结果调用回调函数

2、例如setTimeout函数，在一段延时之后调用回调函数

3、等待在编程中很有用，可以用来更新动画或者检查是否超时

4、但是如果连续使用很多异步操作，就需要不断传入回调函数
Highlight:Most crow nest computers have a long-term data storage bulb, where pieces of
Highlight:functions
Sticky notes:这一节用了很多比拟的话，很多生英语好讨厌，比如这里在计算机内特定地方存储信息，这里比喻成在树枝上雕刻，腐蚀信息，醉了

就是说 很多数据存在 一个 Storage 里面，因为数据很多，存储和调用 Storage的数据 都是异步操作 花费时间 要传入回调函数
Highlight:encodable
Sticky notes:下面代码例子就展示了 回调函数怎么用：
1、数据都用 JSON编码

2、这里 bigOak,readStorage 方法是异步操作，调用了两次，因为数获取据比较多，步骤是：
①获取""food caches"" ，可能是""总的食物存储""，得到caches，然后caches也比较大，再回调
②获取caches[0]，可能是“仓库A”一大堆，再调用回调，获取了很多仓库A的食物

因此用了两次回调模拟过程
Highlight:This style of programming is workable
Sticky notes:这种回调函数的用法可以使用，但是回调函数会不断的进入另一个函数，构成一种缩进结构，当异步操作多了可能会很复杂很奇怪
Highlight:request-response
Sticky notes:下面这三段说乌鸦巢的沟通方式其实就是计算机网络的发送请求request和返回结果response！！

1、乌鸦巢计算机用的是request-response请求对的形式，发送一条信息并且得到一个恢复

2、每个messag有一个type（就是计算机网络的GET、PUT、POST、DELETE）用来告诉被请求端应该执行什么操作

3、send() 函数的参数：
1、目标巢穴（服务器），“Cow Pasture”
2、信息类型type，“note”
3、信息内容，""Let's caw loudly at 7PM""
4、得到返回的回调函数：
() => console.log(""Note delivered."")

（这里回调函数如果能操作结果可以带上结果如：
(result) => console.log(result)）
Highlight:defineRequestType
Sticky notes:（这个比拟真的服了，其实就是计算机网络工作原理，要是没有提前学过计网，看什么乌鸦安装电脑一脸懵逼）
1、处理request的操作需要给每个nest巢穴安装一个（就是巢穴相互通信，在我们例子只有两个通信，在一个巢穴想给别人通信，对方必须有相应）（上一段）

2、defineRequestType函数定义新的“note”请求，执行的操作hanlder就是打印出来看看
Highlight:done
Sticky notes:这个代码真的有点复杂，一定要理解好这两段代码，是后面章节其他代码的基础，录了视频帮助理解：
https://user.qzone.qq.com/1186179435/mood/6ba9b34696232a5f12e60700

这一段谷歌翻译：
赋予处理程序的第四个参数完成是一个回调函数，在完成请求后必须调用该函数。 如果我们将处理程序的返回值用作响应值，则意味着请求处理程序本身无法执行异步操作。 完成异步工作的函数通常在工作完成之前返回，并安排了在完成时调用回调。 因此，我们需要某种异步机制（在这种情况下，是另一个回调函数）来发出响应可用的信号。

第二段分析一下：
1、是什么：我们让(nest, content, source, done) => {
  console.log(`${nest.name} received note: ${content}`);
  done();
}
这个函数的返回值作为请求的response，我们就不能“模拟”请求的异步行为了（整个过程都是假的！！一个要模拟服务器的耗时，一个要模拟request发出后，异步获取服务器的response）
2、为什么：完成异步工作的函数通常在工作完成之前返回，并安排了在完成时调用回调。
3、怎么样：所以我们又用了一个done异步回调函数来模拟！！！

整体意思就是 一个异步操作里再加一个异步操作，woc把我看傻了
Highlight:calls a function
Sticky notes:谷歌翻译：（说明callback方法的坏处）
在某种程度上，异步性具有传染性。 调用异步工作的函数的任何函数本身都必须是异步的，使用回调或类似的机制来传递其结果。 与简单地返回一个值相比，调用回调在某种程度上更加复杂并且容易出错，因此需要以这种方式构造程序的大部分不是很好。

真的挺迷惑 是书说错了吗？
这一句：“调用异步工作的函数的任何函数本身都必须是异步的”

我理解异步函数定义之后向下执行，然后当条件达到的时候折回来再执行callback
但是下面代码：
function b(){
    setTimeout(()=>{console.log('abc')},123)
}
function a(){
    console.log(123)
    b()
    return 1234
}

let c = a()
console.log(c)

同步函数a还是能调用异步函数b呀 并且打印出来
123
1234
abc
本来我以为 return之后整个程序段就结束了 但是他还是能打印出来abc 说明同步函数内可以有异步操作，严重怀疑是node或者浏览器环境对这种情况进行优化了，这本书过时了，或者我理解错了，希望以后的小伙伴有理解的联系qq：1186179435

总之就是说callback容易套娃写代码吧 也可以先过，先学好最新方法promises
Highlight:Working with abstract concepts is often easier when those concepts can be represented by values.
Sticky notes:这一句英语五级：
当抽象概念可以用值表示时，使用抽象概念通常会更容易。

1、就是说，在异步操作里面，可以用Promise来操作一些未来的值（对象），而不是为未来的结果执行函数很容易出错

2、这就是Promise干的事情，promise是一个未来可能完成并且返回值，会在返回的时候通知
Highlight:Promise.resolve
Sticky notes:下面将Promise.resolve的例子 ，千万别被这个鬼东西绕进去了，这个我们正常用的new Promise用法不一样

1、这个Promise.resolve()函数将你传入的任何值转换何成Promise

2、如果传入参数是promise，原封不动返回，
如果不是promise，帮你封装成promise，并且立即resolve返回（就相当于转换一个变量，没有函数体肯定立即返回呀）
Highlight:<p><code>then</code> method. This registers a callback function to be called when the promise resolves and produces a value. You can add multiple callbacks to a single promise, and they will be called, even if you add them after the promise has already <em>resolved</em> (finished).</p>

<p><a class=""p_ident"" id=""p_BLNHvARdwj"" href=""#p_BLNHvARdwj"" tabindex=""-1"" role=""presentation""></a>But that’s not all the <code>then</code></p>
Sticky notes:这两段讲then()方法

1、then方法的逻辑是为一个promises绑定一个回调函数，这个回调函数的参数是promises对象返回的值，并且then()可以绑定多个callbacks对同一个promises返回的值，并且可以在promises已经resolved之后绑定

2、then方法不仅会执行回调，还会return一个 promise
就是说
let a = storage(bigOak,""food caches"").then(value => console.log(""Got"", value))
a是一个Promise

这个promises在以下两种情况resolve
1、回调函数return一个值，比如回调函数为：
value => {
    console.log(""Got"", value)
    return 123
}
然后a.then(value => console.log(value))，就能打印出123    （这个可能有用吧就是promise的回调函数的promise）
2、回调函数return一个promise，等待这个promise
Highlight:useful
Sticky notes:这里讲怎么理解promises

1、把promises向左一个可以把值放进去的容器

2、普通的值（比如常量）会已经存在

3、而promised的值（有困难是Fetch方法的值得到的）有可能已经存在或者未来某个时间存在

4、当这些所有的值都就绪的时候，就调用回调函数（一系列计算）

比如下面 storage的例子，value就是promised的值，当value的值准备好的时候，就调用console
Highlight:<code>Promise</code> as a constructor.
Sticky notes:这里讲 构造 new Promise
1、这个 Promise 的构造函数的参数是一个函数（这个函数立即调用），这个函数的参数是两个函数（一个resolve函数参数，一个reject函数参数）
在函数主体里可能调用resolve或者reject参数来完成then或者reject里的定义操作

首先这个new Promise里传入的函数被立即调用 然后主体下面可能执行resolve或者reject
Highlight:resolve
Sticky notes:我觉得他例子下面代码不好 把你绕晕了，其实结构很简单，它的readStorage函数就是根据“enemies”得到另一个字符串，简化他的：

function storage(nest, name) {
  return new Promise(resolve => {
    let value = name
      setTimeout(() => resolve(name), 20)
  });
}

storage(bigOak, ""enemies"")
  .then(value => console.log(""Got"", value));

关注主体是：
resolve => {
    let value = name
      setTimeout(() => resolve(name, 20)
  }

调用这个函数 ，然后 20ms之后 调用 resolve(name)，注意pormise形式的逻辑
Highlight:advantage
Sticky notes:promises的好处：简化了异步函数

没有使用回调函数，基于promise的函数看起来和正常的函数一样

有传入的参数（resolve和reject）

有返回的结果（利用参数resolve和reject的主体）（只不过结果可能未来才会好）
Highlight:first argument to the callback is used to indicate that the action failed, and the second contains the value produced by the action when it was successful
Sticky notes:任何程序都可能报错 对异步函数也同样是的

但是回调函数callback风格异步对差错处理很困难

常用解决方法是给回调函数的参数是(error, value)，此类回调函数必须始终检查它们是否收到异常，并确保它们引起的任何问题（包括由它们调用的函数引发的异常）均已捕获并分配给正确的函数。
Highlight:Promises make this easier. They can be either resolved (the action finished
Highlight:automatically
Sticky notes:1、Promises就简单很多，一个promises的状态有两个resolve（成功调用）和reject（失败调用）

2、resolve可以有很多（绑定很多then），但是reject只有一个会扩散到所有的resolve，当resolve 抛出一场then就会被rejected

3、所以当有一系列 异步操作，任何一个报错，整个都会报错，并且没有成功的处理函数被调用
Highlight:rejecting
Sticky notes:1、resolve参数是一个 函数 他有一个参数
value => {console.log(value)类似}

2、reject参数 也是 类似 的函数参数
error => {console.log(error)} 这个error就是reject的报错信息

3、所以当一个 handler 函数里 有一个 exception的时候 就会调用 reject 然后 这个 exception 就会当作 reject的 error 参数

4、当handler里 还return 一个 promise 当这个promise里有 exception 会传递回来 ，然后给 reject函数 确保捕捉到合适的 报错信息

5、有一个Promise.reject 创建一个 立马被rejected的promise
Highlight:catch
Sticky notes:catch方法 也和 then 方法类似 用来定义 reject函数参数，也是会返回一个新的 promise

这个promise
1、在原本的Promises正常resolve的时候 自己也resolve

2、在原本的Promises没有正常resolve的时候（throw a error），调用自己的catch 处理函数

怎么说呢 ，就是
let a = new Promises(***).catch(###)
这个a是一个 promises
然后看***的内容有无正常执行，正常则执行a.then()正常的，***报错就执行a.catch() 调用自己的reject方法

3、当catch(###) 当###报错的时候 a也会执行reject
Highlight:<p>As a shorthand, <code>then</code> also accepts a rejection handler as a second argument, so you can install both types of handlers in a single method call.</p>

<p><a class=""p_ident"" id=""p_JarwEqSrWp"" href=""#p_JarwEqSrWp"" tabindex=""-1"" role=""presentation""></a>A function passed to the <code>Promise</code> constructor receives a second argument, alongside the resolve function, which it can use to reject the new promise.</p>
Sticky notes:reject具体代码使用

1、catch()方法传入

2、then() 方法支持第二个参数作为reject函数参数，一次绑定两个（免得写两遍，但是结构不太清晰）

3、new Promise的时候 传入构造函数的，包含reject
(resolve, reject) => { }
Highlight:promise
Sticky notes:1、多个promise构成的链条可以看成一个管道，这些promises每个都由catch或者then创建，管道就顺次往后面移动，有可能碰到异步成功的值，有可能失败
（就比如下面的例子，catch返回值也是一个promises
new Promise((_, reject) => reject(new Error(""Fail"")))
  .then(value => console.log(""Handler 1""))
  .catch(reason => {
    console.log(""Caught failure "" + reason);
    return ""nothing"";
  })
  .then(value => console.log(""Handler 2"", value));
）
这里有两个promises，就是所谓的chains


2、这种链条由绑定处理函数构建，所以每个节点（每个promise）都有成功/失败处理事件，比如例子里，第一个promise由then和catch，第二个只有then

3、handlers理没有匹配到合适的值就会忽略（例子里第一个promise的then被忽略）

4、但是成功匹配的值会决定之后promise管道里的调用，比如这里
第一个promise的catch成功了
然后catch也成功了（要return “nothing”，这个是then/catch返回promise的特色，return之后才能触发下一个promise）就调用第二个promise的then

万一catch里面再throw error，就调用第二个promise的catch

这就是前面匹配成功的值决定后面promise的走向

5、这一段就是解释下面代码的 结合一起 不然很懵逼
Highlight:. Sinc
Highlight:.<span class=""diigoHighlightCommentLocator""></span> Han
Highlight:promises
Sticky notes:这四段讨论 promises或callback的 网络传输
1、乌鸦的计算机可能因为光线挡住，信号发出去永远收不到

2、这样导致，send函数的回调函数永远不能触发（没有回复），可能导致程序没觉察到没有回复就停止了。比较好的解决方法是设定一个计时器，在一段时间没有回复就报告错误

3、有时候网络传递信息失败有偶然性，可能再多试几次就可以成功了，所以我们设置超时几次然后重新尝试

4、因为promise很好，所以我们让我们的请求返回pormise，callback和promise两者一般可以相互转化
Highlight:Even when a request and its response are successfully delivered, the response
Sticky notes:讨论network问题
——————————
实际写代码
Highlight:<code>send</code> and <code>defineRequestType</code>
Sticky notes:具体有两种错误reject
1、前面讨论的网络问题，超时没有获取到

2、发送的请求类型不对（服务端操作出错）

利用像之前讨论的方法，第一个参数作为failure的理由，第二个参数作为结果
Highlight:translated
Sticky notes:上面一大堆 可以 用下面封装的函数来解释，这样封装之后 之前的代码：

bigOak.send(""Cow Pasture"", ""note"", ""Let's caw loudly at 7PM"",
            () => console.log(""Note delivered.""));

就可以变成

request(bigOak, ""Cow Pasture"", ""note"", ""Let's caw loudly at 7PM"")
    .then(()=>console.log(""Note delivered""))
    .catch(() => console.log(""Failed!""))


这样就把callback转换成promise了 并且比较科学可以重试3次

（只不过不能演示运行resolve和reject，他的nest.send函数没有写好 failed）
你可以把send函数按底下修改 就能实现failed（0.3概率失败）

if (Math.random() > 0.03) setTimeout(() => {
        try {
          handler(toNode, ser(message), this.name, (error, response) => {
            if(Math.random()<0.3){
              error = true
            } else {
              error = false
            }
            setTimeout(() => callback(error, ser(response)), 10)  //模拟信息返回
          })
        } catch(e) {
          callback(e)
        }
      }, 10 + Math.floor(Math.random() * 10))
Highlight:first time
Sticky notes:这里说 promises只会被 resolve或者reject一次，如果有多次promises被请求（上面每0.25s），然后由于网络原因，可能有的先后被resolve/reject ，只有第一个resolve会被当作promises结果，其他之后的被忽略
Highlight:recursive
Sticky notes:为了完成多次请求，我们用的是递归结构而不是loop循环，
因为只有递归里面能有运行一次，等待0.25s，在进入下一次，这样等待

这里就是attempt(1) ->attempt(2) ->attempt(3)
Highlight:<p>Retrying every quarter-second and giving up when no response has come in after three-quarter second is definitely somewhat arbitrary. It is even possible, if the request did come through but the handler is just taking a bit longer, for requests to be delivered multiple times. We’ll write our handlers with that problem in mind—duplicate messages should be harmless.</p>

<p><a class=""p_ident"" id=""p_e9iIV/0dqZ"" href=""#p_e9iIV/0dqZ"" tabindex=""-1"" role=""presentation""></a>In general, we will not be building a world-class, robust network today. But that’s okay—crows don’t have very high expectations yet when it comes to computing.</p>
Sticky notes:这两段跟上面蓝色标记意思一样

就是说我们每0.25s就重新请求一次，也许是服务器端请求通过了但是花了一点事件处理，多次请求有点武断，但是这个是无害的，并且乌鸦的计算机网络不需要太健壮
Highlight:callbacks
Sticky notes:为了完全不使用callback回调函数，我们把defineRequesttype也封装一遍，用promises取代
底下有三个小细节：

1、Promise.resolve 来将非promise 的值转换成promise，这就是把我们的handler函数转换成promise了

2、用了 try catch，原因是 callback 很难获取报错，并且返回到指定的处理函数里去，而promise更加智能且少出错。

3、注意这里将callback形式转化成promise done这个参数就无效了（因为以前是执行完服务器操作然后执行done回调函数来异步，现在是promise，应该在服务器操作中return，然后在request后面加上.then（动手实验下面））

requestType(""note"",(nest, content, source, done) => {   
    console.log(`${nest.name} received note: ${content}`)
    return nest.name
})

request(bigOak, ""Cow Pasture"", ""note"", ""Let's caw loudly at 7PM"")
    .then((value)=>console.log(value))
    .catch(() => console.log(""Failed!""))

然后下面 最下面 then 就可以获取 return的nest.name
完全改变了 done的callback形式
Highlight:ping
Sticky notes:为了检查两个乌鸦巢穴之间是否能通信，这里新建一个“ping”类型请求，

这个ping请求给邻居巢穴neighbors发送请求，然后看有哪些返回（是当前可用没有损坏的）

我去，就是计算机网络里面的ping方法，来检查两台电脑是否通顺
Highlight:Promise.all
Sticky notes:因为要给所有neighbors发送请求，有很多promises，可以用promise.all来抱狗包裹所有的promises

然后这个promise.all函数返回一个 promise，当所有的小promises结束了 resolve返回一个数组包含所有小的值 并且任何一个小promises reject  这个 all 的promise也会reject
Highlight:rejected ones produce <code>false</code>
Sticky notes:上面代码可能有点陌生（对我）
这个 request和 requestType 是上一个小结用promise封装的科学的函数，还有注意函数小细节

a、handler应该是：()=> console.log(""pong"")「也可能没有写错，服务端打印一下比较好」

b、并且注意这里then()函数里
() => true 是 () => {return true}的简写
也就是这里每个request的promise 有返回值 然后用了Promise.all 这些返回值 集中到 result数组

c、return nest.neighbors.filter((_, i) => result[i]);
这里Promise.all里面的return 并不能用到异步外面去，比如
let a = availableNeighbors(bigOak) 打印出来a，a是一个Promise，唯一的方法是在 a后面再跟一个then然后操作，
有篇知乎：https://www.zhihu.com/question/274196779/answer/375315187
像React/Taro的做法是 把then里的值 setState 可以
或者用后面说的 asyn/await解决

或者setTimeout 等待异步完成 就可以获取b的值了
let a = availableNeighbors(bigOak).then(value=> {b = value})
setTimeout(()=>console.log(b),1500)      //异步需要一定时间

下面来说这两段：
1、当一个邻居不能到达，我们不想整个都reject报错，所以我们定义 reject函数是 () => false，这样就不会导致整个reject，并且把结果保存到 Promise.all的result数组里（当你不定义catch()，任何一个reject都会导致 Promise.all reject）

2、然后用 filter函数 来去除是false 的邻居，并且用到 index 这个好理解 并且不是本章重点
Highlight:inhibits
Sticky notes:巢只能与邻居交谈的事实极大地限制了该网络的实用性。
为了向整个网络广播信息，一种解决方案是设置一种自动转发给邻居的请求。 然后，这些邻居依次将其转发给他们的邻居，直到整个网络都收到了该消息。
Highlight:everywhere
Sticky notes:上面代码应该好理解，特别的：
1、这个广播信息，防止相同的信息重复传播，每一个nest都有一个数组，来保存已经收到的信息，这里定义everywhere函数，参数是一个函数，调用这个每个nest都执行这个参数函数（这里是清空每个nest的gossip）

2、当接收到重复信息（nest.state.gossip.includes(message)）会忽略，当新的消息，调用sendGossip函数，1、给自己的gossip数组加上信息，2、给每个邻居发送这条信息

3、这样广播每个节点都会收到这个信息，叫做洪流（广播）
Highlight:flooding again
Sticky notes:前面洪流的方法可行，但是当网络特别大的时候，效率特别低，更好的方法是寻找一条最好的路径

寻找路径需要知道整个网络的节点信息，为了知道全部的图信息，就有了下面的代码

也是利用洪流，但是这次洪流不是检查是否有相同的信息，而是检查##给定嵌套的新邻居集是否与我们拥有的当前邻居集匹配。##
就是判断：
JSON.stringify(connections.get(name)) ==
      JSON.stringify(neighbors)

（我们的图，是所有的节点和邻居，http://a1.qpic.cn/psc?/V53MyxRX401CAY1CP1Wn3uyyFc10kiPp/ruAMsa53pVQWN7FLK88i5m3jqmLS4psBljg*6BVoictGW..KI*hPFR.u.UAdZNkNH1xAcVDOHazSnSEa.8GaZy6QZWWKDsqog.gOnWrtfW4!/b&ek=1&kp=1&pt=0&bo=UgI6AQAAAAADF1k!&tl=1&vuin=1186179435&tm=1596866400&sce=60-2-2&rf=viewer_4）
Highlight:JSON.stringify
Sticky notes:1、这里用JSON.stringify 
因为用 == 比较connectioins.get(name)和neighbors
必须要两者完全相等（这里一个是Map，一个是对象，有些Map内置方法不可能对象上相等，就转换成JSON strings 更有效）

2、上面的 “connections”请求就迅速扩散广播到所有的节点，保证每个节点的信息 保存到 nest.state.connections

最后成为：http://a1.qpic.cn/psc?/V53MyxRX401CAY1CP1Wn3uyyFc10kiPp/ruAMsa53pVQWN7FLK88i5m3jqmLS4psBljg*6BVoictGW..KI*hPFR.u.UAdZNkNH1xAcVDOHazSnSEa.8GaZy6QZWWKDsqog.gOnWrtfW4!/b&ek=1&kp=1&pt=0&bo=UgI6AQAAAAADF1k!&tl=1&vuin=1186179435&tm=1596866400&sce=60-2-2&rf=viewer_4
Highlight:A thing you can do with graphs is find routes in them, as we saw in <a href=""07_robot.html"">Chapter 7</a>.
Sticky notes:寻找网络所有节点信息
——————————————
findRoute方法
Highlight:<code>findRoute<span class=""diigoHighlightCommentLocator""></span></code> from <a href=""07_robot.html#findRoute"">Chapter 7</a>
Sticky notes:第七章的findRoute函数：

function findRoute(graph, from, to) {
    let work = [{at: from, route: []}];
    for (let i = 0; i < work.length; i++) {
        let {at, route} = work[i];
        for (let place of graph[at]) {
            if (place === to) return route.concat(place);
            if (!work.some(w => w.at == place)) {
                work.push({at: place, route: route.concat(place)});
            }
        }
    }
}
Highlight:next step
Sticky notes:两个函数原理可以说一摸一样（只不过connect是Map，graph是对象数组）。
不过这里有不同的是：
if (next == to) return via;
对比
if (place === to) return route.concat(place);

原来是返回一个点到另一个点的所有路径
而这里是返回当前位置到到另一点的下一个位置

然后当前节点根据网络情况看能不能给下一个节点发送信息
Highlight:closer
Sticky notes:然后下面代码就利用findRoute找到目标节点的合理路径

1、如果是邻居，不用findRoute，直接发送
2、否则用findRoute算法，一点点 到via参数节点去


然后requsetType方法里 的handler 就是routeRequest函数
其实就是 send的时候 不断调用routeRequest的hanlder传递给邻居寻路
Highlight:network
Sticky notes:谷歌翻译（类似总结感慨，这就是计算机网络不同计算机通信的基本原理）：
为了方便使用，我们在原始通信系统上构建了几层功能。 这是一个很好的（尽管简化了）真实计算机网络如何工作的模型。

计算机网络的一个显着特征是它们不可靠-建立在它们之上的抽象可以提供帮助，但是您不能抽象出网络故障。 因此，网络编程通常非常关注预测和处理故障。
Highlight:consult random
Sticky notes:为了保存重要的信息，会在很多不同计算机存储

当要获取一个自己内存没有的信息的时候，一台计算机随机向其他网络的计算机寻求 知道找到想要的
Highlight:pseudo-synchronous
Sticky notes:上面的请求请求方法是
function findeInStorage => function findInRemoteStorage

这个findInRemoteStirage看起来比较奇怪，因为有多个异步操作绑定在一起（先试一个随机的节点，不行再试下一个节点next()），还用到了递归来模拟循环（因为异步里面不能用loop，异步的代码是定义未来的操作，只能迭代）

但是我们的操作是完全线性的，只是一个个等待下一个操作，用同步程序也许更好表达

于是有了 async 函数  在函数或者方法前面加上 async字段，在函数/方法内部就可以用 await参数 来等待一个异步操作 这样达到伪同步的代码
Highlight:Array.from
Sticky notes:这里就是想获取所有的Map的索引（名称），比如图片下的
http://m.qpic.cn/psc?/V53MyxRX401CAY1CP1Wn3uyyFc10kiPp/ruAMsa53pVQWN7FLK88i5m3jqmLS4psBljg*6BVoictGW..KI*hPFR.u.UAdZNkNH1xAcVDOHazSnSEa.8GaZy6QZWWKDsqog.gOnWrtfW4!/b&bo=UgI6AQAAAAADB0k!&rf=viewer_4

woods、Fabiene's Garden、Big Maple等等

本来有Object.keys()方法可以完成这样提取keys，但是对Map不能用，就就用Map.keys() 方法这个是返回一个迭代器iiterator，再用Array.from方法可以获取keys的数组，就得到了所有节点的名字
Highlight:asyn<span class=""diigoHighlightCommentLocator""></span>c
Sticky notes:注意这个findInStorage还需要用到上节用的findRoute函数，并且必须定义 “route”类型的 requestType，就是没有看到这个“route”搞了半天出错

然后就解释啦，下面四段：
1、函数/方法前面可以加一个async参数，然后这个函数/方法调用的时候返回一个promise，当函数体return就resolve，当throw error 就rejet

2、在async函数/方法内部，可以在表达式前面加await 来等待后面的promise执行，然后继续执行下面的

3、这样的async函数 就不会是从头到尾执行下去，而是到await的时候 冻结 一段时间等待异步

4、对于非平凡的异步代码，此表示法通常比直接使用promise更方便。 即使您需要做一些不适合同步模型的事情，例如同时执行多个动作，也可以很容易地将await与直接使用promise结合起来。
（就像这种异步等待下一个异步的就是不平凡的，promise更加方便与promise且结构清晰）
Highlight:function*
Sticky notes:这种在函数里冻结暂停的方法不仅仅在 async里面有，在生成器函数里面也有

第六章我们见过 function*开头的是生成器函数
Highlight:When you call a generator, it returns an iterator
Sticky notes:生成器是函数，迭代器是生成器函数返回值：
我觉得我的函数比他给的例子更清晰：
function* powers(n) {
  for (let current = n;; current *= n) {
    yield console.log(current)
  }
}

let a = powers(3)
a.next()
a.next()
a.next()

下面代码块的 let of 语法对迭代器也是可行的 但是可能把初学的你看晕
Highlight:generator
Sticky notes:用生成器函数写迭代器很方便

比如下面第六章联系的例子

再也不用专门为一个迭代器保存一个state，生成器函数自动生成了

生成器函数的state作用域只在生成器函数里，就连在生成器函数里面的一个inner 函数都 没有state作用域

为什么突然扯到生成器函数？
因为async就是一种特殊的生成器函数，async函数会返回一个promise，当函数题return时resolve，然后thrwo error的时候 reject，无论何时合适await另外一个promise，那个promise的resolve或reject结果都是await表达式的结果
Highlight:callbacks
Sticky notes:这里说异步函数的调用栈和时间循环

1、异步程序是逐段执行的。 每个动作都可以启动一些动作，并计划动作完成或失败时要执行的代码。 在这两个片段之间，程序处于空闲状态，等待下一个动作。

2、所以回调函数不会被被定义回调函数的函数控制，如果定义好了 setTimeout 整个函数体都会执行到底部，然后时间到了就会折回来执行setTimeout的回调

3、异步行为发生在自己的空函数调用栈里，所以没有promise控制异步代码很困难，因为回调函数用一个大多空的栈，catch不能catch到回到函数里的错误（下面代码）
Highlight:This example
Sticky notes:上面一段应该讨论了 JS 的event loop 机制，谷歌翻译比较好，我总结可能出错：
不管超时或传入请求之类的事件多么紧密地结合在一起，JavaScript环境一次只能运行一个程序。 您可以认为这是因为它在程序周围运行了一个大循环，称为事件循环。 当无事可做时，该循环将停止。 但是随着事件的到来，它们被添加到队列中，并且它们的代码一个接一个地执行。 因为没有两件事同时运行，所以运行缓慢的代码可能会延迟其他事件的处理。

（我也不太懂，可以深究有缘人补充出来，也可以有个概念）

然后举了一个“运行缓慢的代码可能会延迟其他事件的处理。” 的代码例子
Highlight:timeout to be late
Sticky notes:这段代码又让你一脸懵逼，听我的分两次执行

1、
let start = Date.now();
setTimeout(() => {
  console.log(""Timeout ran at"", Date.now() - start);
}, 20);
while (Date.now() < start + 50) {}

2、
console.log(""Wasted time until"", Date.now() - start);

然后你就懂了，本来原来1是定时20ms的但是由于event loop，一次只能执行一个动作，导致20ms的变成了57ms

而2底下没有 while所以没有影响

连着跑他代码就傻了，分开
Highlight:Promises
Sticky notes:但是Promise就不会有这个问题，

谷歌翻译：
Promise始终会作为新事件解决或拒绝。 即使已解决了承诺，等待它也会导致您的回调在当前脚本完成后运行，而不是立即执行。
Highlight:gaps
Sticky notes:谷歌翻译：

当您的程序一次同步运行时，除了程序本身所做的更改之外，不会发生任何状态更改。 对于异步程序，这是不同的-在执行其他代码的过程中，它们的执行可能会有间隙。

让我们来看一个例子。 我们乌鸦的爱好之一是计算每年在整个村庄孵化的小鸡数量。 巢将这些计数存储在它们的存储灯泡中。 以下代码尝试枚举给定年份中所有巢的计数：
Highlight:async
Sticky notes:await Promise.all(network(nest).map(async name => 

上面看出来 箭头函数也可以用 async

上面代码看起来好理解，看起来没问题，就是每次请求一个巢穴的“storage”，await等待返回后 存储到 list里面
Highlight:+=
Sticky notes:这个就是异步编程的问题，出错点有两个

1、
list += `${name}: ${
      await anyStorage(nest, name, `chicks in ${year}`)
    }\n`

这个 list +=操作 原来操作是 list = list + (await...)
因为 await是异步的 你需要等待这个完成，但是这个list = list + (await)操作 这个 相加然后赋值给list的操作比等待await先执行，就不能等待await结果

2、然后下面这个错误结合
Promise.all(network(nest).map(async name => {
map操作 比函数体底下的  list +=操作前（由于1，await的结果不能加到list里去），最后的结果是
list =  '' + '' + '' + '' + '' + '' + ... + 最后一个结果

1和2就导致了 list不能由空字符串‘’ 相加得到结果，问题关键是 list += 操作，这个操作是 改变原来的绑定 list 但是异步操作会造成空隙有阻隔
Highlight:avoided
Sticky notes:解决方法：
用join函数 将 Promise.all的所有参数 变成一个字符串返回，而不是通过改变绑定，看底下好理解

关键点是：计算新的值比改变已经存在的值更不容易出错
Highlight:gaps
Sticky notes:这样的错误很容易造成，特别是在使用await时，您应该意识到代码中的空白出现在哪里。 JavaScript的显式异步性（无论是通过回调，承诺还是等待）的一个优点是发现这些差距相对容易。
Highlight:Asynchronous programming
Sticky notes:1、异步编程 可以让我们程序 不用等待长时间操作 继续执行操作

2、js环境里 典型的操作是 用回调

3、event loop 有一小节讲了这个概念 每个异步操作也安排在程序向下执行 就要考虑 异步带来的问题（BUGS）

4、promise可以方便写异步代码

5、可以用 async函数结合await 达到伪同步的效果
","2020-08-03 08:41:50"
"Project: A Pixel Art Editor :: Eloquent JavaScript","https://eloquentjavascript.net/19_paint.html","no_tag","","","Highlight:You can use the program to open image files, scribble on them with your mouse or other pointer device, and save them.
Sticky notes:利用之前学的，做一个可以导入，修改，保存图片的小应用
Highlight:Components
Sticky notes:卧槽，下面一堆就是将 一些 state啊 组件啊 接口啊，一大堆说半天，越看越绕，不知道他的核心思想，好像他特别想跟我们说明白什么 但是又很抽象

送上 中文版eloquent JS本节翻译：
http://m.qpic.cn/psc?/V11eVEA03x8oJX/ruAMsa53pVQWN7FLK88i5i46Z6Yz17pJFxoN6mg0advS9TyJISJ*EGNHXeuLcj0lk37qaGbXjLptcohoDvGIJ2Un4BRGgDSkMhq6Tkhf8RY!/b&bo=OASgBQAAAAABB7k!&rf=viewer_4
Highlight:&lt;select&gt;
Sticky notes:我们的界面就是上面样子：
最上面是canvas我们的图片

下面是一堆工具，Tool栏是一个<select>标签
三种工具：
1、绘制矩形
2、填充颜色
3、取色工具
Highlight:We will structure the editor
Sticky notes:下面一大堆无语了 不知道如何总结，希望有缘人能够补充总结下面（结合 中文的）
Highlight:empty
Highlight:drawing
Sticky notes:一个Picture 类
有多种方法
1、draw方法可以改变很多像素，让某个像素（像数组一行一行存储）的颜色改变
用 this.pixels.slice() 方法来创建一个一样的备份（深拷贝）

2、empty方法，返回一个数组，所有元素相同，长度给定，注意用法：
new Array(width * height).fill(color);
给定长度width * height   .fill方法   所有元素相同

3、pixels方法，返回某个像素的颜色

4、CSS的RGB不用多说把
Highlight:We’ll allow the interface to dispatch actions as objects whose properties
Sticky notes:class Picture
————————————
function updateState(state, action)
Highlight:Object.assign
Sticky notes:这个updateStaet方法，传入新的 state和action，然后构建一个新的对象

Object.assign方法用于深拷贝，
把 state和 action  拷贝到{}    其中action和state重复的会被重写，就相当于两个合在一起

也可以写{...state, ...action} 但是有可能不兼容
Highlight:The main difference between this version and the one we used in <a href=""16_game.html#domdisplay"">Chapter 16</a> is
Sticky notes:elt函数 16章做小游戏也见到过，区别是这里第二个参数
attrs         =》     props
在<div>上增加 attrs : class = “pink”     变成⬇️
在<button>（document.createElement返回对象） 上增加properties {onclick: ()=>{console.log(""123"")}}

三步骤：
1、let dom = document.createElement(type);
创建节点<button>啥的（函数返回是对象）

2、if (props) Object.assign(dom, props);
为节点添加属性（onClick()）

3、for (let child of children) {
    if (typeof child != ""string"") dom.appendChild(child);
    else dom.appendChild(document.createTextNode(child));
  }
把children参数里的添加到dom后面
（这里剩余参数...children 意思是可以传入很多child）
Highlight:This component
Sticky notes:上面的class Picture用来 加载图像 保存图像什么的
然后这里class PictureCanvas就是在编辑器界面上用canva把图像画出来

两个功能：
1、展示图片
2、和鼠标点击或者触摸屏触摸事件交互

这个PictureCanvas没有直接改变图像的功能（state），只是单纯展示图片，修改图片内容在点击或者触摸事件里调用回调函数
Highlight:syncState
Sticky notes:syncState  来同步更新图片，当图片不同的时候（this.picture!=picture）才会调用（比如你用白色在白色背景画了一下不会调用，提高效率）

syncState里再具体一个drawPicture函数
1、scale参数，跟游戏章节一样逻辑一个点画成像素乘以scale
2、我们是基于像素的，所以图片从左到右从上到下都是一排一排的像素格子，所以要两个遍历画出来，每个点都是格子
Highlight:left mouse button
Sticky notes:注意这里事件的逻辑：
canvas里加了onmousedown属性，是为cnavas增加一个onmousedown事件，在这个鼠标点下去事件调用的函数里面

又添加一个mousemove事件，当鼠标点下去又移动了，触发mousemove的事件函数move

注意这里
上：  let onMove = onDown(pos);
else语句里：     onMove(newPos);
注意这个onDown函数，比如是：function draw，它的函数体最后
drawPixel(pos, state);
  return drawPixel;

也就是说
let onMove = onDown(pos); 这里调用了一遍draw函数，就是鼠标点下去的时候必定调用draw函数在canvas上画一个点

然后之后绑定mousemove事件，当你的鼠标按下去并且拖着在画面上会不停的调用onMove函数，不断画点

这个mouse方法实际上有两个操作，结合代码理解
Highlight:pointerDown
Sticky notes:这里看代码它的调用情况更容易理解
1、定义PictureCanvas，这里构造函数 pointerDown传入
class PictureCanvas {
  constructor(picture, pointerDown) {
    this.dom = elt(""canvas"", {
      onmousedown: event => this.mouse(event, pointerDown),
      ontouchstart: event => this.touch(event, pointerDown)
    });

2、实例化PictureCanvas，发现pointerDown函数是箭头函数
this.canvas = new PictureCanvas(state.picture, pos => {
                let tool = tools[this.state.tool]
                let onMove = tool(pos, this.state, dispatch)
                if (onMove) return pos => onMove(pos, this.state)
            })

3、调用pointerDown，进入this.mouse,名字改为onDown函数，调用
let onMove = onDown(pos); ，返回值也是一个函数是一个参数是pos，函数体是tool函数得到的函数（function drwa的返回值）
let onMove = tool(pos, this.state, dispatch)
if (onMove) return pos => onMove(pos, this.state)

比如tool = function draw() 调用onDown得到的函数是：
onMove = pos => drawPixels(pos, this.state)

哎哟说不清呀 最好去看看代码
Highlight:getBoundingClientRect
Sticky notes:这个pointerPosition函数，参数pos是“mousemove”事件发生时的参数event，参数this.dom是PictureCanvas的<canvas>，
用来获取鼠标的相对canvas的坐标，理解图如下
http://m.qpic.cn/psc?/V11eVEA03x8oJX/ruAMsa53pVQWN7FLK88i5oB7jaejaiyEbp7v2AB66Dfc4O9q.d9agubCivwpmWrqm.ipqOYODHSRyJ4MNGxt1*WXs*JMPESscCviiqr04nE!/b&bo=mwXPAgAAAAABB3M!&rf=viewer_4
Highlight:touchstart
Sticky notes:touch方法和mouse大同小异，就是在平板上的触摸方法，注意：

1、startEvent.preventDefault()，在事件的参数event里调用preventDefault来防止触摸的默认事件（长按复制啥的）

2、touchend事件可能复杂一点
let end = () => {
    this.dom.removeEventListener(""touchmove"", move);
    this.dom.removeEventListener(""touchend"", end);
  };

this.dom.addEventListener(""touchmove"", move);
this.dom.addEventListener(""touchend"", end);

3、触摸下去的坐标不直接在moveEvent里，但是可以在moveEvent.touches[0]里获取
Highlight:application
Sticky notes:接下来一点点构建应用

主题是一个大图片canvas和一些系列工具和控件（工具是控件之一toolSelect的具体）
Highlight:<em>tools</em>
Sticky notes:const baseControls = [
        ToolSelect, ColorSelect, SaveButton, LoadButton, UndoButton
    ]

const baseTools = {draw, fill, rectangle, pick}

控件Controls是底下一排，工具Tools是传入到ToolSelect组件的函数，
这些函数参数是（pos, state, dispatch），
这些函数也可能返回一个mousemove事件就是鼠标点下去拖着移动的时候持续调用这个Tool函数（上面详细说了）
Highlight:PictureCanvas
Sticky notes:PictureCanvas类实例化的时候传入的pointerDown事件（传入到构造函数里的mousedown事件），作用就是每次选择<select>的时候及时更新鼠标点下去会调用的函数

let tool = tools[this.state.tool];
      let onMove = tool(pos, this.state, dispatch);
      if (onMove) return pos => onMove(pos, this.state);
Highlight:The call to <code>reduce</code> introduces spaces between the controls’ DOM elements.
Sticky notes:this.dom = elt(""div"", {}, this.canvas.dom, elt(""br""),
                   ...this.controls.reduce(
                     (a, c) => a.concat("" "", c.dom), []));

其实就是构造底下这种结构，一个大的<div>然后传入很多平级的子元素
http://m.qpic.cn/psc?/V53MyxRX401CAY1CP1Wn3uyyFc10kiPp/ruAMsa53pVQWN7FLK88i5lHsjVXJzW*Jg8abVDAkbi0TeHtsvoNf85WX3qso1OD5U4byiA2mZJ9ESnBpuTGRf3CeCLRgnIcAqTCZMAOJmTA!/mnull&bo=PgGeAAAAAAADB4M!&rf=photolist&t=5

reduce方法是把所有的元素执行一个操作，然后保存到一个结果里，可以去了解，this.controls.reduce()得到的数组是：
http://a1.qpic.cn/psc?/V53MyxRX401CAY1CP1Wn3uyyFc10kiPp/ruAMsa53pVQWN7FLK88i5i46Z6Yz17pJFxoN6mg0advPoGXlzF12w3n*Kz9YMaBHjybXddWvb99bbC3lZAlnQ0FZQSxvokkCWH8wTAcQpMU!/b&ek=1&kp=1&pt=0&bo=SgLYAAAAAAADF6I!&tl=1&vuin=1186179435&tm=1596196800&sce=60-2-2&rf=viewer_4

这里reduce得到的数组有一些“ ”，其实没有影响到elt函数里，appendChild("" "") 不会发生改变
Highlight:change
Sticky notes:这里绑定onChange函数，是为了更改大的state里的状态就是
const startState = {
        tool: ""draw"",
        color: ""#000000"",
        picture: Picture.empty(60, 30, ""#f0f0f0""),
        done: [],
        doneAt: 0
    }
变成
const startState = {
        tool: ""fill"",
        color: ""#000000"",
        picture: Picture.empty(60, 30, ""#f0f0f0""),
        done: [],
        doneAt: 0
    }

因为pointerDown函数里面也是根据state.tool改变的：
let tool = tools[this.state.tool];
Highlight:&lt;input&gt;
Sticky notes:<input type=""color""> 来构建一个颜色选择器

注意这里把选择器的颜色传递给state和syncState函数：
onchange: () => dispatch({color: this.input.value})
syncState(state) { this.input.value = state.color; }
Highlight:draw
Sticky notes:1、最常见draw方法，就是获取坐标和颜色，然后改变state.picture.draw([drawn])，
在调用更新方法dispatch  来实现一个canvas某个像素点颜色改变

2、注意这个draw函数，执行的时候，立即执行drawPixel函数，然后return drawPixel函数用于鼠标点下去调用一遍，然后按住鼠标移动的时候再不断调用
Highlight:To draw larger shapes, it can be useful to quickly create rectangles. The
Sticky notes:function draw()
——————————————
function rectangle()
Highlight:picture from the <em>original</em> state
Sticky notes:1、注意这个rectangle函数，是根据一个start参数和pos参数绘制矩形
这个start 是事件 mousedown触发的时候传入
这个pos 是事件 mousemove触发的时候传入
所以可以不断的改正，实现动态拉取矩形

2、这里只要你鼠标没有放开，你就可以不断调整矩形的大小，这是因为我们只是更改了 state.picture.draw(drawn)

这是 immutable picture objects的好处？？ 有点不太懂，可能说是：
picture实例是不可改变的，但是可以调用他的draw方法来改变 
Highlight:Implementing flood fill is somewhat more involved. This is a tool that fills the
Sticky notes:function rectangle()
——————————————
funciton fill()
Highlight:doubles as the function’s work
Sticky notes:1、let drawn = [{x, y, color: state.color}];
是第一个鼠标点下去的点，最初drawn是有一个元素的数组，drawn数组会不断增加，因为会执行下面的循环（不用担心drawn.length一开始等于1，因为drawn增加之后length会增加）

2、然后底下循环也好理解：
for (let {dx, dy} of around) {
      let x = drawn[done].x + dx, y = drawn[done].y + dy;
      if (x >= 0 && x < state.picture.width &&
          y >= 0 && y < state.picture.height &&
          state.picture.pixel(x, y) == targetColor &&
          !drawn.some(p => p.x == x && p.y == y)) {
        drawn.push({x, y, color: state.color});
      }
    }
就是找一个起始点，找这个点的上下左右有没有相同这个点颜色的，有就加到drawn数组里面去，同样去掉重复的坐标的，
最后遍历完 就是fill需要填充的被包围的空间
（应该好理解哈 类似Ch7的寻路算法，不过更通俗易懂）
Highlight:The final tool is a color picker, which allows you to point at a color in the
Sticky notes:funciton fill()
——————————————
function pick()
Highlight:toDataURL
Sticky notes:这个saveButton的逻辑看类的定义应该挺清楚的，
注意这里创建<a>节点 来保存图片 使用到 canvas.toDateURL() ， 不是普通的http或https的URL，是很奇怪一大串 能保存图片信息的URL，浏览器可以识别并下载

比如下面console.log出来的这种：

data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAABLAAAAJYCAYAAABy5h8aAAAgAElEQVR4Xu3aUZLkRq4EQO0NdP9Tzg3eM1vT6qdb6iELmRkJ+H5Xk0gPFKcYq//8+vXr//7wPwIECBAgQIAAAQIECBAgQIAAAQKhAv9RYIUmYywCBAgQIECAAAECBAgQIECAAIH/CiiwLAIBAgQIECBAgAABAgQIECBAgEC0gAIrOh7DESBAgAABAgQIECBAgAABAgQIKLDsAAECBAgQIECAAAECBAgQIECAQLSAAis6HsMRIECAAAECBAgQIECAAAECBAgosOwAAQIECBAgQIAAAQIECBAgQIBAtIACKzoewxEgQIAAAQIECBAgQIAAAQIECCiw7AABAgQIECBAgAABAgQIECBAgEC0gAIrOh7DESBAgAABAgQIECBAgAABAgQIKLDsAAECBAgQIECAAAECBAgQIECAQLSAAis6HsMRIECAAAECBAgQIECAAAECBAgosOwAAQIECBAgQIAAAQIECBAgQIBAtIACKzoewxEgQIAAAQIECBAgQIAAAQIECCiw7AABAgQIECBAgAABAgQIECBAgEC0gAIrOh7DESBAgAABAgQIECBAgAABAgQIKLDsAAECBAgQIECAAAECBAgQIECAQLSAAis6HsMRIECAAAECBAgQIECAAAECBAgosOwAAQIECBAgQIAAAQIECBAgQIBAtIACKzoewxEgQIAAAQIECBAgQIAAAQIECCiw7AABAgQIECBAgAABAgQIECBAgEC0gAIrOh7DESBAgAABAgQIECBAgAABAgQIKLDsAAECBAgQIECAAAECBAgQIECAQLSAAis6HsMRIECAAAECBAgQIECAAAECBAgosOwAAQIECBAgQIAAAQIECBAgQIBAtIACKzoewxEgQIAAAQIECBAgQIAAAQIECCiw7AABAgQIECBAgAABAgQIECBAgEC0gAIrOh7DESBAgAABAgQIECBAgAABAgQIKLDsAAECBAgQIECAAAECBAgQIECAQLSAAis6HsMRIECAAAECBAgQIECAAAECBAgosOwAAQIECBAgQIAAAQIECBAgQIBAtIACKzoewxEgQIAAAQIECBAgQIAAAQIECCiw7AABAgQIECBAgAABAgQIECBAgEC0gAIrOh7DESBAgAABAgQIECBAgAABAgQIKLDsAAECBAgQIECAAAECBAgQIECAQLSAAis6HsMRIECAAAECBAgQIECAAAECBAgosOwAAQIECBAgQIAAAQIECBAgQIBAtIACKzoewxEgQIAAAQIECBAgQIAAAQIECCiw7AABAgQIECBAgAABAgQIECBAgEC0gAIrOh7DESBAgAABAgQIECBAgAABAgQIKLDsAAECBAgQIECAAAECBAgQIECAQLSAAis6HsMRIECAAAECBAgQIECAAAECBAgosOwAAQIECBAgQIAAAQIECBAgQIBAtIACKzoewxEgQIAAAQIECBAgQIAAAQIECCiw7AABAgQIECBAgAABAgQIECBAgEC0gAIrOh7DESBAgAABAgQIECBAgAABAgQIKLDsAAECBAgQIECAAAECBAgQIECAQLSAAis6HsMRIECAAAECBAgQIECAAAECBAgosOwAAQIECBAgQIAAAQIECBAgQIBAtIACKzoewxEgQIAAAQIECBAgQIAAAQIECCiw7AABAgQIECBAgAABAgQIECBAgEC0gAIrOh7DESBAgAABAgQIECBAgAABAgQIKLDsAAECBAgQIECAAAECBAgQIECAQLSAAis6HsMRIECAAAECBAgQIECAAAECBAgosOwAAQIECBAgQIAAAQIECBAgQIBAtIACKzoewxEgQIAAAQIECBAgQIAAAQIECCiw7AABAgQIECBAgAABAgQIECBAgEC0gAIrOh7DESBAgAABAgQIECBAgAABAgQIKLDsAAECBAgQIECAAAECBAgQIECAQLSAAis6HsMRIECAAAECBAgQIECAAAECBAgosOwAAQIECBAgQIAAAQIECBAgQIBAtIACKzoewxEgQIAAAQIECBAgQIAAAQIECCiw7AABAgQIECBAgAABAgQIECBAgEC0gAIrOh7DESBAgAABAgQIECBAgAABAgQIKLDsAAECBAgQIECAAAECBAgQIECAQLSAAis6HsMRIECAAAECBAgQIECAAAECBAgosOwAAQIECBAgQIAAAQIECBAgQIBAtIACKzoewxEgQIAAAQIECBAgQIAAAQIECCiw7AABAgQIECBAgAABAgQIECBAgEC0gAIrOh7DESBAgAABAgQIECBAgAABAgQIKLDsAAECBAgQIECAAAECBAgQIECAQLSAAis6HsMRIECAAAECBAgQIECAAAECBAgosOwAAQIECBAgQIAAAQIECBAgQIBAtIACKzoewxEgQIAAAQIECBAgQIAAAQIECCiw7AABAgQIECBAgAABAgQIECBAgEC0gAIrOh7DESBAgAABAgQIECBAgAABAgQIKLDsAAECBAgQIECAAAECBAgQIECAQLSAAis6HsMRIECAAAECBAgQIECAAAECBAgosOwAAQIECBAgQIAAAQIECBAgQIBAtIACKzoewxEgQIAAAQIECBAgQIAAAQIECCiw7AABAgQIECBAgAABAgQIECBAgEC0gAIrOh7DESBAgAABAgQIECBAgAABAgQIKLDsAAECBAgQIECAAAECBAgQIECAQLSAAis6HsMRIECAAAECBAgQIECAAAECBAgosOwAAQIECBAgQIAAAQIECBAgQIBAtIACKzoewxEgQIAAAQIECBAgQIAAAQIECCiw7AABAgQIECBAgAABAgQIECBAgEC0gAIrOh7DESBAgAABAgQIECBAgAABAgQIKLDsAAECBAgQIECAAAECBAgQIECAQLSAAis6HsMRIECAAAECBAgQIECAAAECBAgosOwAAQIECBAgQIAAAQIECBAgQIBAtIACKzoewxEgQIAAAQIECBAgQIAAAQIECCiw7AABAgQIECBAgAABAgQIECBAgEC0gAIrOh7DESBAgAABAgQIECBAgAABAgQIKLDsAAECBAgQIECAAAECBAgQIECAQLSAAis6HsMRIECAAAECBAgQIECAAAECBAgosOwAAQIECBAgQIAAAQIECBAgQIBAtIACKzoewxEgQIAAAQIECBAgQIAAAQIECCiw7AABAgQIECBAgAABAgQIECBAgEC0gAIrOh7DESBAgAABAgQIECBAgAABAgQIKLDsAAECBAgQIECAAAECBAgQIECAQLSAAis6HsMRIECAAAECBAgQIECAAAECBAgosOwAAQIECBAgQIAAAQIECBAgQIBAtIACKzoewxEgQIAAAQIECBAgQIAAAQIECCiw7AABAgQIECBAgAABAgQIECBAgEC0gAIrOh7DESBAgAABAgQIECBAgAABAgQIKLDsAAECBAgQIECAAAECBAgQIECAQLSAAis6HsMRIECAAAECBAgQIECAAAECBAgosOwAAQIECBAgQIAAAQIECBAgQIBAtIACKzoewxEgQIAAAQIECBAgQIAAAQIECCiw7AABAgQIECBAgAABAgQIECBAgEC0gAIrOh7DESBAgAABAgQIECBAgAABAgQIKLDsAAECBAgQIECAAAECBAgQIECAQLSAAis6HsMRIECAAAECBAgQIECAAAECBAgosOwAAQIECBAgQIAAAQIECBAgQIBAtIACKzoewxEgQIAAAQIECBAgQIAAAQIECCiw7AABAgQIECBAgAABAgQIECBAgEC0gAIrOh7DESBAgAABAgQIECBAgAABAgQIKLDsAAECBAgQIECAAAECBAgQIECAQLSAAis6HsMRIECAAAECBAgQIECAAAECBAgosOwAAQIECBAgQIAAAQIECBAgQIBAtIACKzoewxEgQIAAAQIECBAgQIAAAQIECCiw7AABAgQIECBAgAABAgQIECBAgEC0gAIrOh7DESBAgAABAgQIECBAgAABAgQIKLDsAAECBAgQIECAAAECBAgQIECAQLSAAis6HsMRIECAAAECBAgQIECAAAECBAgosOwAAQIECBAgQIAAAQIECBAgQIBAtIACKzoewxEgQIAAAQIECBAgQIAAAQIECCiw7AABAgQIECBAgAABAgQIECBAgEC0gAIrOh7DESBAgAABAgQIECBAgAABAgQIKLDsAAECBAgQIECAAAECBAgQIECAQLSAAis6HsMRIECAAAECBAgQIECAAAECBAgosOwAAQIECBAgQIAAAQIECBAgQIBAtIACKzoewxEgQIAAAQIECBAgQIAAAQIECCiw7AABAgQIECBAgAABAgQIECBAgEC0gAIrOh7DESBAgAABAgQIECBAgAABAgQIKLDsAAECBAgQIECAAAECBAgQIECAQLSAAis6HsMRIECAAAECBAgQIECAAAECBAgosOwAAQIECBAgQIAAAQIECBAgQIBAtIACKzoewxEgQIAAAQIECBAgQIAAAQIECCiw7AABAgQIECBAgAABAgQIECBAgEC0gAIrOh7DESBAgAABAgQIECBAgAABAgQIKLDsAAECBAgQIECAAAECBAgQIECAQLSAAis6HsMRIECAAAECBAgQIECAAAECBAgosOwAAQIECBAgQIAAAQIECBAgQIBAtIACKzoewxEgQIAAAQIECBAgQIAAAQIECCiw7AABAgQIECBAgAABAgQIECBAgEC0gAIrOh7DESBAgAABAgQIECBAgAABAgQIKLDsAAECBAgQIECAAAECBAgQIECAQLSAAis6HsMRIECAAAECBAgQIECAAAECBAgosOwAAQIECBAgQIAAAQIECBAgQIBAtIACKzoewxEgQIAAAQIECBAgQIAAAQIECCiw7AABAgQIECBAgAABAgQIECBAgEC0gAIrOh7DESBAgAABAgQIECBAgAABAgQIKLDsAAECBAgQIECAAAECBAg
Highlight:button component.
Sticky notes:这个LoadButton包含许多另外的函数，有点麻烦
LoadButton=》startLoad=》finishLoad=》pictureFromImage
Highlight:And it gets worse. We’ll also want to be able to load existing image files into our
Sticky notes:class SaveButton
——————————
class LoadButton
Highlight:FileReader
Sticky notes:整个过程挺麻烦的：
1、LoadButton组件
画一个<button> ，点击后调用2

2、startLoad函数，这里获取磁盘文件借用原生的<input type=""file""> 然后 input.click 并不在页面画出来<input>（因为比较丑） onchange 函数 传入文件的的参数 input.files[0]：

lastModified: 1596336510000
lastModifiedDate: Sun Aug 02 2020 10:48:30 GMT+0800 (中国标准时间) {}
name: ""路径 5.png""
size: 1366
type: ""image/png""
webkitRelativePath: """"
调用3

3、function finishLoad函数，用FileReader()类用来加载磁盘上的文件，调用reader.readAsDataURL可能需要一些时间，添加 “load事件”，完全加载后调用4

4、function pictureFromImage 获取一个<image>节点，创建一个临时的<canvas>，传入<image>，然后用一系列操作得到pixels数组，传入new Picture，渲染更新小程序 的canvas，达到加载的目的
Highlight:&lt;canvas&gt;
Sticky notes:let canvas = elt(""canvas"", {width, height});
这个<canvas>节点不是我们应用渲染出来的只是一个临时工具

cx.drawImage(image, 0, 0)将 finishLoad函数里的得到的<image> 节点写入canvas

cx.getImageData(0, 0, width, height) 调用这个，用来获取100*100 的像素数据 然后传入 pixels数组，
最后return new PIcture ，这里才是绘制在我们的应用上面画布上
Highlight:data
Sticky notes:1、data返回的是有颜色分量的数组，他是rgba格式，分别为【红，绿，蓝，不透明度】，通过循环获得每个像素的颜色

2、但是data返回的像素颜色是十进制的0～255
调用hex函数转换成16进制
padStart函数用来保证是两位，前面没有0的时候补位
Highlight:data
Sticky notes:1、获得的data属性格式是rgba格式，代表【红，绿，蓝，不透明度】，为了获取rgb 需要slice(i,i+3)

2、1中获取的rgb是 十进制，为了得到十六进制，调用hex函数，注意padStart函数，保持不足两位的时候填充0为两位十六进制数
Highlight:store previous versions of the picture.
Sticky notes:完成撤回按钮需要的三要素
存储之前的绘图
done数组
Highlight:update function
Sticky notes:更复杂的更新函数
function historyUpdateState
Highlight:doneAt
Sticky notes:不会每个小改动都存储，存储特定事件的
doneAt 数字
Highlight:undo action
Sticky notes:然后就是看上下两段函数了，应该好理解，注意点：
1、当state.done 为空数组 这个UNDO button 是disabled的不能点击

2、然后historyUpdateState函数，有三个判断
1、action.undo 调用undo 就撤回一章图片
2、Date.now() - 1000  > state.doneAt 判断修改的时间超过1秒 就存起来
3、其他情况 不改变，返回原来的state和action
Object.assign({}, state, action);
Highlight:create a state
Sticky notes:startPixelEditor，传入初始化参数

startState
baseTools
baseControls
Highlight:destructuring
Sticky notes:state = startState,
tools = baseTools,
controls = baseControls


默认参数
Highlight:Why is this so hard?
Sticky notes:推荐谷歌翻译：
浏览器技术是惊人的。它提供了一组强大的界面构建块，样式和操作它们的方法，以及用于检查和调试应用程序的工具。您为浏览器编写的软件可以在地球上几乎所有的计算机和电话上运行。

同时，浏览器技术是荒谬的。您必须学习大量愚蠢的技巧和晦涩难懂的事实才能掌握它，并且它提供的默认编程模型非常有问题，以至于大多数程序员更喜欢将其抽象为多个抽象层而不是直接对其进行处理。

尽管情况肯定在改善，但主要是通过添加更多元素来解决缺点，从而增加了复杂性。一百万个网站使用的功能无法真正取代。即使可以，也很难决定应将其替换为什么。

技术永远不会存在于真空中-我们受到工具以及生产工具的社会，经济和历史因素的束缚。这可能很烦人，但尝试对现有技术现实的工作方式（以及为什么如此）建立良好的理解通常比对它发怒或坚持另一种现实要有更多的收获。

新的抽象可能会有所帮助。我在本章中使用的组件模型和数据流约定是它们的粗略形式。如前所述，有些库试图使用户界面编程更加令人愉快。在撰写本文时，React和Angular是受欢迎的选择，但是整个框架行业都有这样的框架。如果您对网络应用程序编程感兴趣，建议您调查其中的一些应用程序，以了解它们的工作方式以及所提供的好处。
","2020-07-30 02:30:05"
"Project: A Robot :: Eloquent JavaScript","https://eloquentjavascript.net/07_robot.html","no_tag","","","Highlight:automaton
Sticky notes:前面教了很多理论，重要的是应用，这一节叫我们编一个机器人 模拟一个邮递包裹的任务
Highlight:convert
Sticky notes:上面的两点之间的连线roads字符串数组不好用，转换成
[一个点：这个点连接的点]  型对象

注意点：
let [from, to] of edges.map(r => r.split(""-""))
这个用法，将每个字符串分开，然后拆分处from和to

  ""Alice's House-Bob's House"" 
-》 
from = Alics's House 
to = Bob's House

let of 和 split语法一起用采用这种效果

console.log(roadGraph)
Highlight:object-oriented programming
Sticky notes:我们可能用面向对象编程方法，为机器人，包裹或者地点都设定一个类，每个类有特定的方法更新状态，这样不太好因为
 为应用程序中的每个概念反射性地编写类往往会给您留下一组互连的对象，每个对象都有自己的内部变化状态。 这样的程序通常很难理解，因此很容易破解。

下面用最小的值定义 一个村庄的state，混合有
this.place
this.parcels
用这个villageState表示机器人的当前位置和包裹，每个包裹有 [current location, destination address]
Highlight:don’t <em>change</em>
Sticky notes:因为这个类的特殊性
每次我们移动后不是改变State，而是重新返回一个VillageState
Highlight:move
Sticky notes:1、先查看从当前位置能不能到 目的地（是否在roadGraph对象里），不能就返回自己
Highlight:Then
Sticky notes:move方法，真的绕死了，看了半天debug

注意：
1、parcels是当前没有递送的包裹，就是机器人身上没有带的！！！，
实际上parcels里的p.place永远不能等于机器人位置this.place， 永远！

2、代码操作解读：
①if (p.place != this.place) return p;  检查包裹取件地址是不是机器人当前位置
②return {place: destination, address: p.address}; 包裹取件地址是机器人当前位置，机器人用手把包裹丢到下个目的地
③.filter(p => p.place != p.address); 检查是否有包裹当前位置等于目的地址（实际上只对丢到目的地包裹检查，只有它地址改变了），匹配的包裹删除
④return new VillageState(destination, parcels);
机器人走到目的地

3、这个操作是，一个机器人
走到在当前位置，准备要到目的地，先看待递送包裹里有没有当前位置的，没有就是还没到取件地址，有(p.place == this.place)则把当前地址的快递用手丢到目的地destination！！！，然后走到目的地
这个鬼操作就相当于机器人拿着包裹走到了目的地，实际上是神经病，把包裹丢到目的地，然后人走过去
还有一个插曲就是包裹丢到目的地之后检查所有的包裹 有没有 包裹地址等于包裹目的地的，有就相当于递送到了「实际上只可能是丢到destination的包裹是否恰好丢到了包裹的目的地（因为只有它地址改变了），
当一个包裹被丢，他会跟着机器人一直丢来丢去向前进，相当于携带包裹前进(p.place == this.place)」

3、不要用常规的递送思维去看这个代码，他是为了程序需要设计的代码 有点怪理解上
Highlight:Object.freeze
Sticky notes:number、string等对象不可改变

可以用Object.freeze方法 将对象变成immutable不可改变对象
但是计算机需要额外的工作或者容易让人疑惑为什么更新无效

最好的方法是告诉人们 这个对象不能改变
Highlight:Why am I going out of my way to not change objects when the language is obviously expecting me to?
Sticky notes:JS程序 希望对象可以改变 但是我却不希望 原因？
Highlight:understand my programs
Sticky notes:下面一大堆 看个人理解吧 绕来绕去
1、用不可改变的对象 可以更好的理解程序
2、我们小系统里面可以用一些额外的工作实现不变量帮助理解，让系统理解越简单越容易做大做强
3、理解用不变变量构建的程序很简单，但是构建很难，这一节用一些变量 用一些不变量

应该主要说编程思想吧
Highlight:robot
Sticky notes:底下英文能看懂，主要是一开始对结构有点懵逼，可以看我的xmind思维导图 各个函数之间的关系
Highlight:remember
Sticky notes:每次Robot函数执行 后 返回一个 direction移动的方向和 memory（这个randomRobot没有 下一节有）
Highlight:A static method
Sticky notes:是说这里看起来很奇怪

VillageState.random() 方法是定义静态方法，不需要实例化

VillageState.prototype.random() 这个方法才是成员函数 需要实例化
Highlight:We don’t want any parcels that are sent from the same place that they are addressed to. For this reason, the <code>do</code> loop keeps picking new places when it gets one that’s equal to the address.
Sticky notes:注意随机初始化包裹这句：
do {
      place = randomPick(Object.keys(roadGraph));
    } while (place == address);

这是一整段代码，不要像我一样，把下面parcels.push({place, address})看成一起的了

就是不能拿到地点是A目的地也是A的包裹，要用循环避免
Highlight:runRobotAnimation
Sticky notes:runRobot 方法可以把逻辑跑出来了

但是绘图 需要学习之后的DOM章节和canvas绘图章节

runRobotAnimation 方法逻辑同 Robot 只是能绘图
Highlight:If we find a route
Highlight:Pathfinding
Sticky notes:主要就是 findRoute() 和 goalOrientedRobot()   下面说一大堆话 人要崩溃了 
所以 findRoute() 我录制了视频 讲解，实在不懂的可以看我的视频分析或许有帮助：
https://user.qzone.qq.com/1186179435/mood/6ba9b3467ef3205f83a70b00

goalOrientedRobot()好理解

下面一堆英语 有可能越看越晕，但他是在解释代码
Highlight:Here is a function that does this:
Sticky notes:上面一大堆摘要：
1、我们不能盲目的找路，需要判断出最好的路
2、为了实现1 故意的走向一个有包裹的地点，这样做即使不是一步就到包裹地，也需要某种寻路功能。
3、这个问题就是典型的寻路问题，必须多次寻找可能的路径
4、可能的路径可能有无穷个但是 从A到B点我们只关注从A出来的路线，路线可能走重复一个点，但是不关心（不关心可以提高效率）
5、事实上，我们要找最短路径，所以我们在找到更远的路径前想找到最近的，最好的方法是从起点，“生长出路径”，寻找可能的路，这样会找到最短的路
Highlight:Our code doesn’t handle the situation where there are no more work items on
Sticky notes:要崩溃了看他的解释 看也看不懂核心思想

goarlOrientedRobot函数
","2020-07-28 01:34:41"
"Project: A Platform Game :: Eloquent JavaScript","http://eloquentjavascript.net/16_game.html","no_tag","","","Highlight:game
Sticky notes:无关紧要 谷歌翻译：
我最初对计算机的迷恋，就像许多书呆子的孩子一样，都与计算机游戏有关。 我被吸引到了我可以操纵的微小的模拟世界中，并且其中的故事（某种）展开了-我想，更多是因为我将想象力投射到其中，而不是因为它们实际提供了可能性。

我不希望任何人从事游戏编程工作。 就像音乐行业一样，渴望在其中工作的年轻人数量与实际需求之间的差异造成了相当不健康的环境。 但是，编写有趣的游戏很有趣。

本章将逐步介绍小型平台游戏的实现。 平台游戏（或“跳跃和奔跑”游戏）是期望玩家在整个世界（通常是二维视图，从侧面看）上移动人物同时跳到物体上的游戏。
Highlight:Jumping is a specialty
Sticky notes:介绍下这个游戏（基于Dark Blue的，很简单也很有趣）
1、游戏任务就上上面的图，玩家黑色，躲避演讲红色，收集硬币黄色 =》通关

2、这个游戏特色是跳跃，在空中也可以变换角色的位置（代码实现要点）

3、背景静态的是 蓝色（空气） + 白色（墙） + 红色（岩浆） 
这些背景可以 依据一个地图样子的字符串画出来

4、移动动态的是 玩家 + 硬币 + 移动型岩浆

总共上面3+3个元素 整体把握 别晕了之后看代码
Highlight:DOM
Sticky notes:我们实现这个游戏的技术是DOM+事件

1、游戏里的每个元素都是有颜色的方块，用DOM+CSS特别容易实现颜色大小和位置

2、背景是一个不变的方块，自由移动的元素使用aboslut的CSS

3、DOM虽然不是为游戏设计的，但是效率还是比较高，能胜任这些图像的展示
下一章我们用canvas来绘制像素级别的游戏而不是DOM节点
Highlight:Periods are empty space, hash (<code>#</code>) characters are walls, and plus signs are lava. The player’s starting position is the at sign (<code>@</code>). Every O character is a coin
Sticky notes:我们用一个字符串表示要加载的地图等级，约定：
1、句号.是空白
2、井号#是墙
3、加号+是岩浆
4、艾特号@是玩家初始位置
5、字母o是金币位置

以上是静态的元素
Highlight:lava
Sticky notes:岩浆除了静态的+元素还有是那种动态岩浆
1、等号= 是水平来回移动的岩浆
2、或号|  是竖直来回移动的岩浆
3、下箭头号v  是滴落的岩浆，不会反弹 到地上回到原点
Highlight:trim
Sticky notes:下面一大堆解释class Level：
1、用trim 去除空格，传入关卡的字符串可能有多余的空格

2、用map方法  弄出一行一行rows 再map 弄出单独一行row 这样就可以得到传入大字符串每个元素：
#@这些东西

3、弄出来这些符号，要解析分两类
① if (typeof type == ""string"") return type; 
是wall或者lava或者empty
② 
this.startActors.push(
    type.create(new Vec(x, y), ch));
return ""empty"";
相当于else 不是①情况就是移动的对象
然后原来移动对象的地方设置为空气（被object取代）

4、map方法有index参数 可以作为游戏坐标，左上顶点为(0, 0)

5、在好底下有个levelChars根据字符串转换成相应的，然后塞到startActors 为之后 startActors使用

6、和第6章的练习一样，我们定义一个Vec类存储坐标
Highlight:levelChars
Sticky notes:在好底下定义的常量

const levelChars = {
  ""."": ""empty"", ""#"": ""wall"", ""+"": ""lava"",
  ""@"": Player, ""o"": Coin,
  ""="": Lava, ""|"": Lava, ""v"": Lava
};
Highlight:As the game runs, actors will end up in different places or even disappear
Sticky notes:Level类
——————————————
State类
Highlight:statu
Sticky notes:这个State类决定 游戏的去向

初始是“playing”状态
碰到岩浆 “lost” 状态
收集完所有金币 “win“ 状态

State就是来存储状态信息的，输了重开，赢了下一关
Highlight:Actor objects
Sticky notes:讲actors能动对象（Player，Lava，Coin），先说他们的共同特点：
1、这些对象有相同的接口（好像可以用继承？）。都有pos属性包含坐标，和size属性说明大小

2、都有update方法，来模拟这些对象的操作，比如人用键盘移动，人掉到岩浆，岩浆来回移动这些都需要不停的判断+更新，重新绘制出来

3、都有type属性用来判断行为，“player”，“coin”，“lava

4、都有静态的create方法，来将类实例化成对象，传入参数是坐标

5、用一个Vec类来存储坐标，有plus加法和time乘法来进行更多操作
Highlight:Vec
Highlight:The player class has a property <code>speed</code> that stores its current speed to simulate
Highlight:player
Sticky notes:static create(pos) {
    return new Player(pos.plus(new Vec(0, -0.5)),
                      new Vec(0, 0));
  }
就是上面这个，因为玩家是一个半高，所以绘图的起点要pos.plus(new Vec(0, -0.5))，把玩家向上移动半个，注意这个图坐标最左上是(0,0)，所以向下是正数，向上是负数。
Highlight:size
Sticky notes:Player.prototype.size = new Vec(0.8, 1.5);

size属性我们用原型链写好，我们不用get type() { return ""player""; }，这个是因为对size每次调用getter会浪费的新建一个Vec对象，但是字符串“player”不会有这个问题
Highlight:When constructing a <code>Lava</code> actor, we need to initialize the object differently
Highlight:reset
Sticky notes:岩浆有两种行为
1、有this.reset属性，就是滴落型，碰到障碍，回到初始位置
2、没有this.reset属性，就是反弹型，碰到障碍，移动方向乘以-1，反弹
这两个行为会在update后面具体写出来

create方法接受ch参数（从Level类接受到的，就是字符串具体的符号= | v）来构建特定岩浆（水平型，竖直型，滴落型）
Highlight:<code>Coin</code> actors are relatively simple. They mostly just sit in their place. But to
Highlight:coin’s actual position
Sticky notes:1、为了让游戏更有趣，要让Coin有左右浮动的感觉，于是多存储this.basePos和this.wobble属性，然后计算出最后展现的this.pos

2、第14章我们用了Math.sin，对模拟波浪运动很有效

3、为了避免所有的金币一起同步运动，我们用Math.random函数来让他们随机运动，并且sin的波长是2PI，【0～1随机】 * 2 * PI = wobble
（实现都是之后的update方法 ，
let wobblePos = Math.sin(wobble) 有用）
Highlight:We can now define the <code>levelChars</code> object that maps plan characters to either
Sticky notes:Coin类
——————————————
levelChars
Highlight:Level
Sticky notes:1、定义常量 const levelChars

2、于是可以用前面的Level类了，创建一个小例子试一下
（
console.log(simpleLevelPlan)
......................
..#................#..
..#..............=.#..
..#.........o.o....#..
..#.@......#####...#..
..#####............#..
......#++++++++++++#..
......##############..
......................
）

3、下面任务是在屏幕上展示这些关卡，模拟时间和运动
Highlight:two reasons.
Sticky notes:可以看到本节的函数和类都是从头到尾疯狂写，作者故意没有封装，有两个理由：
1、封装一个程序需要额外的工作和介绍额外的接口，我们这个代码作者为了不让你无聊放弃，尽力写的很小，不需要封装
2、这个游戏里面的不同的元素很多混在一起，当某个的行为改变，很难保持其他的代码一样能用，元素之间的接口改变时，需要关心会不会影响别的，会降低效率
（对这种中型还不太大的不需要分文件封装了，我理解哈，理由也是绕来绕去）
Highlight:Some
Sticky notes:这一节都是说概念啥的绕，
谷歌翻译：
系统中的某些切入点很容易通过严格的界面进行分离，而其他人则不能。 尝试封装一些不合适的边界是浪费大量能量的肯定方法。 当您犯此错误时，通常会注意到您的界面变得笨拙而又笨拙，并且随着程序的发展，需要经常对其进行更改。
Highlight:display
Sticky notes:但是我们有用到封装的，就是具体操作dom节点绘图或者用Canvas绘图，这两个单独封装，可以选择性传入游戏接口

1、class DOMDisplay {     这一章

2、class CanvasDisplay {    下一章
Highlight:following helper<span class=""diigoHighlightCommentLocator""></span> function
Sticky notes:1、可以用 dom.style 来给每个节点写css样式 ，但是太多了很冗余

2、使用辅助函数 function elt，可以方便的给目标节点name添加attrs属性，增加子节点children
三个参数，三个操作，好理解
①  目标节点 name
let dom = document.createElement(name);
②  添加属性 attrs
for (let attr of Object.keys(attrs)) {
    dom.setAttribute(attr, attrs[attr]);
  }
③  添加子节点 children
for (let child of children) {
    dom.appendChild(child);
  }
Highlight:following helper
Highlight:actorLayer
Sticky notes:看的这个actorLayer可能有些懵，听我解释

1、先看代码
初始定义：this.actorLayer = null;

操作actorLayer（syncState方法里）：
DOMDisplay.prototype.syncState = function(state) {
  if (this.actorLayer) this.actorLayer.remove();
  this.actorLayer = drawActors(state.actors);

赋给actorLayer属性的为drawActors返回值：
return elt(""div"", {}, ...actors.map(actor => {
为 数组 actors里面 所有的 “coin player lava” 的对象

2、解释（有点绕哈，就是的）：
actorLayer用来保存当前的所有的Actors，

每当State改变的时候，都要重新绘制Actors（比如金币被收集了，少了一个或玩家碰到岩浆了重新回到起点）

所以更新的时候要remove之前的actors，然后绘制新的，这样用actorLayer就方便移除

3、我们的坐标和大小单位都是1个像素，绘制游戏的时候乘以scale=20
Highlight:unit takes up on the screen.
Sticky notes:class DOMDisplay      [elt()  +   drawGrid()]  整体大类
——————————
drawGrid()     画背景
Highlight:The spread (triple dot) operator
Sticky notes:注意这里三点运算符（...）的迷幻用法，

1、一种是“剩余参数“，在函数定义的时候使用，
function elt(name, attrs, ...children) {
这里children是可以传入任意多个child，然后一起放到children里面去，定义函数的时候

2、另外一种是”扩展运算符“，在调用函数做参数的时候使用
elt(""tr"", {style: `height: ${scale}px`},
        ...row.map(type => elt(""td"", {class: type})))
这里...row，row本来是一个数组，传入elt函数的时候前面三个点是吧数组所有元素拆解出来，然后一个个传入进elt，相当于elt接受到children
Highlight:CSS
Sticky notes:然后就是底下的CSS
1、table-layout、border-spacing和padding属性用来覆盖不想要的默认属性，便于之后创建新的dom在背景上移动

2、CSS颜色可以用单词white也可以用RGB（这不用多说吧
Highlight:We draw each actor by creating a DOM element for it and setting that
Sticky notes:drawGrid()   画背景
————————————
drawActors()    画演员（玩家，能动的岩浆，金币）
Highlight:class,
Sticky notes:1、用drawActors来画所有的动态对象，乘以scale从一个单元到大的像素图像

2、用多个css  空格连接起来
class = ""actor coin""
class = ""actor player""
class = ""actor lava""  这个lava动态的样式和静态一样
Highlight:redraws
Sticky notes:syncState方法来当游戏的State改变的时候，根据State去除旧的Actors，重新绘制所需的Actors

有一种方法是去除某个改变的Acotr，但是Actors数比较少，重画效率也还好
Highlight:The <code>syncState</code> method is used to make the display show a given state. It first
Sticky notes:drawActors()
————————————
syncState()    [drawActors()]
Highlight:level’s current status
Sticky notes:用下面这种空格分割的两个css来表示失败和赢了时候的样式

1、输了 背景变暗一些
2、赢了 有两个 box-shadow 营造出圣光的感觉 
Highlight:We can’t assume that the level always fits in the <em>viewport</em>—the element into
Sticky notes:syncState()
————————————
scrollPlayerIntoView()
Highlight:scrollPlayerIntoView
Sticky notes:又是一个难点，就是说整个游戏地图很大，但是玩家视角是一块600px * 450px的矩形，你需要即使根据玩家的坐标移动矩形，所以代码一堆，理解一哈
1、背景的.game 用 position:relative   玩家的用position:absolute 这样玩家就可以用 最左上角为(0, 0)相对移动

2、改变视角是通过 改变this.dom.scrollLeft 和 this.dom.srollTop 属性，
这里this.dom 是DOMDisplay 对象里的
this.dom = elt(""div"", {class: ""game""}, drawGrid(level))

this.dom就是<div class = ""game"">改变它来变视角
<body>
<div class = ""game"">......</div>
</body>
Highlight:center
Sticky notes:然后底下一堆就是说上面的代码啦，重在理解，推荐用webstorm啥的 调试程序一点点跟着跑看参数咋变的
http://m.qpic.cn/psc?/V11eVEA03x8oJX/45NBuzDIW489QBoVep5mcXMho*H8ovJ3ssrZJIz395pBGIllThtgbmiOeNxDA2tT0944Q1P4yb9V*PmSCoJWAnh8dS9bOXeVX8USYs0fShc!/b&bo=oAV6AwAAAAADN84!&rf=viewer_4

1、let left = this.dom.scrollLeft, right = left + width;
  let top = this.dom.scrollTop, bottom = top + height;
这个鬼东西看半天，还以为是高深的语法，完全是偷工减料气死宝宝了，就是：
let left = this.dom.scrollLeft,
let right = left + width;
let top = this.dom.scrollTop
let bottom = top + height;

1、center的计算利用 state的player的坐标来计算，展示了Vec类是怎么灵活的计算的（通过palyer的坐标加上size一半在乘scale）

2、然后四种判断 判断玩家是否碰到margin=200的上下左右界限，碰到了及时改变scrollTop（具体数学计算看不懂不太要紧，理解代码结构更重要）
ScrollTop啥的为负数不要紧，自己转换成0

3、有另外的方法是scroll，把视角一直保持在画布的正中心，但是这样不自然，我们这种碰到界限改变自然一些
Highlight:We are now able to display our tiny level.
Sticky notes:scrollPlayerIntoView()
——————————————
绘制游戏
Highlight:Solving
Sticky notes:这一堆反复分析如何解决运动和碰撞的问题：
1、平常游戏对于运动是将时间分成很多小步，对每一步，将actor移动一段距离，该距离对应于其速度乘以时间步长的大小，但是我们不一样，我们用秒计算时间然后计算运动距离

2、移动很简单，困难的是处理元素间的交互，当玩家碰到某个东西会有相应反应，碰到墙/地板停下，碰硬币收集，碰岩浆重开

3、解决上面的元素交互是一个大任务，可以找到物理引擎的包，模拟出真实物体的二维或者三维运动，但是我们用更简单更方便的代码处理方块

4、每次移动玩家/岩浆之前，我们检测他们是否碰到墙，碰到了就停止/反弹

5、要把时间步长弄的很小，否则有卡顿感
Highlight:This method tells us whether a rectangle (specified by a position and a size)
Sticky notes:分析一大堆判断如何解决游戏运动和碰撞的问题
——————————————————
Level.prototype.touches方法   
判断是否与Level的东西（大字符串里的静态岩浆/wall）碰撞
Highlight:touches
Sticky notes:这个Level 方法用来判断是否与背景里的东西相碰（静态岩浆、墙）

1、因为玩家的坐标很多是小数，可能跨越了Level大字符串的很多背景小格子，所以使用floor和ceil方法找到玩家相关的格子

2、找到格子之后，要做的是遍历这些格子，判断两个：
① 是否掉到了地图之外，isOutside = true 也把地图边界当作墙（第一关就有这个bug，防止玩家没了
Highlight:The state <code>update</code> method uses <code>touches</code> to figure out whether the player is
Sticky notes:Level.prototype.touches方法   
判断是否与Level的东西（大字符串里的静态岩浆/wall）碰撞
——————————————————
State.prototype.update方法，三个功能
1、一个State更新update ，执行所有actors的更新update方法

2、let player = newState.player是 State的get 方法
然后
判断player是否与Level里的静态岩浆碰撞

3、判断所有actors（除了玩家）是否与玩家碰撞，
玩家与金币碰撞，执行Coin.collide()
玩家与动态岩浆碰撞，执行Lava.collide()

那玩家与墙碰撞怎么办？
答案是，在Player.update() 方法里判断，回到功能1
Highlight:The method
Sticky notes:State.prototype.update方法，三个功能
1、一个State更新update ，执行所有actors的更新update方法（这些update方法可能改变status）

2、let player = newState.player是 State的get 方法
然后
判断player是否与Level里的静态岩浆碰撞

3、判断所有actors（除了玩家）是否与玩家碰撞，
玩家与金币碰撞，执行Coin.collide()
玩家与动态岩浆碰撞，执行Lava.collide()

那玩家与墙碰撞怎么办？
答案是，在Player.update() 方法里判断，回到功能1
Highlight:a time step and a data<span class=""diigoHighlightCommentLocator""></span> structure
Sticky notes:if (newState.status != ""playing"") return newState;

哦哦 我知道了 就是 这个update方法是不断更新的 
有可能 你收集完所有金币 这时候status=""win"" 在1秒的跳转时间里 如果没有
if (newState.status != ""playing"") return newState;
这个 保持 status=“win” 你可能又跳到岩浆里输了（因为没有这个if 程序还向下执行 执行 actor.collide）
Highlight:Overlap between actors is detected with the <code>overlap</code> function. It takes two
Sticky notes:State.prototype.update() 方法
——————————————————
overlap函数 判断两个actor是否相碰
Highlight:collide
Sticky notes:函数overlap 判断两个 actor有没有相碰 
这里就是判断玩家是否与岩浆/硬币相碰，
碰到了就执行 岩浆/硬币的collide函数

这里有个注意的Coin的collide方法
let filtered = state.actors.filter(a => a != this);
这里 this就是代表当前碰到的actor Coin，执行filter就是在actors数组中 把所有 不是 this 当前Coin的对象弄出来 ，相当于收集到了这个硬币

关键：this = 当前actor（coin）
Highlight:This <code>update</code>
Sticky notes:Lava的update方法， 忽略keys参数
（Lava的update方法在State的update方法里调用：
  let actors = this.actors
    .map(actor => actor.update(time, this, keys));）

这个update方法，通过当前速度+时间步+旧位置计算新的位置，然后判断有无障碍物
没有：移动到新的位置
有：根据Lava属性改变（滴落型回到原点（有this.reset），水平/竖直型反弹）
Highlight:Coins use their <code>update</code> method to wobble. They ignore collisions with the grid
Highlight:wobble
Sticky notes:在Coin里创建就弄好了2pi 和这里要用的 this.wobble属性
class Coin {
static create(pos) {
            let basePos = pos.plus(new Vec(0.2, 0.1))
            return new Coin(basePos, basePos, Math.random() * Math.PI * 2);
        }

然后这里更新就直接计算下一个晃动的位置（算法和参数可以自己研究）
Highlight:That leaves the player itself. Player motion is handled separately per axis
Highlight:motion.
Sticky notes:看底下代码的if判断还是能看懂的，这里说下几个注意的

1、画布最左上为(0, 0) 所以向左为负数，向右为正数，向上为负数，向下为正数
下面代码，上半部分是x水平运动
下半部分是y竖直运动

2、let xSpeed = 0;
  if (keys.ArrowLeft) xSpeed -= playerXSpeed;
  if (keys.ArrowRight) xSpeed += playerXSpeed;
这个update会不断调用，所以xSpeed会不断的变成0然后根据按键，变成向右还是向左走（我之前看成了疯狂递增加速
Highlight:key handler
Sticky notes:好理解底下的 代码

核心是 创建一个对象
let down = Object.create(null);

然后 监听 keydown 和 keyup事件 （传入触发函数track）

当事件是keydown的时候，动态改变dom对象，然后用于 palyer.update()的判断 移动玩家

down对象为
{ArrowRight: false, ArrowUp: false, ArrowLeft: false}
Highlight:Running the game
Sticky notes:啊啊啊啊 经历一大堆 终于可以运行游戏了
Highlight:quite primitive
Sticky notes:先说runAnimation()函数，他其实是把requestAnimationFrame()函数重新封装了一遍，原来的太原始，用起来不方便（可以具体看Chapter14章咋调用的，很麻烦）
这个requestAnimationFrame就是用来没过多少秒刷新一次当前帧，执行一遍frameFunc函数（底下runLevel定义好了）

实际打印 time 发现 约为 0.016
1/0.016 = 60 所以 我们的游戏FPS=60 比较流畅
Highlight:<code>false</code>
Sticky notes:} else {
        display.clear();
        resolve(state.status);
        return false;
      }

下面的runLevel 只有当所有关卡都过了 就会停止更新帧
Highlight:maximum frame step of 100 milliseconds
Sticky notes:这里
let timeStep = Math.min(time - lastTime, 100) / 1000;

是设置刷新事件最小为100，是为了解决玩游戏时候切换浏览器的选项卡，
time-lastTime会变得很大 ，然后整个游戏就会出现bug（具体可以试试）
其实不太懂 为啥会出这种bug，但是现象可以看出来，之后闲得慌可以研究

然后这个函数可以把时间步转换成秒，更顺畅
Highlight:The <code>runLevel</code> function takes a <code>Level</code> object and a display constructor and
Sticky notes:function runAnimation()
——————————————
function runLevel()
Highlight:level
Sticky notes:然后具体就是runLevel函数

具体运行关卡判断state.status来进行操作
1、“playing”    玩家还在玩，没有碰到岩浆也没有收集完硬币

2、收集完所有硬币或者碰到岩浆，这里有个ending -=time 就是说计时1秒之后 跳转到下个界面 或者重开（time是每个帧刷新的时间约为 0.016秒，ending=0就是到1秒）

3、这个是1和2情况错（为win/lost 并且 ending <=0 调用下面的）
display.clear();      //调用DOMDisplay的 claer方法
resolve(state.status);
return false;          //停止runAnimation

注意这里resolve(state.status);就是把state的status值在Promise里返回回去给runGame的status
Highlight:A game is a sequence of levels. Whenever the player dies, the current level is
Sticky notes:function runLevel()
——————————————
function runGame
Highlight:resolves when the player finishes the game.
Sticky notes:runGame好理解

就是执行异步函数runLevel 然后成功了 有个
resolve(state.status); 结果 到了 let status = 

if (status == ""won"") level++;  status为“won则下一关”
","2020-07-23 09:51:04"
"Drawing on Canvas :: Eloquent JavaScript","https://eloquentjavascript.net/17_canvas.html","no_tag","","","Highlight:DOM
Sticky notes:就说前面我们可以用DOM节点来构建图像，也可以进行很多很酷操作
但是DOM并不方便，因为DOM设计不是为了画图的而是为了文本text
比如画一个两点之间的线用DOM很奇怪
Highlight:The first is DOM-based but utilizes <em>Scalable Vector Graphics</em> (SVG)
Sticky notes:第一种更好的是SVG，他是基于节点设计于绘图shapes的

可以在普通的HTML文档里面加入SVG节点或者用<img>
Highlight:The second alternative is called a <em>canvas</em>
Sticky notes:第二种更好的是canvas绘图，一个canvas就是一个单独的节点包含绘图，它提供了很多接口来在node占用空间里绘图
Highlight:The main difference
Sticky notes:他们两个的主要区别

1、对SVG 绘图的形状会被保存，然后之后可以随时修改或者缩放

2、对canvas他是利用像素点绘图，绘制一次后就不能修改。唯一修改的方式就是重新绘制
Highlight:briefly
Sticky notes:这里简单说一下SVG，本章重点canvas

最后会讨论SVG和canvas的优缺点
并说什么时候那个更好
Highlight:SVG
Sticky notes:下面两个SVG特点

1、
用<svg xmlns=""http://www.w3.org/2000/svg""></svg>这个包围起来命名空间
就可以使用html没有的标签 circle或rect的来方便绘图
xmlns来指定空间的网络地址

2、
svg节点也可以像html节点一样 用dom操作
let circle = document.querySelector(""circle"");啥的很方便
Highlight:&lt;canvas&gt;
Sticky notes:要用canvas绘图 需要在<canvas>节点上，特点
1、canvas需要 width和height的attrs来制定绘图框的大小，一开始是透明啥都没有
<canvas width=""120"" height=""60""></canvas>

2、canvas的坐标是以最左上角为原点，向下向右为y和x正方向
Highlight:drawing interface
Sticky notes:为了在canvas上绘图需要获取对象利用它的绘图结构

1、let context2D = document.querySelector(""canvas"").getContext(""2d"");
用context2D的接口完成二维图像绘制（重点）

2、let context3D = document.querySelector(""canvas"").getContext(""webgl"");
用context3D完成三维图像绘制（非重点，但是建议学习，它提供了图形硬件的直接接口，并允许您使用JavaScript有效地渲染甚至复杂的场景。）
Highlight:<em>filled</em>
Sticky notes:填充图像
1、cx.fillRect(x坐标，y坐标，宽，高)
任何位置绘制一个填充的矩形

2、fillRect只能接受上面四个参数，要改变形状参数需要别的方法
cx.fillStyle决定填充的属性（同CSS的颜色red）
Highlight:stroked
Sticky notes:绘制描边的图像
1、cx.strokeRect(x坐标，y坐标，宽，高)
任何位置绘制一个描边的矩形

2、cx.strokeRect只能接受上面四个参数，要改变形状参数需要别的方法
cx.strokeStyle决定描边的属性（同CSS的颜色red）
cx.lineWidth决定描边的线宽
Highlight:path
Sticky notes:这节讲下canvas的路径path

path用来构建路径绘制想要的图形
这个path不是用来存储一些路径的信息

相反是用moveTo和lineTo等方法控制点的移动来构建路径描述图形

moveTo 相当于瞬移 移动到一个起点
lineTo 相当于拉一条直线 从当前位置到给定位置 构成线段
Highlight:<code>stroke</code> method
Sticky notes:cx.stroke()方法
来绘制lineTo拉出来的线

但是一旦使用了moveTo到新的起点  线会重新开始
Highlight:<code>fill</code> method
Sticky notes:cx.fill()方法
填充线构成的图形（会填充闭合的图形，当没有闭合的时候 首尾会添加一条线 来填充成图形）

同样moveTo会重新绘制一个封闭图形
Highlight:quadraticCurveTo
Sticky notes:cx.quadraticCurveTo方法绘制曲线（一个弯曲点）

cx.quadraticCurveTo(a, b, c, d)
起点：当前坐标(x, y)
终点：(c, d)
控制点：(a, b)
相当于从(x, y)到(c, d)的直线向(a, b)弯曲，控制点越远弯曲越强
Highlight:example
Sticky notes:上面例子 三角形只花了两条边 当cx.fill()的时候会正常封闭填充

但是cx.stroke()的时候只会画出两条边，可以用cx.closePath() 明确的画出第三条边
Highlight:method draws a similar kind of curve. Instead of a single
Sticky notes:quadraticCurveTo方法
———————————
bezierCurveTo方法
Highlight:The
Highlight:bezierCurveTo
Sticky notes:cx.bezierCurveTo方法绘制曲线（两个弯曲点）

cx.bezierCurveTo(a, b, c, d, e, f)
起点：当前坐标(x, y)
终点：(e, f)
控制点1：(a, b)
控制点2：(c, d)

相当于(x, y)和(e, f)  两个端点被两个控制点(a, b)和(c, d)牵引 越远牵引力越强 绘制曲线
Highlight:Such curves can be hard to work with—it’s not always clear how to find the
Sticky notes:bezierCurveTo方法
———————————
arc方法
Highlight:arc
Sticky notes:cx.arc()方法绘制弧线

cx.arc(a, b, c, d, e)
圆中心点: (a, b)
圆半径：c
截取弧线夹角：d至e（弧度制 Math.PI）
好理解 

注意连续调用cx.arc()会是连续在Path是行动
结果导致两个圆心直线连接（就相当于一直用lineTo移动 连接起来）
可以用moveTo()换新起点或beginPath()方法重新开始绘图
Highlight:avoid this.
Sticky notes:这里有问题，但不知道咋办

1、用 cx.moveTo 还是会有圆心到圆的线段
  let cx = document.querySelector(""canvas"").getContext(""2d"");
  cx.beginPath();
  // center=(50,50) radius=40 angle=0 to 7
  cx.arc(50, 50, 40, 0, 7);
  // center=(150,50) radius=40 angle=0 to ½π
  cx.moveTo(150, 50);
  cx.arc(150, 50, 40, 0, 0.5 * Math.PI);
  cx.stroke();

2、用cx.beginPath()
旧的圆又没有了
  let cx = document.querySelector(""canvas"").getContext(""2d"");
  cx.beginPath();
  // center=(50,50) radius=40 angle=0 to 7
  cx.arc(50, 50, 40, 0, 7);
  // center=(150,50) radius=40 angle=0 to ½π
  cx.beginPath();
  cx.arc(150, 50, 40, 0, 0.5 * Math.PI);
  cx.stroke();

咋办？
Highlight:choice
Sticky notes:reduce函数计算count只和

let total = results
    .reduce((sum, {count}) => sum + count, 0);

sum是reduce返回值 ，后面的0是sum初始值
Highlight:<code>fillText</code> and <code>strokeText</code>
Sticky notes:用fillText()和strokeText()来写文字
两者的区别是fill写出来的字 fill是实心的
stroke出来的是空心字（就是字母中间掏空的）

样式不同而已
Highlight:size, style<span class=""diigoHighlightCommentLocator""></span>, and font
Sticky notes:很多方法改变Text的样式
1、cx.font = ""28px Georia bold italic""
指定字号，字体，加粗，意大利斜体

2、cx.fillText(""I can draw text, too! "", 175, 50);
最后参数(175, 50)指明字体的位置（
默认以(175, 50)为start，向右绘制基线，text站上面）

3、cx.textAlign = ""center"" | ""end"" 水平移动位置
cx.textBaseline = ""top"" | ""middle"" | ""bottom"" 垂直移动位置
Highlight:<em>vector</em> graphics and <em>bitmap</em> graphics.
Sticky notes:计算机图形学有两种图

1、矢量图形（我们之前探讨的 固定能描述形状的图形）

2、位图图形（工作在像素数据层面）
Highlight:drawImage
Sticky notes:drawImage方法 绘制 位图图形
1、cx.drawImage(img, x, y)
img可以是另外一个canvas的<img>标签 如果是网络资源，需要 添加事件 img.addEventListener(""load"") 来进行操作

2、drawImage 共9个参数（后6个可选） 可以三种方式使用
drawImage(image, x, y)   
⬆️  绘制image 指定到canvas位置(x, y)

drawImage(image, x, y, width, height)
⬆️  绘制image 指定到canvas位置(x, y) 并且指定绘制大小width* height 用于缩放

drawImage(image, sourceX, sourceY, sourceWidth, sourceHeight,
          destX, destY, destWidth, destHeight)
⬆️  从源图片截取一段 source图片 放到 canvas上作为一个dest图片
source和dest图片都有四个参数 决定图片的一个矩形框 就是从源图片 剪一个矩形 贴到 canvas上
Highlight:This can be used to pack multiple <em>sprites</em> (image elements) into a single image
Sticky notes:下面全是利用drawImage 切分图片绘制运动的马里奥
Highlight:frame:
Sticky notes:主要是看懂下面代码，要点：

1、主要是利用drawImage方法
2、每次刷新 利用 clearRect清空 canvas
3、设置定时器 setInterval
4、每8个循环一次 cycle = (cycle + 1) % 8;
Highlight:scale
Highlight:shows
Sticky notes:就是利用上面的说的translate和scale函数 实现镜像翻转

说一大堆，看上面图好理解，
为了具体你要假设一个原点（比如在红色3的正中心）
1、context.translate(around, 0);这个 把坐标轴右推around长度 1推到2 坐标轴在绿色1正中心
2、  context.scale(-1, 1);   这个翻转 2到3
3、  context.translate(-around, 0); 因为翻转后向右为负 3推到4

记住翻转之后坐标轴也变了
Highlight:There are several other methods besides <code>scale</code> that influence the coordinate
Sticky notes:先将scale 引出小节主题 缩放和变换
——————————————————
进一步介绍坐标变换 translate和rotate方法
Highlight:<code>save</code> and <code>restore</code>
Sticky notes:就是说改变坐标轴 之前绘制的图像也会改变不方便

为了方便有save和restore可以把之前的图片保存到栈里面去 实现暂时保存 然后进行别的啥操作
Highlight:To flip a picture around the vertical line at a given x position, we can do the
Sticky notes:scale、rotate、translate
——————————————
利用上面学的 弄一个 flipHorizontally镜像翻转函数 然后用于马里奥
Highlight:branch
Sticky notes:下面 branch 就是利用save和restore绘制一个神奇的树 重要是理解 下面的代码在干啥 有点难的 推荐用IDE用Debug跟着他跑跑看看

其实是一个递归的思想 有个主干分支 不断重复 先左边画到底（length< 8） 然后画右边
哎 说不清楚
Highlight:CanvasDisplay
Sticky notes:类比DOMDisplay，都有syncState和clear方法

不同的是：
1、constructor构造函数是 创建一个 <canvas>节点的画布
2、多了flipPlayer 用来之后判断角色的方向
3、多了viewport  用来在大关卡中调整玩家的视角
Highlight:syncState
Sticky notes:syncState方法 用来更新展示的图像

与DOMDisplay的syncState方法不同，DOMDisplay方法是计算玩家的坐标，然后改变这个玩家的DOM，canvas把像素点画出来就不能改了，所以每次绘制要删了重新画

有四个方法
updateViewport  更新关卡的视角
clearDisplay  清除之前画的 （其实是重新画背景矩形）
drawBackground    画背景
drawActors     画actors

这样可以完整的展示一个游戏界面 并且按照FPS=60刷新
Highlight:updateViewport
Sticky notes:updateViewport方法
更新视角

1、用了Math.max()   Math.min()方法，防止view.left/top 小于零 或者超过关卡的边界

2、所有参数改在 view = this.viewport 里面然后之后绘图drawBackground用 this.viewport
Highlight:clearing the display
Sticky notes:clearDisplay

改变一下canvas的背景颜色 ，win了亮一些 lost了暗淡一些
然后
this.cx.fillRect(0, 0,
                   this.canvas.width, this.canvas.height);
画出来
Highlight:draw the background
Sticky notes:drawBackground方法 和 上一章的touches有点像，注意是有点像！！！它们的作用不同

Level.touches 方法是用来判断某个东西是否与Level里静态东西相碰

这里drawBackgroudn 是绘画 当前视图里的所有东西
用 this.viewprot 里的参数是有可能是小数 还是类似touches 弄出整数的格子 然后遍历每个格子 用drawImage方法 从 otherSprites 截出来图像 绘制到canvas里

就是注意
let tileX = tile == ""lava"" ? scale : 0;
下面的sprite.png图像 岩浆要从 (20, 0)处开始 ，墙就从(0, 0) 开始 硬币在drawActors里画出来
Highlight:We don’t bother waiting for the sprite image to load
Sticky notes:谷歌翻译：
我们不用费心等待精灵图片加载。 使用尚未加载的图像调用drawImage只会执行任何操作。 因此，当图像仍在加载时，我们可能无法在最初的几帧中正确绘制游戏，但这并不是一个严重的问题。 由于我们会不断更新屏幕，因此加载完成后会立即显示正确的场景。
Highlight:The walking character shown earlier will be used to represent the player. The
Sticky notes:前面别的
————————————————
最后的 drawActors方法
（drawPlayer复杂一点 要单独写一大段，然后统一到drawActors方法）
Highlight:right sprite and direction based on the player’s current motion.
Sticky notes:1、要绘制玩家在游戏地图里的动态
① 走路用前八张图片，因为FPS=60，
tile = Math.floor(Date.now() / 60) % 8;
除以60 的时间 作为每一帧的某个动作
② 静止不懂用第9张
③ 跳跃在空中用第10张

2、因为这个cancas绘制的马里奥比上节的方块宽（24取代16像素），以便为脚和手臂留出一些空间），所以该方法必须将x坐标和宽度调整给定的数量（playerXOverlap）。
Highlight:drawActors
Sticky notes:1、判断是那种actors对象然后绘制
① 玩家则调用this.drawPlayer
② coin 则 tileX=40（从sprites.png里截图靠右）
③ lava 则 tileX=20（从sprites.png里截图在中间）

2、
let x = (actor.pos.x - this.viewport.left) * scale;
let y = (actor.pos.y - this.viewport.top) * scale;
这两段：计算角色的位置时，我们必须减去视口的位置，因为画布上的（0,0）对应于视口的左上角，而不是关卡的左上角。 我们也可以为此使用translate。 不管哪种方法。
","2020-07-22 09:20:59"
"Variables and assignment • JavaScript for impatient programmers (ES2020 edition)","https://exploringjs.com/impatient-js/ch_variables-assignment.html","no_tag","","","Highlight:mutable
Sticky notes:可变的
","2020-07-19 08:53:12"
"Values, Types, and Operators :: Eloquent JavaScript","https://eloquentjavascript.net/01_values.html","no_tag","""Chapter 1
Values, Types, and Operators""","","Highlight:Below the surface of the machine, the program moves. Without effort, it expands and contracts. In great harmony, electrons scatter and regroup. The forms on the monitor are but ripples on the water. The essence stays invisibly below.
Sticky notes:程序在机器表面下方移动。 不费吹灰之力，它就会扩展并收缩。 电子非常和谐地散射并重组。 监视器上的表格只是水面上的涟漪。 本质隐藏在下面。
Highlight:but that which isn’t data cannot be mentioned
Sticky notes:就是说数据是 用二进制0 1来表示的（which isn’t data）

计算机里的数据用 0 和 1 表达出来

任何离散信息都可以简化为零和一的序列，从而以bit位表示。
Highlight:those chunks are called <em>values</em>
Sticky notes:前面introduction 说明了 计算机中用 0和1 表示数据

计算机中有超过 30 billion 的比特， 为了正确利用比特，我们把比特分成 很多个 chunk
一个 chunk 是比特的集合 代表某些含义（比如数字，字符串，函数等等）
然后我们在js将一个chunk成为 “值”

为了创建值，我们要给每个值取一个名字（变量名），然后 不用某个变量 他占的空间就会消失 留出空间用于后面的操作
Highlight:atomic elements
Sticky notes:本章介绍js程序的基本元素————值和操作符

（上面什么鬼 比特 比特组合 什么chunk 容易把你搞晕，就是说 计算机内是0和1代表数据，每个变量后面可能有很多个比特 会动态存储在内存中）
Highlight:number
Sticky notes:这一部分是说 js 里的 number 是 64位的 最多 2^64种表示 比以前8/16位 强很多 但是 还是有限的 不过很够用
Highlight:overflow only when dealing with truly astronomical numbers.
Highlight:nonwhole
Sticky notes:这里18 quintiliion个数字 要打折扣

1、非整数（nonwhole） 要在整数基础上拿出位数确定小数点的位置

2、负数需要 在第一位 存储标志位（正/负）

然后剩下 9 quintillion 也很多
Highlight:e
Sticky notes:PS:
js里数字还可以用 科学技术法
2.998e8
Highlight:Calculations
Sticky notes:number的计算问题：
1、对整数 前面说的 9 quadrillion种数字 计算是精确的

2、但是对 小数不是精准的 是近似
（主要是有些小数是无限的 pi啥的 用 18 quadrillion也不能表示完）
Highlight:with whole numbers (also called <em>integers</em>) smaller than the
Highlight:Arithmetic
Sticky notes:幼儿园大班都会的加减乘除

就是注意 加减乘除的运算顺序 和 括号() 
Highlight:three special values
Sticky notes:三种特殊的 number 类型值
1、Infinity
2、-Infinity
3、NaN
Highlight:<em>string</em>
Sticky notes:字符串三种表示方法
1、双引号 “”
2、单引号 ‘’
3、反引号 ``

单引号和双引号区别只是 看你想逃避那种在最后结果表示：
print(""She said: 'Hello!' "") 这样 双引号就被省略 而真正字符串是单引号的 ‘Hello’
Highlight:Almost anything can be put between quotes, and JavaScript will make a string
Sticky notes:字符串基础
————————————
解决转义字符问题
Highlight:difficult
Sticky notes:问题：
1、 用""''字符串方式 里面包含 “” 很困难

2、在字符串里换行很难（\n）
只有反引号里的 回车换行是真的换行

于是用转义字符⬇️
Highlight:such characters
Sticky notes:1、转义字符使用
在特定字符前面加\ 就可以表示很难打出来的字符
比如\n表示换行   \t表示缩进 \""表示双引号

3、取消转义字符
想字符串里写\
就用\\ 表示 \
Highlight:Strings, too, have to be modeled as a series of bits to be able to exist inside the
Sticky notes:转义字符问题
————————————
字符编码特殊的（Unicode 和 unicode解决不足问题）
Highlight:Unicode
Sticky notes:字符串的编码扩充特殊情况：
1、js用Unicode编码格式 这个标准涵盖很多世界上的语言每个 字符都是 编码好的 比如""a""就有特殊的Unicode编码，
If we have a number for every character, a string can be described by a sequence of numbers.

2、但是奇怪的是，js语言只用16位表示一个字符元素，最多只能表示2^16种字符，远不及Unicode编码的所有种类 有些表情啥的就不能用了 解决方法第五章详细
Highlight:Strings cannot be divided, multiplied, or subtracted, but the <code>+</code> operator <em>can</em> be
Sticky notes:字符编码
————————————
字符串的特殊操作（加减运算以及字符串中嵌入表达式）
Highlight:string
Sticky notes:好理解：
1、字符串可以用 + 运算符 将每个字符串 “连接concact”起来

2、字符串有一系列内置方法 详细第4章

3、
单引号和双引号区别只是 看你想逃避那种在最后结果表示：
print(""She said: 'Hello!' "") 这样 双引号就被省略 而真正字符串是单引号的 ‘Hello’   

4、反引号的字符串 也叫做 template literals （模版字符串），可以做更多事情 比如写${} 在字符串插入表达式
Highlight:operators
Sticky notes:不是所有操作符都是 特定字符（+ - * / 啥的）
还有个操作符是 typeof租用给出一个数据的类型

操作符分类：一元操作符、二元操作符、三元操作符

- 操作符既可以是一元也可以是二元    一元表示求负 二元是减运算
Highlight:<em>Boolean</em> type
Sticky notes:布尔类型 表示两种情况 正确或者错误
true false
Highlight:produce Boolean values
Sticky notes:产生布尔值的方法：
1、> < >= <= != ==
Highlight:roughly alphabetic
Sticky notes:字符串里 字母的排列大致是按照 字母顺序排列的(abcdefg这种) 

但是有不同是 不同于传统意义上的字母排列
abcde....zABCD,,,,,Z

js里的排列是""Z""<""a"" 也就是大写在前面  这是因为字符串Unicode编码导致的

但比较两个字符串 是一一比较每一个字符串的Unicode编码 （“Z”的编码小于”a“的编码）
Highlight:only one value in JavaScript that is not equal to itself
Sticky notes:所有js里 自己不等于自己的

NaN != NaN

原因：（谷歌翻译）
NaN应该表示无意义计算的结果，因此，它不等于任何其他无意义计算的结果。
Highlight:<em>and</em>, <em>or</em>, and <em>not</em>
Sticky notes:1、逻辑运算符：与或非，应该好理解

2、几个逻辑运算符一起的运算规则：
或|| < 与&& < (比较运算符> ==其他的) < 其他的
这样规定的好处是尽量少使用括号

1 + 1 == 2 && 10 * 10 > 50
Highlight:<em>ernary</em>, operating on three values
Sticky notes:最后要讲的运算符是三元运算符
也叫做条件运算符（唯一三元的）

A : B ? C
A为true 结果B
A为false 结果C
Highlight:<code>null</code> and <code>undefined</code>
Sticky notes:null和undefined表示空值

有时候 你搞一些错误的操作 起码程序要告述你 比如返回 null/undefined 表示空

有两个空是设计者搞错了 大部分情况等同
Highlight:accept almost any program
Sticky notes:js兼容性很强 就是你写很多错误的程序段也能执行 只是执行的结果不对（对比C或者python 尤其C 数据类型错了都疯狂报错卡你 指针很麻烦）

这就是类型自动转换 js里随便写 是好处 也有坏处
Highlight:type coercion
Sticky notes:这里说明了 类型自动转换几种情况
当一些操作符+-*/ 用在一些错误的值类型上  js会悄悄进行转换 来完成操作符 叫做 类型妥协

1、null 做算数运算+-*/ 转换成0
2、字符串“5” 做减法运算 转换成数字5
3、对+操作符 字符串的拼接优先级大于数字运算
所以 “5” + 1 ，将数字1转换成字符串“1”
4、当一些奇葩操作，比如 ""five"" *2 js才不会认得five是人类语言5 不能转换成显式的数字 就会“five”转换成NaN
Highlight:When comparing values of the same type using <code>==</code>, the outcome is easy to
Sticky notes:类型自动转换例子
——————————————
==运算符
Highlight:types differ
Sticky notes:== 运算符也包含了 类型自动转换
1、当左右两个值相等 就是true
唯一特例是NaN（见上面小节）
console.log(NaN == NaN)  => false

2、当左右类型不一样也会进行类型自动转换

3、null == undefined 这个是 true 
可以用来做js程序里条件判断
Highlight:But what if you want to test whether something refers to the precise value
Sticky notes:==运算符
————————————
===运算符
Highlight:<code>===</code> and <code>!==</code>
Sticky notes:三个等于的判断 ===
不会进行类型自动转换

“” === 0 就是false了

推荐使用 ===或 !== 来避免一些类型类型转换带来的麻烦
Highlight:but
Sticky notes:逻辑运算符 && 和 || 用一种奇怪的方式处理 不同的类型

逻辑运算符 &&或|| 会将左边的值转换成 布尔值再来决定做是（比如|| 左边是 true 就肯定是 返回true &&左边是false就肯定返回false 否则 还要看右边）


！！但是！！
取决于操作符不同 和 变换的结果不同 他们会返回返回 左边或者 右边的值
Highlight:The <code>||</code> operator
Sticky notes:|| 或逻辑运算符的特点：
1、看||左边的值能否转换成 true（“user”、1、3这些真的值都算能true） 
能的话 这个逻辑表达式 返回值 就是左边的值
否则就是右边的值

2、这样可以用来给自己函数定义默认default值比如
let x =  compute(this.state.speed || 120)
当this.state.speed 等于空或者null  时就 让x计算默认为120 很好用
Highlight:The <code>&amp;&amp;</code> operator
Sticky notes:&&与逻辑运算符 也很类似 对偶的
当 &&左边值可以转换成 false 就返回 左边值 
否则 返回右边值
Highlight:Another important property
Sticky notes:这里 C语言也有这个特性 叫做 逻辑运算符短路

就是 当 && 或 ||左边的值 已经确定这个逻辑比较式的结果 右边的值 就不会运算（比如在作用域里 改变了某个变量的值 就不会变）
true|| a++
false && a++
a不会被增加1
Highlight:The conditional operator
Sticky notes:2、条件运算符（三元运算符）也是一样 只有一边的操作会被执行
Highlight:Summary
Sticky notes:这节学的

1、js的值 numbers, strings, Booleans, undefined

2、二元运算符、字符串拼接、比较运算符、逻辑运算符、一元运算符、三元运算符
","2020-07-18 06:59:01"
"Higher-Order Functions :: Eloquent JavaScript","https://eloquentjavascript.net/05_higher_order.html","no_tag","","","Highlight:get right.
Sticky notes:这个引子说的很明白，
当程序越来越复杂的时候，我们最好不要写很多行很简单冗余的代码，而是最好用更清晰更明白的表达。
console.log(sum(range(1, 10)));
这样的内部程序代码可能更大，但是更容易理解更不易出错，是我们推崇的
Highlight:vocabularies are usually called <em>abstraction</em>
Sticky notes:前面引子的sum range两个方法就是属于一种词汇的抽象。

看下面做菜的例子，第二种肯定更清晰，但是有一些操作可能要额外定义：soak, simmer, chop, and, I guess, vegetable.

我们不能在一个功能里把所有的步骤写的太清晰，不然很冗余很容易出错，最后导致太低级的抽象。

可以写一些“字典里没有的操作”，之后再用函数具体定义形式。
Highlight:little like a <code>for</code> loop
Sticky notes:这里抽象了循环 用一个repeate函数，最后实现的效果有一点像for循环的形式：
for(...){
  body
}

function repeat(n, action) {
  for (let i = 0; i < n; i++) {
    action(i);
  }
}

这里action传入的参数是一个函数，所以传入的参数形式是
(a) => {....}

这样的原因是 js里函数可以作为一个值传入作为参数
Highlight:Functions that operate on other functions, either by taking them as arguments or by returning them, are called <em>higher-order functions</em>.
Sticky notes:操作其他函数的函数叫做“高阶函数”，要么是传入参数是一个函数，要么是返回一个函数

js语言里，函数和普通值的区别没有太大，而在数学里区别很大

下面具体说明了三种高阶函数“分别操作其他函数”
Highlight:create new functions
Sticky notes:注意看下面greterThan函数返回的是一个函数：
return (m) => {m > n}
这个函数在初次定义n之后let greaterThan10 = greaterThan(10); 就可以被调用使用了console.log(greaterThan10(11));
Highlight:change other functions.
Sticky notes:可以修改函数是啥意思呢？
就是下面修改了Math.min函数
Highlight:provide new types of control
flow.
Sticky notes:还可以提供另一种逻辑 unless 这也是操作 action这个函数
Highlight:forEach
Sticky notes:内置方法 forEach也是个 高阶函数 传入一个函数参数
Highlight:data processing
Sticky notes:高阶函数的一个优势 就是 数据处理
为了演示数据处理的高级操作，这一节首先把“script”当作数据。然后表演如何处理data=script

script 是计算机里面的书写系统，包含拉丁文等等语言字符。
Highlight:140 different scripts—81 are still in use today, and 59 are historic.
Sticky notes:这里script就是语言脚本的意思。不是Unicode有很多大量的字符编码吗，有可能某几段范围是某一种特定的书写脚本语言，比如可能 【2999～5999】（瞎写的）就全是中文汉字，这就是 一种 script


然后本书提供了一个SCRIPT的文件，可以查找所有可能的script 对应的信息和Unicode范围
Highlight:  <span class=""cm-property"">living</span>: <span class=""cm-atom"">false</span>,

Highlight:object
Sticky notes:每一个script是一个object对象，信息给的很清楚，比如Coptic语言的属性上面很清楚，但有两个要说明的：
1、direction：是文字的书写方向，ltr是从左向右，rtl是从有向左，ttb是从上到下。
2、ranges：在Unicode里面的范围，是两元素的数组[下限，上限)，左闭右开。
Highlight:<code>map</code> method
Sticky notes:filter方法是传入一个函数 这个函数返回true 或者 false用来判断是否从原来数组筛除出来某部分元素

map方法是传入一个函数，这个函数会在每个元素上调用（所以不会改变元素数量），但是可能会改变每个元素的内容，（return新的元素内容）

map也是数组的内置方法，上面自定义函数很好的展示逻辑
Highlight:<code>filter</code> function
Sticky notes:这个自定义的filter函数很好的符合高阶函数的特点
1、传入一个函数参数test，在函数体里决定是否收集这个元素（上面定义是test(element) ，然后test函数是 script => (return) script.living 如果 living是undefined就表示不存在这语言脚本了，然后可以判断if语句条件执行）
2、filter函数体里，新定义了一个空数组，符合条件就加入到数组里，而并不是修改原始传入数组删除原始数组程序，这就符合纯函数的概念，不会产生副作用


（我们自定义的filter函数和forEach函数一样，都是内置的数组方法，我们的定义函数展示了默认array.filter()方法的内部功能（实际可能更复杂））
Highlight:reduce
Sticky notes:reduce的作用可以理解为遍历到一个数组里所有element，进行响应的计算，返回出combine成一个值（不一定是将所有elemnet加起来比如下面绿色线的例子，但是肯定会用到所有的element计算得到结果）

这样的话从实现原理来说就需要传入一个执行方法函数，这个函数有两个起码参数（pre，element），element是当前对待的元素，pre是之前已经处理后的元素，然后进行操作后return next，这个next作为下次调用的pre（下一次调用函数的时候pre=next自动，变的主要是每次的element参数）

（比如1，2，3，4用reduce实现连加和，当element是3的时候，pre=1+2，然后执行自定义的操作（这里是简单加起来）return next=3+3=6，这个6作为下次element是4的时候pre=6）不知道有没有更讲复杂，或者可以看他的代码原理
Highlight:start
Sticky notes:我们自己定义的reduce函数有个小注意的 start元素，作为要使用的总和的开头元素

但如果是调用原生的 array的 reduce方法，start默认是第一个元素，不需要额外传入（数组有多个元素时候）
Highlight:To use <code>reduce</code> (twice) to find the script with the most characters, we can write
Sticky notes:前面先介绍清楚reduce

下面一个稍微复杂一点的例子 学会用reduce来找到character最多的script
Highlight:The second call to <code>reduce</code>
Sticky notes:上下两个函数不知道把你搞晕没有，搞晕了就看我的分析，没搞晕就向下看。
1、先用函数式思想，不用太管原理，characterCount就是计算单个script占了多少个Unicode字符编码数，封装认为是一种操作，就是算总数
2、再看下面的reduce方法
看我上面注释说的 reduce传入的函数参数是：
(pre, element) => { ..操作... ; return next}
在看他给的函数参数:
(a, b) => {
  return characterCount(a) < characterCount(b) ? b : a;
}

意思很明确 因为下次调用的时候 pre=next，函数主体并不是普通的reduce类似 (a, b) => {return a+b}，这里reduce是比较a和b那个Unicode个数多一点，多的作为新的next，传入下次pre比较，最后实际上的操作是，找到所有元素里Unicode个数最多的，比较巧妙。

3、然后再去看characterCount(script)，也特别好理解，注意这里script参数 是一个 SCRIPT里的一种语言脚本对象，很方便算出Unicode长度。，script.range是一个大数组（可能某个语言的Unicode范围是多个分散的），用reduce可以算出来所有的范围数量和
Highlight:Composability
Sticky notes:可组合性，就是高阶函数可以用相互组合来完成更复杂的任务
Highlight:But it is still very readable
Sticky notes:上面用普通for循环形式求 最长Unicode的 script脚本，四行长，虽然多了一点绑定 但是还是比较简单 还是可读的比较简单的，显示不出来高阶函数优势
Highlight:Higher-order functions start to shine when you need to <em>compose</em> operations. As
Sticky notes:上面是普通
————————————————————
下面 结合多种高阶函数来实现复杂操作
Highlight:You can see it as a pipeline: we start with all scripts, filter out the living (or dead) ones, take the years from those, average them, and round the result.
Sticky notes:上面是用高阶函数形式完成查找平均script年份的操作，高阶函数很清晰
1、用filter筛除出living/!living的script
2、用map将每个living/!living的script对象变成年份的number（用map方法）
3、用reduce计算出所有living/!living的年份的总和。
4、 / array.length 算出平均值
Highlight:You could definitely also write this computation as one big loop.
Sticky notes:上面是 用 高阶函数组合求平均年份的函数形式
——————————————————
下米娜是普通函数实现求平均年份的形式 并做出一些总结比较
Highlight:computer
Sticky notes:这里来比较高阶函数对于普通函数的优缺点
1、优点，高阶函数更清晰
上面的普通函数把很多操作都揉合在一起，很难看出某一步的操作，并且 比较难像 上上面高阶函数一样抽象出average函数
2、（半）缺点，可能效率低一点
高阶函数运行过程中新建了一些数组，可能占用更多资源和空间，但是对现在告诉的计算机可以不用太考虑，但是对特别大的数组，重复很多次的时候还是要用这种普通低级的形式效率更高。
（这就是正常的相互斗争的，想要高可读性就要牺牲效率，但还是鼓励高阶函数）
Highlight:One use of the data set would be figuring out what script a piece of text is using. Let’s go through a program that does this.
Sticky notes:有了这个SCRIPT数据集很有用的一种应用是查找一段话有哪些语言构成并有多少百分比，分为两小节：
1、STRINGS AND CHARACTER CODES 
说明特殊的字符编码先知需要了解的知识
2、RECOGNIZE TEXT
定义高阶函数实现是被text的功能
Highlight:<code>some</code> method
Sticky notes:也是array内置的some方法，传入一个函数参数test，这个函数return fale 或者 true，
依我的理解some方法和filter方法传入的test参数如出一辙，

只不过filter是针对所有的elements，将return true的element保留下来
但some方法是从头到位判断element，只要有一个element返回true，这个some方法就返回true

这样判断某个Unicode编码是在哪一个script的ranges数组的范围里
Highlight:But how do we get the character codes in a string?
Sticky notes:上面用some方法可以很容易根据一个Unicode代码查找出是属于哪一种语言，但是现在问题是咋找出一个字符串他的Unicode代码？

下面讨论
Highlight:code
units
Highlight:JavaScript strings,
Sticky notes:但是这样有些 js 对字符串的操作就有问题，因为有些字符背后是 2unit的

下面归纳几种js里字符串的操作
1、charCodeAt是早期的方法，只能对1 unit的字符起作用，对双字符的不对
2、后推出codePointAt方法，可以正确返回一个2 unit的编码号
3、.length方法可以争取反应 2unit 和 1unit
4、用方括号 获取错误 horseShoe[0]有问题，是获取马的一半unit

但是还是有个问题，就是我们需要知道某个字符到底是1个unit 还是 2个 unit
Highlight:<code>for</code>/<code>of</code> loo
Sticky notes:幸运的是有 for of循环方法 可以正确的获得 character 再利用 charPointAt 就能获取Unicode编码了
Highlight:characterScript
Sticky notes:前面已经实现了 characterScript函数 传入一个 12345类似的Unicode 就可以判断出是在那个范围的script

下面定义countBy辅助函数
Highlight:findIndex
Sticky notes:在理解这个countBy函数之前弄清楚findIndex方法，这个方法类似indexOf不过有区别。
例如 有个数组let array = ['s', 'y', 'p', '6', '6']
1、findIndex方法是传入一个函数参数，这个函数参数retrun false/true， 调用这方法会找到符合这个条件的第一参数的index 比如
array.findIndex(element => element == '6') 
这个返回3（对象的用法稍微不同 不过原理通 对象是 element.xxx == '6'）

2、indexOf方法是传入一个字符串/数字，找到这个元素，比如
array.indexOf('y')
返回1（这个只能用于数组，所以find方法更灵活表达式形式是参数更复杂应用）
Highlight:countBy
Sticky notes:然后看countBy方法也好理解，
参数(items, groupName)，items是数组，groupName是一个函数参数，return一系列不同的函数名字，然后内部算法计算每个相同return函数名字出现的次数，最后是一个数组。
类似
[
0:	{name: ""Han"", count: 11}
1:	{name: ""Latin"", count: 7}
2:	{name: ""Cyrillic"", count: 3}
]

上面true 和 false的例子不好 反而把你绕进去
Highlight:none
Sticky notes:1、“none” 是 非SCRIPT里的元素，比如空格都是 none 不考虑在内

2、reduce可能有点蒙记住：
(pre, element) => {return next}
上面 {count }是找到每个{name: ""Han"", count: 11}里的11， 整个reduce 加起来 得到总数

3、后面用map 将每个{name: ""Han"", count: 11}转化成“37% Han” 最后 用array.join("","") 方法将字符串数组转化成一条长字符串
Highlight:pass function values to other functions
Sticky notes:js里很强的一点就是可以传入函数作为参数并且做很多处理，允许我们给一个模版函数留下很多gaps，然后传入gaps进行操作 特别灵活强大

array有很多内置方法：
1、forEach
2、filter
3、reduce
4、some
5、findeIndex
等等

这个总结太草率了 总结不好
","2020-07-17 09:37:13"
"Regular Expressions :: Eloquent JavaScript","https://eloquentjavascript.net/09_regexp.html","no_tag","","","Highlight:chapter
Sticky notes:1、编程工具和技术是混乱演进的，只有刚好契合其他技术需要的技术可能胜出而不是那些特别完美的
（以正则扩展，就是说正则很好的契合了其他的语言，很成功有用）

2、在这章讨论正则表达式，可以用来描述字符串里的元素，正则是js和其他编程语言的小且独立的语言

3、正则表达式很难懂隐秘但是及其有用，而且js里的编程接口很烂，但是学好正则可以让你更搞笑
Highlight:Both
Sticky notes:创建正则表达式方式有两种方式

let re1 = new RegExp(""abc"");
let re2 = /abc/;
两种等价

注意以下
正斜杠：/
反斜杠：\
Highlight:<code>RegExp</code> constructor
Sticky notes:创建正则表达式方式有两种方式 两种等价

第一种：
let re1 = new RegExp(""abc"");
利用RegExp构造函数，但是传入的是普通字符串，
也把反斜杠看成字符串

let re4 = new RegExp(""\abc\?"");
onsole.log(re4)
=》 /\abc\?/
Highlight:second notation
Sticky notes:第二种：
let re2 = /abc/;

用斜杠构造正则表达式，对反斜杠的处理方式不同，以下三种奇葩
1、因为以正斜杠/分割，内容用/需要加反斜杠：
let re3 = /and \/ or/

2、正则里不像字符串，转义字符不再适用：
console.log(/eight\n/) 
=》/eight\n/

3、有些特殊符号比如+?在正则里有特殊含义，要用纯符号需要反斜杠：（和1同类，均正则用的符号要\区分）
let re4 = /abc\?/
Highlight:A regular expression consisting of only nonspecial characters simply represents that sequence of characters.
Sticky notes:绕口令 看半天

就是说正则表达式只包含字母（没有特殊字符）就会去字符串里有没有这段字母，任何地方有就是true

/abc/ =》无特殊字符，去找有没有“abc”
Highlight:indexOf
Highlight:match any number
Sticky notes:这节将元素的组合，匹配任意一个就true，两种方式
1、用方括号
[0123456789] 或 [0-9]

2、约定好的转义表达：
\d \w \s \D \W \S.
Highlight:That looks completely awful, doesn’t it? Half of it is backslashes, producing a
Sticky notes:上面可以用元素组合完成很多任务，但是有些冗余，后面可以简化

下面说一些元素组合的特例（.+^）
Highlight:For example, <code>[\d.]</code> means any digit or a period character. But the period itself, between square brackets, loses its special meaning.
Sticky notes:上面元素组合不是很多集合吗 可以匹配任意一个元素（/d /s .这些）
然后可以在原始的[]里再加入元素组合Sets of characters

1、/[\d\s]/.test(""    123"")   这样就可以查看有无数字或者空格类型之一
2、但是/[\d.]/.test(""asd"")     这样特殊符号.失去匹配任意字符的意义 变成匹配数字或句号（原因可能是 . 的范围超过了\d 可能包含了）
3、/[\d+]/.test(""+"")  表示匹配数字或者加号

注意以上特殊符号+.变成原来含义是仅在[]里有效，没有[]还是特殊含义（因为[]表示匹配任何一个就true 所以 . +等表示多个的意义不大）
Highlight:^
Sticky notes:方括号里加^（这个特殊符号不一样）
表示除了后面跟随的任意内容
Highlight:a sequence of one or more digits
Sticky notes:前面用[]来匹配某一个数字
下面说说如何匹配一串字符或数字，有多种
1、+   time >= 1
2、*    time >=1 or time = 0
3、？  time = 1 or time = 0
4、{4}  time = 4
Highlight:(<code>+</code>)
Sticky notes:+
前面的
重复 大于等于一次
Highlight:(<code>*</code>)
Sticky notes:*
前面的
重复大于等于1次 or 【不存在】
Highlight:A question mark
Sticky notes:？
前面的
重复0次或1次
Highlight:{4}
Sticky notes:{}
前面的
重复花括号里的次数，多种：
1、{4}
2、{2,4}    2～4闭区间
3、{5,}      >=5次
Highlight:A part of a regular expression that is enclosed in parentheses counts as a single element as far as the operators following it are concerned.
Highlight:i
Sticky notes:1、前面是单个字母或字符重复，也可以将一段重复，容易理解
(hoo+)+

2、正则最后也可以加修饰符
这里 i 不区分大小写
Sticky notes:1、前面是单个字母或字符重复，也可以将一段重复，容易理解
(hoo+)+  

2、正则最后也可以加修饰符
这里 i 不区分大小写
Highlight:test
Highlight:exec
Sticky notes:RegExp.test()方法很简单 只能检查是否存在
test()匹配到true
test()没有匹配到false

RegExp.exec() 方法更高级
exec()匹配到返回一个很多信息数组
exec()没有匹配到是null
Highlight:An object returned from <code>exec</code> has an <code>index</code> property that tells us <em>where</em> in the
Sticky notes:个鬼东西 下面讲的绕来绕去 看半天 我来捋一捋
Highlight:object
Sticky notes:下面四段的 1 3 4段都是说exec返回的对象
1、exec返回的object
a、有index告诉你 匹配到的第一个的位置
b、返回的object 像一个 字符串的数组（就是前面几个是字符串 后面有index 和 input两个额外对象）
Highlight:match
Sticky notes:String.match()
RegExp.exec()

match和exec区别挺大的
https://www.cnblogs.com/heshan1992/p/6259171.html
Highlight:subexpressions
Sticky notes:2、返回的几个字符串
第一个是整个正则表达式匹配到的内容（第一个）
后面是（如果有()括号括起来的组）整个匹配到的里面的子表达式
他给的例子太烂，看半天，蛮简单例子：

var re = /quick\s(brown).+?(jumps)/ig;
var result = re.exec('The Quick Brown Fox Jumps Over The Lazy Dog');
console.log(result)
=》
[""Quick Brown Fox Jumps"", ""Brown"", ""Jumps"", index: 4, input: ""The Quick Brown Fox Jumps Over The Lazy Dog"", groups: undefined]
undefined

就是整个RegExp匹配到的是""Quick Brown Fox Jumps"" 然后里面有小括号的组匹配到了一个  ""Brown"" 二个""Jumps""
Highlight:<code>undefined</code>.
Sticky notes:3、当子表达式没有匹配到
第二个 是undefined
（当整个RegExp没有匹配到 整个object是null）
Highlight:match ends up in the array.
Highlight:exec
Sticky notes:组很有用

下面给一个例子
从一个字符串里 找出年月日 变成一个数组

讲以前先介绍一下Date类
Highlight:JavaScript uses a convention where month numbers start at zero (so December is 11), yet day numbers start at one. This is confusing and silly.
Sticky notes:很傻的月日从0开始
月（0～11）
日（0～29）
Highlight:Date
Sticky notes:Date类 简单 一看就懂，总结一下：
1、构造Date类
console.log(new Date(2009, 11, 9, 12, 59, 59, 999));
参数： 年 月 日 （时 分 秒 毫秒）（后可选不穿为0）
console.log(new Date(1387407600000));
也可以传入毫秒计算的相对时间（1970年为界）

2、Date类的方法
getTime() 得到自1970年的毫秒
getFullYear()  得到年
getMonth() 得到月
getDate()  得到日
getHours()
getMinutes()
getSeconds()
getYear()  得到年份减去1900（鸡肋）

3、获取现在时间方法两种
let nowTime1 = Date.now()

let nowTime2 = new Date()   //不给参数默认当前时间
console.log(nowTime2.getTime())
Highlight:Putting parentheses around the parts of the expression that we are interested
Highlight:00-1-3000
Sticky notes:说明问题
匹配可能从任何地方开始

比如这里""100-1-30000""
匹配到第二课到倒数第二个

可以用^$ 和 \b来界定字符串和单词的边界
Highlight:<code>^</code> and <code>$</code>
Sticky notes:单词用^$来界定正则的边界

/^\d+$/ 以数字开头以数字结尾
console.log(/^\d+$/.exec(""123123a""))      false
console.log(/^\d+a$/.exec(""123123a""))      true

/^!/  以！开头

/x^/   什么都匹配不到
Highlight:\b
Sticky notes:\b 严格匹配单词
Highlight:|
Sticky notes:好理解 
| 给多种可选表达匹配
Highlight:Parentheses
Sticky notes:|符号 配合 括号()使用 一起来限定
有点奇怪哈 如果你不使用括号
Highlight:The mechanics of matching
Sticky notes:这一节细细的讲了一下正则匹配的过程，本质挺简单的，就是英语看的脑袋疼

感觉这一节讲不讲意义都不大，看了半天也觉得没太大作用，还绕进去了浪费耐心

捋一捋
Highlight:We keep a current position in the string,
Sticky notes:前三段讲下正则匹配的机制
1、第一段就说调用exec或test的适合，正则表达式引擎就从前到后的看你的字符串（从头到尾一点点移动匹配），找到了就返回第一个匹配，或者找不到（废话？我去）

2、第二段说花了一个流图来表示前面的
let animalCount = /\b\d+ pig|cow|chickens?\b/;

3、第三段说：当我们从左到右的流图能找到一个匹配就说明 我们表达式匹配到了，我们会在字符串的一个个位置看，并且每次经过一个盒子，查看下一个元素是否匹配盒子（废话？）
Highlight:""the 3<span class=""diigoHighlightCommentLocator""></span> pigs""
Sticky notes:下面说一下匹配“the 3 pigs”的例子
1、在”3“ 算是一个单词边界 ✅
2、还是”3“ 找到一个数字3 ✅  移动到下个盒子
3、在“ ” 我们先往回看是不是还是数字❌
但发现一个空格“ ” 所以走后面的路✅
4、在“p” 在三个分支找匹配的 匹配到pig✅
5、在“s” 还是两条路 一个跳过s ❌
一个匹配到s ✅
6、在最后“” 匹配到是单词边界✅
Highlight:So the matcher <em>backtracks</em>.
Sticky notes:前几段说下 回溯的原理
就是正则匹配的时候，有多个分支，会从头到尾匹配，当一个匹配错误，会记住之前的位置，回溯回去然后尝试下面的分支
比如例子，匹配""103""
1、第一个分支，匹配到3 错误 换下个分支
2、第二个分支 匹配到尾 没有发现h 换下个分支
3、第三个分支 都是数字 匹配成功

多个分支只会有一种被匹配到（虽然可能有多个都符合），按照他们写的顺序从上到下
Highlight:Backtracking also happens for repetition operators like + and <code>*</code>.
Sticky notes:用｜的正则会有多个分支回溯
特殊符号 + *也会造成回溯

比如/^.*x/.exec(""abcxe"")
1、匹配器发现最后是x结尾 先看整个“abcxe” 发现他之后没有x   回溯 向前移动
2、匹配器看“abcx” 发现之后也不是x 回溯向前移动
3、匹配起看“abc” 发现之后有 x 匹配成功
Highlight:will do a <em>lot</em> of backtracking
Sticky notes:当一个字符串可能被正则表达式多种情况匹配到的时候可能会花很多时间来进行回溯匹配

比如正则    /([01]+)+b/
步骤（也不太懂 迷迷糊糊 就是很多情况就对了吧）：
1、看内部的 [01]+ 所有情况匹配
2、看外部的 ([01]+)+ 来看是否匹配
有多种情况
Highlight:replace
Sticky notes:讲下replace方法 相信都看得懂好理解，总结一下：
1、replece传入两个参数， 后参数替代原来的参数，返回被替代了的结果字符串

2、传入的替代参数可以是一个函数，函数可以有多个参数，例子中：
function minusOne(match, amount, unit) {
这个函数的参数
第一个match 整个匹配到的字符串
后面的 是子字符串匹配到的组group
（不传入函数参数 也可以用$1 $2来表示组）

3、全局匹配 增加g 等选项
Highlight:It would have been sensible if the choice between replacing one match or all matches was made through an additional argument to <code>replace</code> or by providing a different method, <code>replaceAll</code>. But for some unfortunate reason, the choice relies on a property of the regular expression instead.
Sticky notes:这一段强调本来 给replace() 这个函数里面传入一个参数 来选择全局匹配更好 或者给另一个函数replaceAll() 

但是实际情况是 添加 g 选项来全局匹配有点奇怪 但是是这样设计
Highlight:[^]
Sticky notes:注释可能有任何内容

这里用[^]来表示任何字符
不用.* 是因为.*不能匹配换行 而注释可以换行
Highlight:greedy
Sticky notes:第三个出错了
因为 这些重复操作符 是贪婪的
""1 /* a */+/* b */ 1""
对上面字符串 匹配到第一个*/ 还不满足 还会向后匹配 匹配到b后面的*/才结束 因为贪婪

要变成懒惰 就使用(+?, *?, ??, {}?)
Highlight:<code>RegExp</code> constructor
Sticky notes:遇到这种对要匹配的字符串不确定 
不能使用
/\b(harry)\b/gi   这种形式 因为事先不知道要匹配harry

只能用 
let regexp = new RegExp(""\\b("" + name + "")\\b"", ""gi"");
这种 new RegExp的构建正则的方式 但要记住 \b 写成 \\b 
然后很灵活解决这个问题
Highlight:nerdy
Sticky notes:但是万一有人捣乱 
传入的name是dea+hl[]rd
因为 let regexp = new RegExp构建正则
对 .+*?(){|^$       这种东西需要在最前面添加 \

需要转换一下
dea+hl[]rd        =》     dea\+hl\[]rd

然后就可以正常使用了
Highlight:start at a given offset
Sticky notes:search 和 indexOf差不多

console.log(""  word1"".search(/\d/));
console.log(""  word1"".indexOf(""1""));

区别1: search后是正则  indexOf后是数字
区别2: indexOf后可以加 从偏移开头多少开始 search不行
Highlight:global (<code>g</code>) or sticky (<code>y</code>) option enabled
Sticky notes:前面说search方法不能像indexOf提供偏移，这里说exec能实现

整节结构混乱 这里来总结下来
1、exec用 g 或者 y标签 才能使用，可以用
let pattern = /\d+/;
pattern.lastIndex = 3;
这种来指定 exec开始的位置
（RegExp的lastIndex属性 还有 source属性 来控制）
当lastIndex成功匹配 自动更新+1 到下一位置
lastIndex匹配失败 变成0 从头开始试试

2、y 和 g的区别
y会严格从 lastIndex的位置开始（默认为0）
g 是 全局看看有就能匹配到

3、多次使用exec要小心
匹配成功后 lastIndex会动态更新 一点点变开始的位置

4、g对 match 和 exec影响不同
match方法用了 g 会查找所有匹配到的结果
exec方法用了 g 不变 还是只能匹配第一个结果

5、replace方法 也可以用 lastIndex指定替换的位置 要按需求使用
Highlight:The difference between the global and the sticky options is that, when sticky is
Highlight:When using a shared regular expression value for multiple <code>exec</code> calls, these
Highlight:Another interesting effect of the global option is that it changes the way the
Highlight:So be cautious with global regular expressions. The cases where they are
Highlight:<em>INI</em> file
Sticky notes:我们用正则来读取INI文件的内容（INI通常作为配置文件）
INI文件的格式

1、分号开头的一行被省略
2、用 []开头的 是一个新的节
3、一个 fullname=Larry Doe 这种 给这个节添加一个设置
4、其他的都是无效的
Highlight:split
Sticky notes:要分析这个INI文件内容 可以把这个文件内容 分成一行一行分析 可以用 split方法

但是有操作系统的问题 不同系统换行不同
可能是 \r\n 也可能是 \n

用string.split(/\r?\n/)来解决
Highlight:code
Sticky notes:底下一大堆解释上面代码
下两段：
1、神奇的东西
let section = result;
这个 section 的指针是指向result的
所以section[match[1]] = match[2]; 这个就直接让
resutl[match[1]] = result[2];

好理解 address: {city: ""Tessaloniki""}
节会是一个单独开头 address
节底下的属性 会放到这一节里去  {city: ""Tessaloniki""}

2、section指向当前的节
当是遇到[address] 就会新建一个对象 并且section指向他
当是city=Tessaloniki 就直接添加到section
因为let section = result; 会更改到result

哎哟自己都觉得说的稀烂 推荐用webstorm去debug看一看就好理解了
Highlight:<code>^</code> and <code>$</code>
Sticky notes:用^和$来确保匹配到一行
防止匹配到一部分奇怪的东西

忽略这个可能导致其他的麻烦错误
Highlight:if (match = string.<wbr>match(.<wbr>.<wbr>.<wbr>))
Sticky notes:这里用if (match = string.match(...))

一是 用if 只有 match匹配成功 而不是 null的时候 执行剩下语句

二是 为了保持结构完整性 直接让 match = string.match(...) 然后在下面的花括号使用结果
Highlight:/^\s*(;.*)?$/
Sticky notes:这个东西 

一是可以匹配到 ；开头的注释

二是可以匹配 一系列空格

当这两种都没匹配到 就是错误的字段 报错
Highlight:English language.
Sticky notes:就是说 JS发明最开始很简单

对于一些非英语字符有些蠢

比如对é or β 不能 匹配到 \w 而是匹配到 \W
Highlight:\s
Sticky notes:但是 对于 \s
又可以识别这些奇怪的东西（标准的Unicode）

包括nonbreaking space and the Mongolian vowel separator.（不间断的空间和蒙古元音分隔符。）
这种奇怪的空格可以识别
Highlight:u
Sticky notes:对于上面例子很清楚 
这种苹果玫瑰啥的 是两个 unit组成的 普通的{3} 或者
. 就只能匹配这些鬼东西的 一个unit 因此会出错

所以加上一个 u选项解决这个问题

这是一个问题 默认是会报错的 但是还是保留 为了让其他现存代码能正常运行
Highlight:\p
Sticky notes:然后下面的 \p写法可能不规范 但是可以解决问题

1、\p{Property=Value}
2、\p{Name}

说实话搞不懂什么鬼东西 反正 就是约定匹配是在Unicode什么范围的东西
Highlight:regular expression
Sticky notes:正则表达式 有多种方法：
1、test
2、exec
3、index
Highlight:Strings
Sticky notes:字符串多种方法：
1、match
2、search
3、replace
Highlight:options
Sticky notes:正则有多种选项
1、i 不区分大小写
2、g 全局 对某些方法有影响
3、y 粘性 必须从某个地方开始
4、u Unicode
","2020-07-15 01:17:30"
"Node.js :: Eloquent JavaScript","https://eloquentjavascript.net/20_node.html","no_tag","","","Highlight:outside of the browser
Sticky notes:1、之前学的js 都是在浏览器环境下运行的
下面两章介绍nodejs 它在浏览器之外运行 并且可以搭建http服务器 (之前写的js代码可能这里不适用)

2、这里对node做基本的介绍,不深入研究
首先需要到https://nodejs.org 安装node
Highlight:asynchronou
Sticky notes:1、对于在网络上交流的系统最困难的是处理输入和输出——就是从网络和硬盘上读取和写入数据.移动这些数据花费时间,所以要明智的安排他们可以提升这个系统对用户或网络的响应

2、异步编程很有用(解决这个问题)
Highlight:Node
Sticky notes:1、node最初就是为了让异步编程更方便发明的,2009年发明node的时候,大家已经采用了回调函数()=>这种语法,所以node社区的人很快适应异步编程

2、node js没有内置的输入和输出(读取/写入数据),javascript很适合建立在node上
因此javascrip和node 就只有一套(js的)的内置输入输出方法, 两者结合很合理不会很奇怪
Highlight:process’s standard output stream
Sticky notes:1、node的输出在 进程的标准输出流 而不是在浏览器的js控制台, 因此在终端命令行用node 会在终端打印出来结果

2、 直接在终端输入 node 会开启交互的node程序(跟python一样)
Highlight:<code>process</code> binding
Sticky notes:1、node里面有个process全局绑定 跟 JavaScript里面天天用的console.log的 console全局绑定一样随便用.

2、process提供了很多检查和操控程序的方法

process.exit(code)可以退出程序,code可以是状态码
code=0 正常退出 code!=0其他情况错误error退出

process.avg 可以查看node脚本的参数 返回数组
[“node安装包地址”, “运行js脚本地址”, “参数1”, “参数2”,...]
所以真正的传入参数从 index 2开始
Highlight:This system is built into Node
Sticky notes:1、除了 console 和 process 两个全局绑定,Node还有其他的一些绑定.然后如果想用获取一些别的内置函数可以用modules模组系统(第十章详细介绍的)

2、node内置用 CommonJS 模组系统(用require语法,这个系统可以加载网上的下载包或者自己写的包)
Highlight:require
Sticky notes:下面一大堆说明 require的用法
1、相对路径或绝对路径
相对路径easy :
./当前目录 & ../上一级目录 & /文件系统根目录

用路径时
文件名的"".js""可以省略 : require(./graph)
文件名全省略,只给目录名: require(../MxTag) 则自动导入../MxTag/index.js

2、不用路径,给出包名称
1) 内置模组 require(""fs"") 导入node内置的 fs 包
2) npm下载的包 require(""robot"") 去寻找node_modules/robot/
Highlight:small project
Sticky notes:以下小例子 自己试一试
Highlight:current directory
Sticky notes:1、以上是用 npm 安装使用 ini 包的方法 可以自己试一试

2、node和其他包管理器不太同
1)其他包管理器可能会在一个中央地址安装依赖包

2)node会在当前文件夹安装依赖包
(node这样也有好处 可以便于不同的应用管理包版本,并且便于删除)
Highlight:package.json
Sticky notes:1、package.json就像一个程序的简介 并且来列出所有的依赖和依赖的版本,
2、每个程序应该先执行npm init 来创建一个package.json
3、然后执行 npm install 可以安装依赖包 也方便管理
Highlight:2.3.0
Sticky notes:三大段介绍 版本控制
1、程序和包的版本同时由 package.json控制, 依赖包会独立发展,有些写的程序可能随着依赖包更新而不能用,就要管理好包版本

2、版本号:2.3.0 每一位有含义(semantic versioning语义版本控制)
中间 3: 新的功能增加了 就会更新
首位 2: 表示包的兼容性改变了 就会更新
2.0.0版本和3.0.0版本可能不会兼容

3、可以用在package.json的版本号前用^来选择兼容的版本号
^2.3.0表示: 2.3.0<=版本<3.0.0
Highlight:publish
Sticky notes:1、可以用 npm publish 和 package.json 在一个目录发布一个包,详细的包名称和信息会在 package.json里,任何人可以发布 但是不能发布现在已经有的包名字,不然更新了别人的包

2、npm就是一个进行包注册的程序很简单,还可以用yarn(作用相同 接口和安装策略不同)
Highlight:The file system module
Sticky notes:优雅的分割线

node基本知识
——————————————————
下面介绍 两个模组 require(""fs"") 和 require(""http"")
说明他们的用法并且结合起来实现一个文件下载服务器的小例子

动手学起来 很酷
Highlight:fs
Sticky notes:fs是Node内置模组 可以导出处理文件和文件夹的函数

讲readFile 和 writeFile两个方法
Highlight:readFile
Sticky notes:readFile 从磁盘读取文件, 在回调函数返回文件内容

注意:第二个参数用什么编码方式来读取文件(文件是二进制存储的)
1、有很多编码方式 大多数是 utf8
2、如果不传入编码方式 默认是buffer方式读取 默认读取文件的二进制内容, 返回的是些 比特的对象
Highlight:writeFile
Sticky notes:writeFile 来写入文件到磁盘

不需要传入编码方式
因为传入参数是字符串“Node was here”,js程序就是默认用utf8编码的,字符串自动转换成utf8对应的比特写进文件.
Highlight:callback function
Sticky notes:“fs” 包里函数处理异步方法

1、 大多数是用回调函数(err,text) => {}
(最初写代码的时候 promises语法还在发展没有用)
但是回调函数最大的问题是错误处理变得冗长且容易出错。(the biggest one being that error handling becomes verbose and error-prone.)

2、10.1版本之后提供 promises版本
导入: const {readFile} = require(""fs"").promises

3、也可以用函数的同步版本
const {readFileSync} = require(""fs"")
同步会停止运行别的程序 有坏处
Highlight:http
Sticky notes:http模组 用来提供运行http服务器 和 做http请求的功能

讲 createServer 和 http两个方法
Highlight:createServer
Sticky notes:执行以上代码 可以在 localhost:8000/hello开一个页面

下面一大堆说明上段代码干了什么

1、createSever 传入一个 参数 这个参数是函数 这个函数在每次连接到服务器会被调用
这个函数的两个参数是(request, response)
request包含请求信息(传给服务器处理),
response包含返回信息(浏览器接收进行渲染)

2、下面说明 response 的格式
一、response.writeHead() 写入response的头信息(状态码200和一个包含信息的对象{...})
二、response.write() 返回response的body 可以调用多次write传给客户端
三、response.end() 代表response部分结束

3、server.listen(8000) 在本地8000端口启动服务
node之后一直等待不关 ctrl+c关闭
Highlight:A real web server usually does more than the one in the example—it looks at
Sticky notes:我是优雅的分割线(doge)
真正的web服务器不会上面这么简单,会根据request 执行复杂的结果

createServer
————————————
request
Highlight:request
Sticky notes:request 方法可以模拟客户端发送请求

同样敲一敲下面代码 然后再解释

1、request的第一个参数 是一个对象
对象包含request的信息(服务器地址,路径,请求方法,request头等等)
第二个参数是 当返回 response的处理response的函数参数

2、和response对象一样 request对象也有 write和end方法(但GET方法没有 body 无 write方法)
敲黑板!!
response对象是createServer的(第一个函数参数的参数)
request对象是直接用request 生成的类实例
对比学习记忆

3、对于https请求 也有一个类似的
const {request} = require(""https"")

4、http包的方法非常原始 还有别的很好的npm包
如node-fetch包里的fetch方法
Highlight:Writable streams
Sticky notes:1、写入流的特点
1) 有write方法 传入 字符串或者 Buffer 来写入
2) 有end方法关闭流 并可以传入一个状态参数
3) write和end 方法都可以传入回调函数 在写或关闭的时候调用

2、可以用createWriteStream创建一个流指向文件
(和require(“fs”) 包的 writeFile有点类似)
但是createWriteStream 可以用 write()方法写多次 然后end()
writeFile只能在传入参数一次写入(翻看上两节)
Highlight:Readable streams
Sticky notes:可读流复杂一些

1、从流读取数据 用 事件处理函数完成 而不是方法

2、可读流有一个 on 方法 类似 js里面的 addEventListener方法 可以给一个事件名称 和一个 触发调用函数

3、事件有两种
“data” 有数据来
“end” 流到达末尾
(下面有句话绕口,意思是 当整个文档没有加载完全的时候 你可以 读取流数据“streaming data” 就是不完整一片一片的数据 (流视频的概念))
Highlight:<em>streaming</em> data
Highlight:This code
Sticky notes:敲一敲下面代码实践
让服务器接受请求信息 然后大写返回给客户端请求的内容

1、chunk 是 Buffer对象 可以用toString()转换成字符utf-8编码

2、process.stdout 是 node的标准输出
不用console.log() 因为会换行 这里是数据“可能“是 chunk 一片一片来的 造成影响不适合
Highlight:Let’s combine our newfound knowledge about HTTP servers and working
Sticky notes:接下来 结合学到的 fs包和http包的知识 来创建一个文件传输服务器 内容细节有点多

不要害怕 跟着亚鹏一点点完成

敲完能构建传输文件的服务器还是很酷的
Highlight:When
Sticky notes:三点小细节(注意)

1、将文件当作http资源
用GET、PUT、DELETE三种方法来读取、写入、删除数据

2、不想把整个系统的文件暴露给外界获取
会以服务器启动的目录作为根目录 比如:
1)服务器在 /suyapeng/Desktop 启动
2)请求 curl -X GET http://localhost:8000/file.txt
3)则会 获取 /suyapeng/Desktop/file.txt的文件 而不会到别的路径去 保证安全

3、用一个method对象整合存储所有的 读取删除等方法
这些方法 是 async 异步的 都有返回一个 promise
Highlight:This
Sticky notes:这里四段解释上面代码要点

1、最最重要(看了半天费劲):
上面代码整体是在干啥:

1)let handler = methods[request.method] || notAllowed
这一句是在 根据路由的request.method 选择响应的处理方法(GET就读取数据 DELETE就删除数据)
并且防止有人乱给方法(COPY啥的 没有 则处理函数为notAllowed)

2)handler(request).catch(...).then(...)
!!!!!!!这里是在绑定handler的 catch 和 then 并没有定义handler
定义异步的handler 在报错的时候(catch)和完成的时候(then) 执行的函数

明白了不?上面在干啥? 不然一头雾水
Highlight:pipe
Sticky notes:2、具体各个部分

1) notAllowed 则返回状态码 405 说明方法无中生有

2) catch内 将错误状态码返回

3) then内 注意参数({body, status=200, type=""text/plain}"")
status和type默认 200 和 text/plain
body是 handler方法返回的结果(比如GET方法 body就是文件流)

(如果body是可读流) 注意神奇操作 body.pipe(response)
是将 可读流body 的内容 写进 可写流response

(如果body不正常是null,字符串或者buffer)
则resposne.end(body) 塞进去就行
Highlight:To figure out which file path corresponds to a request URL, the <code>urlPath</code>
Sticky notes:分割线

初始化定义createServer逻辑层
(执行函数的 then catch等等细节)
——————————————————————
下一部分 定义urlPath函数
(来获取请求里面的即将操作文件的名称和位置)
Highlight:security
Sticky notes:urlPath 必须保证在网络上的安全性 几个小细节:
1、decodeURIcomponent 将path解码 因为有的特殊字符在路由里是编码形式 如 %20 这一步将编码转换

2、const {rep} = require(""path"") rep方法获取系统的分隔符 (linux或mac是 正斜杠/ windows是反的\)

3、process.cwd() 获取服务器执行代码的当前目录

4、const {resolve} = require(""path"") resolve方法用来从路由path中解析出 本机的地址

5、结合以上4个小技巧 添加一些if啥的判断 从用户的request获取需要的path 并且判断安全性 防止向服务器的上面获取文件
(就是这四个小东西新的难理解 结合起来看代码容易)

6、throw error情况:
1) path != baseDirectory 解析的路径不是基础路径(GET方法可以解析文件夹 来查看服务器下有啥文件)
2) !path.startsWith(baseDirectory + sep) 解析的路径不是以基础目录并且以系统分隔符开始的 (有人向上请求文件不安全)
除了这两种情况 别的是允许的
Highlight:We’ll set up the <code>GET</code> method to return a list of files when reading a directory
Sticky notes:分割线

urlPath
——————————
GET方法 (stat方法、readdir方法 和 mine包等技巧)
Highlight:mime
Sticky notes:mime包 来获取 文件的类型 并写到type里
Highlight:stat
Sticky notes:stat包检测是否存在路由里请求的文件或者判断是否请求的是否文件夹
Highlight:stats
Sticky notes:这说的逻辑太乱了 几乎是想到哪里说哪里 我也很难帮你总结逻辑呀,看看代码结合理解,尽力帮你屡屡

GET方法用到的包:
1、mime包获取文件类型

2、stat方法 根据解析的路径获取服务器本地的文件,
1) 因为读取硬盘 需要异步 const {stat} = require(""fs"").promises
2) 返回的stats对象 有些方法给出文件的属性
stats.size() 文件属性
stats.mtime() 修改日期
stats.isDirectory 是否文件夹

3、readdir方法
当路径是文件夹时 readdir 方法 来获取文件夹下的所有文件

结合上面3种新的方法来写条件判断完成GET方法
看看代码理解
Highlight:The code to handle <code>DELETE</code> requests is slightly simpler.
Sticky notes:分割线

GET方法
——————————————————
DELETE方法
Highlight:delete
Sticky notes:DELETE 没有复杂的包和逻辑
(rmdir 删除文件夹操作 unlink删除文件操作)

重要是js编程中的一个概念(这两大段)
意思是 进行一个“”删除“”操作的时候
1、不需要返回告知客户端告知是否删除操作成功
2、无论要删除的文件1存在2不存在3是文件夹,操作之后都返回一个成功代码204
因为删除一个不存在的文件也到达了目的 鼓励这样做
Highlight:This is the handler for <code>PUT</code> requests:
Sticky notes:分割线

DELETE方法
——————————————————
PUT方法
Highlight:pipe
Sticky notes:PUT方法(修改/增加文件)也有三点注意

1、put方法也不用检查是否存在目标文件, 有已存在文件则重写 没有则创建 任性

2、用pip方法 从request的内容 写到 服务器文件中,因为pip方法没有promises 需要自己封装一个函数pipStream来进行异步操作(编辑硬盘的操作耗时)

3、当PUT报错时解决方法
1) 打开服务器硬盘文件报错 : createWriteStream会fire 一个 “error”事件
2) 输出流给request可能失败(就是把本地的文件给request的时候断了) (网络断了) request流也会fire 一个 “error”事件
因此 有两次 “error ” from.on(""error"") to.on(""error"")

4、当pip 传输文件完成 fire 一个 “finish” 事件
Highlight:The full script for the server is available at
Sticky notes:恭喜小可爱 !!
你终于看到这里了 以上是搭建文件服务器的代码(有点晕对不?),
node file_server.js

然后用 curl命令 试试操作文件服务器吧 很酷对不对?
Highlight:Summary
Sticky notes:不优雅的总结

1、node很强大 用来构建服务器 还能干很多别的事情 可以深入学习 使用node辅助你

2、npm有很多内置包 你可以下载一些好好使用

3、node里面的函数 大多 异步操作(也提供同步版本) 记得传入回调函数(或者promises)
","2020-06-02 10:24:31"
"Project: Skill-Sharing Website :: Eloquent JavaScript","https://eloquentjavascript.net/21_skillsharing.html","no_tag","","","Highlight:server keeps the list of talks
Sticky notes:这里是产品组的设计:

1、功能:
1) 每个对话有一个演讲者的名字,一个标题,一个总结和一系列评论
2)用户可以来创建对话,删除对话,和对已经存在的对话评论

2、需要实时功能,也就是说页面会不断刷新,自己每进行一个操作就发送到服务器,然后服务器更新(就像qq对话一样很酷)
用的技术是 long pooling 这个想法激励着nodejs的发明
Highlight:server initiate this connection is not practical
Sticky notes:服务器来连接客户端是不实际的
一般是客户端连接服务器
(浏览器不传统接受连接/并且客户端也会隐藏在路由后面 会阻止一些连接)
Highlight:server
Sticky notes:这一些讲的好乱 不知道啥逻辑 梳理一下

1、服务器不行就需要用客户端来保持连接
问题是:http连接只能传输一次简单的数据流(request一次response一次) 要保持连接有两种方法:
1) WebSockets技术 有点像作弊 这里不展开
2) 重点讲long polling方法 持续规律的发送http请求

2、只要持续不断的发送polling请求,当服务器端有数据 就可以立马接受到信息

3、为了防止超时(因为缺少活动返回被丢弃)
long polling手段 为 每次request设置一个最大的时间,不管之前的request有没有返回 都重新开始一个request, 这样也利于服务器端恢复

4、nodejs 可以很好的处理这种 多个long polling 成千上百的请求
Highlight:<code>/talks</code> path
Sticky notes:1、我们用第20章相同的http的接口进行通信
GET 获取信息(很多信息)  (获取主题/评论)
/talks     /talks/Unituning

PUT 创建新对话                  
/talks/Unituning

POST 发送一个对话的评论 /talks/Unituning/comments

DELETE 删除信息            (删除主题/评论)
/talks     /talks/Unituning


2、在路由/talks路径上做http请求 其他路径视为静态资源(html 和 js代码)

3、用JSON格式文档来传递数据
Highlight:PUT
Sticky notes:1、PUT来创建新对话
路由后跟标题 /talks/Unituning 
标题 Unituning

2、因为标题可能包含空格啥的特殊符号 到路由里需要编码
encodeURIComponent(""How to Idle"")

3、在body里添加 presenter 和 summary
Highlight:Such URLs
Sticky notes:/talks/Unituning
可以用作GET/DELTE来 获取/删除一个对话主题
(GET/DELETE的多功能性 又是对话主题 又是评论)
Highlight:POST
Sticky notes:1、POST来为一个主题添加评论 
talks/Unituning/comments

2、在post的body里
传入 author和message
Highlight:GET
Sticky notes:1、GET复杂一 些因为要用到 long polling 加很多信息   看的脑袋疼? 别急 跟着亚鹏思路来

2、客户端
request添加两个头
1)  If-None-Match头 用来告诉服务器现在对话对话的版本
2)  Prefer: wait=90头 用来告诉服务器延时返回resposne的时间

3、服务器
response添加一个头
1)  ETag头 用于服务器存储最新的对话版本号

4、说完了request和response新加的头 总结一下逻辑:
1) 客户端发送request 包含一个对话版本号 If-None-Match 和一个延时时间 Prefer: wait=90

2) 服务器接受到request ,对比If-None-Match和本地的ETag, 
如果版本号相同 并且等待90s(不是立即返回), 则返回resposne(code=304) 告诉客户端 资源没有更新

如果版本号不同 则返回新的response(等待时间内)
Highlight:something
Sticky notes:说完了request和response新加的头 总结一下逻辑:

1) 客户端发送request 包含一个对话版本号 If-None-Match 和一个延时时间 Prefer: wait=90

2) 服务器接受到request 
a) 根据有无Prefer: wait=90 判断是long polling请求还是普通的请求

b) 是long polling 
对比If-None-Match和本地的ETag, 
如果版本号相同 并且等待90s(不是立即返回), 则返回resposne(code=304) 告诉客户端 资源没有更新

如果版本号不同 则返回新的response(等待时间内)

c)  是普通请求  正常返回请求
Highlight:access control
Highlight:The server
Sticky notes:对服务器端四个部分
1、ROUTING

2、SERVING FILES

3、TALKS AS RESOURCES

4、LONG POLLING SUPPORT
Highlight:router
Sticky notes:1、在服务器上要区分多种不同的请求 和 解析path
可以在createServer的时候多个if判断
但是不优美  这里就 写一个 router.js组件来实现

2、router组件里实现的功能:
1) 将request 送到 相应的处理函数handler哪里去
(利用router.add() 添加一些方法 比如)
2) 帮助解析路由path中有意义的部分(如PUT的标题)
Highlight:Router
Sticky notes:解释上面Router 类

1、add方法 来添加一些GET PUT等方法

2、resolve(context, request)方法 来进行处理客户端的请求
1) 检查routes 里有没有 request的方法 没有返回则null

2) 有则进行处理 resolve
(这里一大堆很难看懂 结合后面的定义GET来理解)

3) 注意decodeURIComponent
Highlight:ecstatic
Sticky notes:1、当request不是 router方法的情况 服务器要将它解析成请求public文件的文件 
可以用上一节的文件服务器 
但是有更好的包ecstatic来构建可以防止 PUT和DELETE修改文件和提供该机功能(支持缓存)

2、ecstatic用法 
(解释说的迷迷糊糊的,其实代码很明白)
const ecstatic = require(""ecstatic"");

let fileServer = ecstatic({root: ""./public""});
// 创建fileServer实例 传入配置对象 {root: ...}

fileServer(request, response);
//提供文件 这里 request 和 response 是 crateServer函数参数的 参数里的
this.server = createServer((request, response) =>
Highlight:promises
Sticky notes:1、这里 也用到了上一章的异步处理的好处
resolve 同样是异步
要定义resolve 的 then 和 catch方法

2、写了一个类 将服务器和一些状态封装在一个对象里(下面啥的)
this.talks = talks;
this.version = 0;
this.waiting = [];
Highlight:Talks as resources
Sticky notes:其实单个好理解 困难的是
SkillShareServer 和 Router 和 GET方法三者调用
绕死了 希望下个图对你理解有点帮助

http://r.photo.store.qq.com/psc?/5219df0e-85ba-456c-b509-170d6b73dae4/uMeul31pGB4ZvQm8Ou4xcTei*d.gJ5mFQRIlm9NIlbhfTED33wRbhpp8sAclWCPec6f5qLo0N1ANtblQMElPnHanboYxG86fubssEZbBGBc!/r
Highlight:GET
Sticky notes:GET方法 好理解 如果请求对话存在则返回 否则404

console.log(/^\/talks\/([^\/]+)$/.exec(""/talks/suyapeng""))

-> [""/talks/suyapeng"", ""suyapeng"", index: 0, input: ""/talks/suyapeng"", groups: undefined]
Highlight:Deleting
Sticky notes:DELETE方法

删除 SkillShareServer 的 this.talks 对象里面的 某个对话

执行update方法(之后定义 配合long polling机制)
Highlight:To retrieve the content of a request body, we define a function called
Sticky notes:分割线

DELETE
————————————
PUT
Highlight:readStream
Sticky notes:readStream 获取request.body的内容

其实很疑惑为什么要把 
request 先用readStream 变成 字符串
然后再把字符串解析成对象 获取request.body.presenter
哦哦 知道了 可能http获取body 是一点点的流传输吧
(大大问号?)
Highlight:PUT
Sticky notes:PUT方法新建一个talk

1、readStream 这样 一点点获取request的body

2、检查presenter 和 summary是否为字符串(网络传播 啥东西都有可能炸服务器 检查仔细)

3、合格则写进 server.talks 并调用 update()
Highlight:Adding
Sticky notes:POST添加一个comment

容易理解下面
检查comment 的合法性
1、comment是否合格
2、comment对应的talk是否存在
3、调用update()
Highlight:define a helpe
Sticky notes:对/talks的GET请求 分成两种

1、普通的request请求 就是上面定义的
路由是/^\/talks\/([^\/]+)$/       
/talks/suyapeng这种获取某一title的对话内容信息

2、long polling的请求 下面新定义
路由是/^\/talks$/
纯/talks 获取所有的对话信息 达到实时更新的目的
这种实时更新就需要包含版本控制的ETag
用talkResponse 实现
Highlight:Node stores headers, whose names are specified to be case insensitive, under their lowercase names.
Sticky notes:headers 不区分大小写 
这里“if-none-match”和“prefer”
也可以用来检查If-None-Match和Prefer
Highlight:If
Sticky notes:1、如果if-none-match的版本与server.version不同
则用talkResponse 更新 talks

2、prefer:wait = ? 
不存在等待 返回304
存在等待 则调用server.waitForChanges
Highlight:<code>waiting</code> array
Sticky notes:waitForChanges 等待函数可能有点蒙

1、这里用 一个 数组 waiting 
将resolve(promise完成时的结果)放到waiting里面去

2、不知道在干什么鬼 
看看下面updated 方法 
两个结合理解
Highlight:wakes up all waiting requests.
Sticky notes:简单来说 
就是每次执行updated 就会清空waiting数组 让所有的等待关闭 更新数据返回

但是两段代码有点迷糊
啥resolve setTimeout() 
可以重点研究 在IDE里调试看看
Highlight:The client
Sticky notes:服务器端 除了最后的waiting有点难看代码 其他能好理解

下面是客户端实现
HTML
ACTIONS
RENDERING COMPONENTS
POLLING
Highlight:ecstatic
Sticky notes:提供 index.html作为网页展示 (public文件夹下)

1、index.html
2、skillsharing.css
3、skillsharing_client.js
Highlight:handleAction
Sticky notes:1、应用的数据分为对话talks和用户名user
存储在 {talks, user}对象里面

2、不想让用户直接 修改 state={talks, user} 的值或者发送http请求
定义handleAction函数 来根据不同的action.type来处理相应的事件 更加科学
Highlight:state changes are handled in the same
Sticky notes:一大堆太不优美了, 以下五个事件 (可以直接更新state)
参数 (state, action)   state当前已有状态 action新动作(action为 {talks, user})

1、setUser
设置一个用户 将 {user: action.user} 加入到state
并存储到localStorage

2、setTalks
设置一个对话主题 将 {talks: action.talks} 加入到state

3、newTalk
PUT方法  在服务器新建一个talk

4、deleteTalk
DELETE方法   在服务器删除一个talk

5、newComment
POST方法   在服务器的对话新建一个评论
Highlight:fetch
Sticky notes:三个辅助函数

1、fetchOK
来检查是否请求成功 并且throw error

2、talkURL
将tilte编码 拼接到 url

3、reportError
报错
Highlight:DOM node
Sticky notes:有了数据 要在界面里渲染出来数据 和19章的有点相似  但这里直接修改DOM节点(有些不需要更新 直接渲染DOM更方便 而不是定义类)
1、renderUserField(name, dispatch)
2、renderTalk(name, dispatch)
3、renderComment(name, dispatch)
4、renderTalkForm (dispatch)

注意这里还有dispatch函数 后面才给出

function dispatch(action) {
    state = handleAction(state, action);
    app.syncState(state);
  }
Highlight:elt
Sticky notes:注意elt函数 这一章用前面的 没有写出来

function elt(type, props, ...children){
  let dom = document.createElement(type)
  if (props) Object.assign(dom, props)
  for (let child of children) {
    if (typeof child != ""string"") dom.appendChild(child)
    else dom.appendChild(document.createTextNode(child))
  }
  return dom
}
Highlight:function
Sticky notes:一大堆要疯了 其实就是用elt函数来渲染DOM 复杂一点就很恐怖 不用害怕
建议运行项目 明白elt函数后 用控制台研究

1、http://m.qpic.cn/psc?/5219df0e-85ba-456c-b509-170d6b73dae4/uMeul31pGB4ZvQm8Ou4xcapoHLPfbZLoqRtJkrlALepR7KIWTeUTxVITbfpa2AsxGBKjNTZ0T81i1mhZx**PcpOQB.Z4xw400ymdtkEo1FA!/b&bo=hAYSBIQGEgQRFyA!&rf=viewer_4

2、http://m.qpic.cn/psc?/5219df0e-85ba-456c-b509-170d6b73dae4/uMeul31pGB4ZvQm8Ou4xcf.36O39fMBhmor8rqNZ.PV8q62k*BFFgb4KA0.lZlQ0nIeOUwuBa5y0E0jbYnAh7AeIq*kcYBKi8RTH4JmhcFE!/b&bo=hAYSBIQGEgQRFyA!&rf=viewer_4

3、http://m.qpic.cn/psc?/5219df0e-85ba-456c-b509-170d6b73dae4/uMeul31pGB4ZvQm8Ou4xcZsJpVlocE62fKWAXLQ1hDOzeiRvX3q5lgOqPv95W.uEjVpLeAtP*r3c07LMZxxk4gBBcqeXQTogHft9F.BhNac!/b&bo=hAYSBIQGEgQRFyA!&rf=viewer_4
Highlight:JSX
Sticky notes:上面的代码 疯狂套娃elt函数 只是为了渲染dom节点

其实可以用JSX 在js里面写html标签
JSX的原理跟我们定义的elt函数差不多

每次运行JSX代码之前 要将html标签转换成js代码
Highlight:keeps polling the server for <code>/talks</code>
Sticky notes:1、英语饶人 用谷歌翻译:

“要启动该应用程序，我们需要当前的演讲列表。 由于初始负载与长时间的轮询过程密切相关（轮询时必须使用负载中的ETag），因此，我们将编写一个函数来继续轮询服务器的/ talks，并在有新的对话集时调用回调函数。 可用。”

2、这里回调函数是update
update在底下有定义

pollTalks(talks => {
    if (!app) {
      state = {user, talks};
      app = new SkillShareApp(state, dispatch);
      document.body.appendChild(app.dom);
    } else {
      dispatch({type: ""setTalks"", talks});
    }
  }).catch(reportError);
}
Highlight:infinite loop
Sticky notes:1、async function pollTalks(update) {
async函数 便于等待request

2、for (;;) {} 
是一个无限循环

3、tag = response.headers.get(""ETag"");
成功之后 更新tag 用于long polling
Highlight:fails
Sticky notes:} catch (e) {
      console.log(""Request failed: "" + e);
      await new Promise(resolve => setTimeout(resolve, 500));
      continue;
    }

请求失败 500ms之后再请求一次
比如网络停止了 可以恢复
用setTimeout 来让async 函数等待(异步有点绕哈)
Highlight:304
Sticky notes:if (response.status == 304) continue;
    tag = response.headers.get(""ETag"");
    update(await response.json());

304 则超时 重新请求
200之类 则成功 调用 update函数
更新tag 做下次迭代
Highlight:together:
Sticky notes:SkillShareApp类

将上面的整合起来 来作为客户端js逻辑

主要用来来增加this.dom 更改网页内容
Highlight:application
Sticky notes:runApp()函数

pollTalks 询问新的对话
","2020-05-30 08:09:37"
"Data Structures: Objects and Arrays :: Eloquent JavaScript","https://eloquentjavascript.net/04_data.html","no_tag","""rest""","","Highlight:basic data structures.
Sticky notes:简单的数数据类型 -》 基本数据结构
完成更复杂任务
Highlight:simple data types.
Highlight:The first thing he needs is a data structure to store this information.
Sticky notes:上面是故事背景，重要是用数据结构记录下日志进行分析编程。
Highlight:JavaScript provides a data type specifically for storing sequences of values. It is called an <em>array</em>
Sticky notes:多个数据的集合，叫做数组，
用一个方括号包含多个数据
Highlight:getting at the elements inside an array
Sticky notes:获取数组的元素，也是用一个紧接在数组之后的方括号来获取
数组中index从零开始，历史悠久
Highlight:suspicious-looking expressions
Sticky notes:之前看到过的可疑例子
myString.length
Math.max
这是一些property（属性）的例子
Highlight:<code>null</code> and <code>undefined</code>
Sticky notes:基本js所有的值有property属性
除了null 和 undefined
使用他们的属性报错
Highlight:two main ways to access properties
Sticky notes:两种获取js的property属性方法
1、value.x
2、value[x]
Highlight:The difference is in how <code>x</code> is interpreted.
Sticky notes:两种方法有区别，区别是x解释的方式
1、value.x 直接获取 为文字名称为x的属性 
2、value[x] 获取的是表达式x的值然后转换成字符串的属性，比如x='a' + 'b'  这种表达式，则是获取'ab'这个属性
Highlight:but the dot notation works only with names that look like valid binding names.
Sticky notes:value.x 的语法只能用于 显式能解析的绑定名
所以若 属性名是数字或者分开的字符串等，就要用方括号表达式
value[2] value[""John Doe""] （注意字符串空格，这种显然不能用于.语法）
Highlight:array
Sticky notes:上述讲的是 
通用的property属性！！
在array数组中！！
用数字作为属性的名字因为.dot语法一般不用于数字，并且想用表达式来获取绑定value[3*3]，所以用方括号来获取的多
Highlight:function values.
Sticky notes:有纯值的属性property
也有包含函数值的属性property(method)
(可以把函数看成值,然后调用)
Highlight:arguments
Sticky notes:method函数可以不传递任何参数调用
(实际上是对类成员函数 ,第6章讲对象时易懂)
Highlight:stack
Sticky notes:上面push和pop方法举例子
这两个是堆栈(stack)的术语,
堆栈容易理解,前章的函数调用栈也是这个道理
Highlight:a list of activities and a Boolean value
Sticky notes:日常记录不能仅仅是一个数字或者字符串
这里每天一天的记录(day1,day2)=一系列事件(数组)和一个是否变成松鼠(布尔值)
然后我们需要把这些day1,day2合成一个数组
Highlight:braces
Sticky notes:数组类型就是用来存储多种不同类型的值的.
用花括号创建一个对象
Highlight:aren’t valid binding names or valid numbers
Sticky notes:在花括号里面的形式一目了然:
用冒号和逗号分割

*非显式的名字或者数字必须用引号引起来
""touched tree""
Highlight:braces
Sticky notes:也是注意.从此花括号在js里面有两种用法
1、在语句里面的代码块:
if(a>b) {...}
2、声明一个对象

这两种情况可能会造成混淆,但是情况比较少(在代码块里面又声明对象比较少见)
Highlight:tentacle model
Highlight:octopuses
Sticky notes:前面第1章讲过值(数字number,字符串string,布尔值boolean)的绑定 (触须模型),属性property也是类似的绑定
但是其他的的绑定或者属性可能抓住同一个值

可以把对象看作一个章鱼,有很多触须,每个触须有一个纹身(属性名)和一个抓住的东西(值)
students[""suyapeng""] = ""MFE""
suyapeng是纹身, MFE是抓住的值
Highlight:<code>delete</code>
Sticky notes:有个不常见的delete一元操作符
删除一个对象里面的有名字的属性
不常用,但是是可以实现的

删了一个值就没有了,区别:
1、一个对象完全删除了值 (用 in 为 false)
2、一个对象有个属性a的值为undefined (用 in 为true)
但console.log()都为 undefined
Highlight:Mutability
Sticky notes:变异性
这里讨论对象的可修改 可变性
Highlight:With objects, there is a difference between having two references to the same object and having two different objects that contain the same properties.
Sticky notes:这里一大堆讨论了普通值(数字,字符串,布尔值)和对象的区别
1、普通值怎么都不能改变:
可以用普通值加减,也可以用他们来生成其他值 但是本身的值不能变 “cat” 不可能变成“rat”
2、对象值是可以改变属性property的,可以多次改变让一个对象有不同的值

因此对同一个值,两者也有区别
1、普通值 120和120总是相同的 无论机器里面是否是相同的比特
2、对象值有两种情况:
a、同一个对象(物理比特相同) 有两个不同的名字指向   (object1 == object2 true)
b、两个对象 有相同的值 (object1 == object3 false)
Highlight:Bindings can also be changeable or constant, but this is separate from the way their values behave.
Sticky notes:绑定也可以是 可变的或者不可变的
***重要区分*** 
(绑定的可变性) 和 (值本身的值可变性)不同
1、(绑定)是把变量名对应一个值,也分可变和不可变 let/const a = 1
2、(值)本身是分不可变值/可变的对象 
123/{a:1}

因此有四种情况 2 x 2
有应用
1、你可以用(可变绑定)对应(不可变值)
let a=1
let a=2 //✅ 1,2本身是不变的值 但是a绑定可以改变切换

2、可以用(不可变绑定)对应(可变值[对象])
const score = {visitors: 0, home: 0};
score.visitors = 1;  // ✅ 对可变的对象值改变
score = {visitors: 1, home: 1}; //❌因为绑定score是不可变的
Highlight:==
Sticky notes:比较运算符 ==
1、只有“浅比较”,只能比较两者的id,就是比较两者是否指向同一个物理比特,是或者否
let object1 = {value: 10};
let object2 = object1;
let object3 = {value: 10};
console.log(object1 == object2);
// → true
console.log(object1 == object3);
// → false
2、JavaScript里面没有“深比较”,就是比较对象里面每一个属性property是否相等,但是可以自己写
Highlight:shorthand
Sticky notes:就是这里push有点奇怪:
1、正常应该是 syp.push({age: 20, height: 175})
2、但是这里是直接 journal.push({events, squirrel}),
直接传入了一个值,而不是 events: events

这是简写,直接传递值,就传入给 变量名的绑定里面去
这里相当于 是 传给 events这个属性
console.log(journal[0].events)
Highlight:Correlation
Sticky notes:数学里面的相关性:找出数据变量之间的依赖性
数据分析里面有很多度量方法(这句可能是废话)

反正就是相关性 correlation
1 完美关联
0 完全不关联
-1 完美关联 但是是相反的方向
Highlight:following formula
Sticky notes:有了相关性的定义,接下来是如何计算相关性
好理解:
1、把事件和结果列在表里(2x2duiying)
2、利用phi coefficient公式计算
Highlight:interpret the indices to the array as two-bit binary numbers
Sticky notes:javascript 里面实现计算相关性
很多方案来表示四种情况的表格:
1、4元素数组 [76, 9, 4, 1]
2、两个2元素数组 [[76, 9], [4, 1]]
3、对象,用属性名""11""或""10""表示
4、把索引编译成四种情况(✅这样平的数组最简短高效)
(左边代表是否变松鼠,右边代表事件发生与否)
""00"" -》索引0
""01"" -》索引1
""10"" -》索引2
""11"" -》索引3
Highlight:like n<sub>1</sub>
Sticky notes:好理解,英文烫嘴绕人
求n1. 这种 全部变成松鼠事件是两个相加,因为这两个事件没有直接在我们定义的这种数据结构里面(废话)
n1. = table[2] + table[3]  (n1. = n10 + n11)
Highlight:tally
Sticky notes:tally: 计算(计算事件发生和变成松鼠事件的次数)
就是定义一个函数
将FILE里面定义的一堆对象变成数组[76, 9, 4, 1]方便计算
Highlight:includes
Highlight:tableFor
Sticky notes:解释tableFor函数 英文绕来绕去
大体意思:
函数找到某一天是落入那一个table的下标
1、查找一天的日志是否有输入event事件
index += 1
2、查找是否变成了松鼠
index += 2
3、table[?] += 1
Highlight:of
Sticky notes:数组的循环:
1、计数器循环
2、of 语法 循环一个元素里面所有的值 [推荐]
不仅对数组游泳 对 字符串和其他数据结构也有用
Highlight:correlation for every type of event
Highlight:something.
Sticky notes:将同时有peanuts和没有brushed teeth的事件
新建一个 peanut teeth事件
然后查询这个事件 发现吃了坚果没有刷牙会变松鼠

If only he weren’t such a slob about dental hygiene
如果他不是那么牙齿卫生
affliction 
疾病
Highlight:That’s a strong result.
Sticky notes:以下纯属故事 
_(:_」∠)_
Highlight:some generally useful array methods.
Sticky notes:介绍一些比较有用的数组方法,有点多和杂乱
1、push 和 pop
在数组的末尾添加和删除数据

2、unshift(添加)和shift(删除)
在数组的头部添加和删除数组

3、indexOf和lastIndexOf
从前向后搜索数据索引
从后向前搜索数据索引
找不到返回-1

4、concat和slice
合并数组和拆分数组
array1.concat(‘123’) concat 传递元素而不是数组直接添加
array2.slice(2), slice不给结束范围直接拆分到末尾

以上methods注意: 
特殊用法、传入参数、是否改变原数组、返回值
必要查文档积累了解
Highlight:<code>push</code> and <code>pop</code>
Highlight:<code>unshift</code> and <code>shift</code>
Highlight:<code>indexOf</code> and <code>lastIndexOf</code>
Highlight:<code>concat</code> and <code>slice</code>
Highlight:properties
Sticky notes:字符串、数字和布尔值 不能够自己添加 properties属性  因为本身不能改变immutable
但是数组(动手实验),对象可以自己添加 properties属性

字符串(数字/布尔值也有)有一些内置方便的 [属性] 和 [方法] 了解积累
Highlight:<code>slice</code> and <code>indexOf</code>
Sticky notes:1、slice and indexOf
类似数组, indexOf 可以传入多个元素 a.indexOf(""ee"")

2、trim
消除字符串的空格,回车,tab和相似的元素

3、padStart
前一章[函数]手动实现的函数zeroPad也有内置的padStart  把一个字符串 撑开成多少位(5) 多余用传入元素(a)补齐
""1"".padStart(5, ""a"") => ""aaaa1""

4、spilt 和 join
split 字符串转数组   [参数是分割字符]
join 数组转字符串   [参数是拼接字符]

5、repeat
字符串重复

6、length
长度属性
字符串也能像数组下标获取(第五章警告)
Highlight:trim
Highlight:padStart
Highlight:join
Highlight:split
Highlight:repeat
Highlight:length
Highlight:three dots<span class=""diigoHighlightCommentLocator""></span> before the function’s last parameter
Sticky notes:Rest parameters (翻译剩余参数,难受)

定义函数 参数三个点                                      [定义]

调用函数的时候 rest parameter 就会绑定到一个数组这个数组包含了所有超过的参数数量的元素   [调用]

有多个参数,前面的会按顺序绑定,只是最后多的绑定到rest parameter                                             [注意]
Highlight:<pre class=""snippet cm-s-default hljs css"" data-language=""javascript""><a class=""c_ident"" id=""c_+gqW4B1qk1"" href=""#c_+gqW4B1qk1"" tabindex=""-1"" role=""presentation""></a><span class=""cm-variable""><span class=""hljs-selector-tag"">console</span></span><span class=""hljs-selector-class"">.</span><span class=""cm-property""><span class=""hljs-selector-class"">log</span></span>(<span class=""cm-variable""><span class=""hljs-selector-tag"">Math</span></span><span class=""hljs-selector-class"">.</span><span class=""cm-property""><span class=""hljs-selector-class"">random</span></span>());

<span class=""cm-variable""><span class=""hljs-selector-tag"">console</span></span><span class=""hljs-selector-class"">.</span><span class=""cm-property""><span class=""hljs-selector-class"">log</span></span>(<span class=""cm-variable""><span class=""hljs-selector-tag"">Math</span></span><span class=""hljs-selector-class"">.</span><span class=""cm-property""><span class=""hljs-selector-class"">random</span></span>());

<span class=""cm-variable""><span class=""hljs-selector-tag"">console</span></span><span class=""hljs-selector-class"">.</span><span class=""cm-property""><span class=""hljs-selector-class"">log</span></span>(<span class=""cm-variable""><span class=""hljs-selector-tag"">Math</span></span><span class=""hljs-selector-class"">.</span><span class=""cm-property""><span class=""hljs-selector-class"">random</span></span>());
</pre>
Highlight:three-dot notation to <em>call</em> a function
Sticky notes:调用函数  参数三个点                                [定义]

调用的时候 可以 混合使用 
let numbers = [5, 1, 7];
console.log(max(9, ...numbers, 2));
此时 numbers 会“spread传播“ 成单个元素
相当于 console.log(max(9, 5, 1, 7, 2));      [注意]
Highlight:array
Sticky notes:不仅是[参数的传递]可以用三个点参数
[数组]也可以用三个点参数
Highlight:namespace
Sticky notes:1、有个Math对象,可以提供很多跟数学有关的方法methods     max/min/sqrt

2、Math对象被用作一个相关函数的组合,几乎不会被看作一个值(上面那句英语有点难理解)
就是 Math对象给 自己的内置函数提供了命名空间 免得methods里用的 参数 会和全局绑定混合在一起

(比如 Math.max() 函数里有 let max = -Infinity
在外面也定义 let max = 1000可能会重写 
但是封装在Math的命名空间就不用担心)
Highlight:<code>let</code> or <code>const</code>
Sticky notes:编程语言里 命名了重名的变量 可能会组织你或警告你
js里面 
1、只有 let 或者 const的声明会警告
2、标准的绑定(啥?) 或 用 var/function 声明的不会警告
Highlight:Math.random
Highlight:deterministic machines
Sticky notes:这里又是一大堆Math相关方法介绍
1、Math.random()
产生[0,1)的随机数,虽然 对于机器只会执行重复的动作,但是可以用一些隐藏的值和算法假装出随机值
2、Math.floor()
将小数向下取整数
3、Math.ceil()
将小数向上取整
4、Math.round()
将小数四舍五入取整
5、Math.abs()
取绝对值
Highlight:Math.floor
Highlight:Math.ceil
Highlight:Math.abs
Highlight:Math.round
Highlight:succinct way
Sticky notes:上面跳到下面可能有点不得要领

Destructuring 解构

就是说可以讲一个数组的元素解构出来单独使用
上面phi函数和下面phi函数对比参数发现:
table  -》 [n00, n01, n10, n11]

就是说把传入的参数打开了 分成四个内置的参数
(如果确定传入参数形式可以这样用)
Highlight:<code>let</code>, <code>va<span class=""diigoHighlightCommentLocator""></span>r</code>, or <code>const</code>
Sticky notes:1、上面是函数传参 可以这样拆分 用let, var, const绑定也可以这样
2、数组和对象都可以解构
3、数组用方括号:[] 来解构数组
let [a,b,c] = [1, 2, 3]
//无属性名 直接是元素
console.log(c)
4、对象用花括号:{} 来解构对象 (要属性名properties)
let {name} = {name: ""Faraji"", age: 23}; 
//对应属性名name
console.log(name);
Highlight:memory region
Sticky notes:1、因为属性只是抓住值,而不是拥有值
对象或数组在电脑里面只是一些队列,这些队列包含了每一个包含值/属性值 的物理地址

2、所以一个数组包含了其他数组 就可能有多个地址空间
至少一个地址空间 给 内置的数组a
另一个地址空间 给 外置的数组b (这个地址空间给出了内置数组的地址)
let a = [1, 2, 3]
let b = [a, 3]
console.log(b)

哎 有点绕 就理解多个地址就行
Highlight:JavaScript Object Notation
Sticky notes:1、第一段大堆讨论就是说 这些数据都是存在内存里面特别杂乱 如果要到互联网传播 一种笨方法就是 解决这些铰在一起的地址 然后存储或者发送
2、另一种方法 就是 定义一种通用的数据格式
JSON(JavaScript Object NOtation) 闪亮登场
应用广泛不止于 js
Highlight:double quotes
Sticky notes:JSON格式有点像 js 里面的数组
1、属性名 properties 必须用双引号引起来
2、值只能是简单表达 数布尔值//字符串/数组/对象等,
不能是函数/绑定/计算
3、JSON不能注释
Highlight:<code>JSON.stringify</code> and <code>JSON.parse</code>
Sticky notes:1、JSON.stringify 
将对象编码成JSON格式
2、JSON.parse
将JSON解码成对象
(这里编码的不一定是对象 其他同理 只是通常对象方便使用)
Highlight:Summary
Sticky notes:1、对象和数组(整合基础值成集合)

2、对象和数组的 属性 properties

3、对象和数组的 方法 methods 
[注意 调用methods 通常用到 对象或数组的值]

4、let of 循环

这总结粗略 而且 不优美
","2020-04-30 08:01:48"
"Modules :: Eloquent JavaScript","https://eloquentjavascript.net/10_modules.html","no_tag","","","Highlight:Modules
Sticky notes:(总感觉这章说的话绕来绕去 不像别的章概念很明朗 难道不是同一个作者?)
Highlight:So it is tempting to neglect it and allow the parts of the program to become deeply entangled.
Sticky notes:这里 主要英语比较饶人(So it is tempting to neglect it这是啥? 阅读理解吗?) 理清一下

1、理想的程序都有清晰的结构 他工作的方式很容易理清楚 每个部分担任自己的角色

2、从一开始就要建立有structing结构的项目, 每个新功能会自然的增长 让程序壮大
由于这些工作短期看不出来 很容易被忽视 但在未来别人看你的项目是很有效的 就避免纠缠不清
Highlight:This causes two practical issues
Sticky notes:下面说 纠缠一起的坏处 (就像有的程序不写函数 不写模组 一写到底 很多功能纠缠在一起)
1、别人理解系统很困难 有的功能和别的功能纠结在一起 要理解就要被迫看整体的项目 再去理解某个功能
2、如果想要单独用某个功能 会很困难 把纠结在一起的解开

3、这样的项目就像“泥团”
Highlight:Module interfaces
Highlight:dependencies
Highlight:scope
Highlight:Designing
Sticky notes:1、用Modules模组和interfaces接口解决这个问题:
模组module=内部私有需要的程序（可能也调用了别人的接口）+提供外界调用的接口

模组接口interface很像对象接口(就是 rabbit.speak() 这种 也是封装 给别人调用)

2、搞清楚模组之间的“依赖”.就是一个模组依赖另一个模组 弄清关系 就能自动加载，这个“自动加载”也需要程序来实现，是按需加载

3、模组之间的作用域 避免大家都用一个全局作用域 变量绑定之间互相干扰 并且依赖结构不清晰 后面有办法解决

4、设计一个合适的模组系统比较困难:
可能在设计程序的时候,分模组结构会分散注意力,不想关心.但是一旦感觉某个程序 变成一大块 像泥巴混在一起 就要退一步 重组一下
Highlight:the time and f
Sticky notes:一大堆废话说package咋运作的,精简如下
1、将项目变成独立的部分运行有好处是:
可以在不同的项目里面用相同的代码

2、举例: 比如想用第九章的parseINI函数, 直接copy过去使用 当有错误的时候 每个coppy到的地方都要更改

3、一旦开始copy代码 自己就可能发现浪费很多时间挪动更新代码

4、这个就是包package的工作原理,一个包是一串可以发布的代码,
它可能包含很多模组modules或者这个包依赖的别的包 
它还一般有个 README,md文件告诉你怎么用

5、当包被发现有问题 就更新包 然后其他依赖这个包的更新 就可以随之更新
Highlight:package
Sticky notes:划重点: 你知道 package和modules的区别吗?

1、模块可以是任何一个文件或目录 只要能被node.js通过require加载即可
包是一个文件或目录 必须有一个package.json文件来描述，里面有多个模块

2、npm 上所有代码都是一个包 但是只有能通过require来加载的叫做模块

3、一个a.js文件就可以是一个模块
把a.js和用来描述它的package.json文件放在同一个文件夹下那么就可以称作一个包

4、包含package.json文件的文件夹名字不要包含大写字母和中文

5、模块 + package.json = 包
Highlight:Working in this way requires infrastructure. We need a place to store and find
Sticky notes:⬆️  绪论 包
——————————————
⬇️  NPM
Highlight:NPM
Sticky notes:NPM就是一个很好的包管理工具

有很多别人写好的现成的包(经过可靠的测试和实践),但是有些包也是垃圾

第20章nodejs 会详细的讲一讲 怎么用npm下载包
Highlight:Software is cheap to copy, so once someone has written it, distributing it to
Sticky notes:⬆️  NPM
——————————
⬇️  许可证 license
Highlight:copyright
Sticky notes:第一次写一个需要大量的工作 修改bug也是大量的工作

因此有copyright的问题 牵扯到许可证license,多种情况:


1、有些人想在程序圈出名 明确的给一个license让你随便使用他的代码
2、某些许可证要求您还发布在同一许可证下基于软件包构建的代码。
3、其他人的要求不高，仅要求您在分发许可证时将许可证与代码保持在一起。(JS社区通常这样)
(区别? 搞不懂现在 2和3 可能自己发布的时候才晓得吧)

用npm包之前 明确认识 license
Highlight:Until 2015, the JavaScript language had no built-in module system
Sticky notes:2015年前 js都没有内置的模组系统 
但是大家要使用模组 所以当年大家自己手动写庞大的系统(用函数构建本地作用域或者用对象) 来构建模组

下面是个小例子，在函数表达式里隐藏了内部names的作用域， 敲一敲试一下
Highlight:obsolete
Sticky notes:1、这种风格编程一定程度提供了独立性 但是不会声明依赖关系 相反，它只是将其接口放入全局范围，并期望其依赖项（如果有）也可以这样做。 (坏处 过时)

2、如果要使依赖关系成为代码的一部分，则必须控制加载依赖项。 为此，需要能够将字符串作为代码执行。 JavaScript可以做到这一点。
Highlight:ways to take data (a string of code)
Sticky notes:承接上面: 为了控制加载依赖项(作用域) 要讲data(字符串)解析成代码运行
(其实有点迷 他说的依赖项的关系 应该主要是命名空间, 要让模组单独封装在一个scope里面 不受外界干扰)

这个应该说的是js实现模组系统的背后原理方法，有两种：
1、eval函数
2、Function函数
Highlight:eval
Sticky notes:两种方法
1、 eval操作符(不推荐 因为会在当前scope执行代码 然后破坏了 本scope里面的一些properties属性(全局变量?))
 such as it being easily predictable which binding a given name refers to. 这句不太懂干啥的

2、Function构建函数 (推荐 传入多个参数 前面是函数参数 后面是函数体 会封装在一个scope里面 不会被干扰)
Highlight:Function
Highlight:CommonJS
Sticky notes:详细介绍CommonJS，分成三个部分
1、三段介绍CommonJS

2、一个具体例子使用CommonJS（exports和require）
const {formatDate} = require(""./format-date"");

3、用代码写一个最简单的require并讲一堆不懂的介绍require原理
function require(name) {}
Highlight:require
Sticky notes:前三段介绍原理
1、JS和Node.js的NPM 用的最广泛模组系统是CommonJS
2、CommonJS模组系统主要概念是require，当用require调用一个模组名，它会保证模组被加载并且返回接口
3、因为loader将模组代码封装在一个函数里，模组自动获取本地scope，他们要做的是用require获取依赖并且把接口放到和exports绑定的对象里去（modules.exports）
Highlight:This example module provides a date-formatting function. It uses two packages
Sticky notes:⬆️  介绍CommonJS的特点
——————————————————
⬇️  利用CommonJS做一个小例子，实验如何使用
Highlight:The template string
Sticky notes:为了实现下面小例子，用到了三个小难点：
1、const ordinal = require(""ordinal""); 这个包
将日期数字 1 3 5 13这种这种 1st 3rd 5th 13th样子

2、const {days, months} = require(""date-names""); 
这个很菜 还搞个包
days=
[
0:	""Sunday""
1:	""Monday""
2:	""Tuesday""
3:	""Wednesday""
4:	""Thursday""
5:	""Friday""
6:	""Saturday""
]
months同理就是 March April这样十二个月 有英文名字

3、return format.replace(/YYYY|M(MMM)?|Do?|dddd/g, tag => {
这里format是模版字符串，看他下面的调用
console.log(formatDate(new Date(2017, 9, 13),
                       ""dddd MMMM D""));
这里 ""dddd MMMM D""就是指明要输出的格式，我们就是根据“dddd”这种东西来作为模版不同条件生成最后自定义的结果

4、还有可能有点绕的是date的一堆方法
getFullYear / getDate  / getDay 可能要自己去查阅 就好

这个有点本末倒置，本来讲模组的，搞个稍微有点绕人复杂的东西胡来更搞不清了，模组的应用很简单
Highlight:We can define <code>require</code>, in its most minimal form, like this:
Sticky notes:⬆️  简单使用自定义 一个 我们的 formateDate模组 然后调用学一下
——————————————————
⬇️  用最简单的逻辑 定义说明一下 require背后的原理（了解理解即可，深入还是要看别的资料）
Highlight:In this code,
Sticky notes:我也觉得好复杂好麻烦，但这可以看作深入底层的入门解释，还是了解清除一下，我帮你分段提炼意思：

1、代码里readFile函数是伪代码，因为需要
const {formatDate} = require(""./format-date"");这种样子读取本地文件，实际应用会在浏览器环境/nodejs环境有读取本地文件的特定方法，readFile是代表一下

2、为了防止重复加载包，我们定义一个cache缓存保存已经加载了的包，已经有被加载的就不重复加载，没有被加载则执行函数加载（读取模组代码+封装到函数+调用）

3、就是说正规来说，modules应该返回object，但是如果你想返回一个function，你作为开发者可以操作重写module.exports 来自定义 来只返回一个值（函数ordinal看成一个值也行）而不是对象

4、这里wrapper，把模组里的code封装一下：
let wrapper = Function(""require, exports, module"", code);
    wrapper(require, module.exports, module);
目的是为了保证在模组那些require和exports能在正确的作用域里有效

5、引入路径也有点讲究：
const {formatDate} = require(""./format-date"")
a、当是 ./ 或 ../开头就是相对路径，然后后面省略.js，实际上引用的是本路径下的format-date.js文件
b、当不是相对路径 就是指npm包 到第20章仔细学，实际上是到node_modules文件夹里去引入，像
const {parse} = require(""ini"")
Highlight:<code>require</code> is a normal function call
Sticky notes:require的模组比较好又有优点 帮助在NPM上广泛分享包，但是也有缺点：

1、语法有点奇怪，增加到exports的东西本地作用域不可用
2、因为调用形式
const {parse} = require(""ini"");
这个require是个函数，可以传入任何形式的函数参数，只有在代码运行的时候才能知道模组的以来关系
Highlight:This is why the JavaScript standard from 2015 introduces its own, different
Sticky notes:⬆️  说一下用2015年之前的一直用的 require的缺点
————————————————————
⬇️  介绍新的 ES modules的特点和使用代码块
Highlight:details differ
Sticky notes:所以es6新推出了 ES module语法，理念还是和require保持一致，但是细节不一样了

1、第一点不再用调用require的形式，现在是用js内置的一个关键字import

2、增加了export来导出需要导出的东西，可以是任何东西：函数、类或者绑定的变量都可以

3、然后之前我们require导入的只是一个值
const {parse} = require(""ini"");
比如这样 我们只是导入了一个parse的值

但是ES module是 引入了一组绑定的变量
因为下面这种样子
import ordinal from ""ordinal"";
这样子是引入的绑定，然后如果“ordinal”这个包里 的代码根据程序运行改变了 也能同时改变到引入这个包的 主程序里 这是与以前的不同
Highlight:When there is a binding named <code>default</code>, it is treated as the module’s main
Sticky notes:⬆️  ES modules基本概念
————————————————
⬇️  ES modules里的default咋用
Highlight:default
Sticky notes:这里莫名其妙说明一些 ES module应用的小点：

1、default
就是自定义模组的默认导出绑定
import ordinal from ""ordinal""
就是这种，其实名字可以随便取，像下面这样
import abc from ""ordinal"";
console.log(abc);
// → function ordinal (i){…}
因为default只有默认一个，你就可以随便改变名字

然后定义default的方法可以这样：
export default [""Winter"", ""Spring"", ""Summer"", ""Autumn""];

（还提一下用花括号的情况是 有多个 export比如
import {days, months} from ""date-names"";
上面这种，那么模组背后就是有
export days = ...
export months = ...
这样子 必须要花括号
）


2、as就是把导入的包自己定义好用的名字
import {days as dayNames} from ""date-names"";
好理解
Highlight:Another important difference is that ES module imports happen before a
Sticky notes:⬆️  :ES modules的default
————————————————————
⬇️  :ES modules的不同的特性
Highlight:That means <code>import</code> declarations may not appear inside functions or blocks
Sticky notes:1、ES modules 的一个对比require的重要区别就是ES modules在程序运行之前就发生了，不像const require(...) 以前的方式是程序运行的时候去看函数require里的参数是什么具体内容，这样 import 只能导入纯字符串的引号，而不是任意表达式了

2、就是这个新的ES module语法还在推广中，虽然大部分都支持了，但是情况是require和ES module两种模式都在并行存在 学会使用两种是最好的
Highlight:Building and bundling
Sticky notes:这里真的需要自己写过一段代码之后才能理解，第一次肯定不好理解，但有我在呀：

啥意思呢，其实就是webpack的思想，推荐你们深入学习一下webpack

从上到下讲他的思路：
1、第一点是 通常我们会用一些预处理语言比如TypeScript，Sass这种更强大的语言，但是这种语言不能在实际的浏览器中运行，从开发环境用这种语言到运行环境就需要 “compile” 编译，将新定义的复杂语言编译成原始的JavaScript

2、第二点是如果我们一个项目有大量的modules，需要相互引入，那么一个程序引入很多个小的modules会花费很多事件，如果只是运行一个大文件就很快，因此 我们需要用到“bundlers” 来打包成一个 就会有比较好效率

3、第三点就是，我们还想优化我们的代码，比如删除注释，缩减空格，这样在互联网上传播打开网页会更快，我们又需要用到 “minifiers” 来缩减文件大小

上面三点 全都是 webpack（打包工具的一种，主流）能干的事情，所以需要你们去学习webpack

4、所以实际上我们使用的NPM包或者是网上的网页都是经过多种转换器转换而成的，这本书不讲太多，只是有些概念，有些js代码是自动生成的 所以看起来有点怪（比如一大长条挤在一起）
Highlight:Module design
Sticky notes:下面是一大堆一大堆的 英文，搞的像英语阅读理解一样

真的文字太多了，希望有个有缘人能用心读完 总结改进这里的注释

理清作者从上到下想表达的意思
Highlight:Good program design
Sticky notes:设计好的程序结构：

就像“软件工程”一门课的设计，腰设计好的程序 让每个接口和方法都能有机的组合在一起
（这里也是浅显的说，能有精力看下去的小伙伴总结一下这里吧，我是搞不下去了）
Highlight:after you’ve worked with it once, you’re likely to remember how to use it.
Sticky notes:⬆️  上面只是简单说一下 如何设计 有效的模组系统比如（名字和接口都很好区分好理解，各部分有机组织）
————————————————————
⬇️  下面就有些迷惑了，看了半天，大体意思应该是，我们不是可以定义一些包吗，但是有些包不能单独使用，可能需要额外的代码（比如新定义数据结构），组合到自己代码，我勒个去看了半天一大堆话
Highlight:composed
Sticky notes:待定 有缘人总结

其实这里不读完也没太大关系 本来很抽象 理解下面的例子更好
Highlight:An example of a slightly more complex data structure is the graph from
Sticky notes:⬆️  modules组合代码的概念
————————————————
⬇️  一个具体小例子 比如第七章的寻路算法
Highlight:So if we wanted to use that package, we’d have to make sure that our graph was stored in the format it expects.
Sticky notes:这句很清晰，就是如果我们需要用别人的包，我们需要按照别人定义的方式存储数据，搭配别人写好的接口使用，这就是 “composition” 组合

可以自定义好合适自己包的 数据结构 data structures
Highlight:Summary
Sticky notes:潦草总结：
1、modules的基础概念：提供接口，让其他模组调用

2、js内置没有模组系统，由于历史上需要用我们用CommonJS系统自己构建出模组系统，然后到es6推出了内置的import的模组系统ES module

3、一个package 是一堆可以发布的代码 NPM是一个很好的js包的库 可以下载好用的包
","2020-04-30 01:06:49"
"Try PDF annotation - Active Reading: The Art of Annotation","https://www.diigo.com/item/pdf/7hfoz/evi8","no_tag","","","","2020-04-30 01:03:06"
